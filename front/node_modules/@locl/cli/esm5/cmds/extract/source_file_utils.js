/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/source_file_utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __extends, __values } from "tslib";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵisMissingTranslationError, ɵmakeTemplateObject, ɵtranslate } from '@angular/localize';
import * as t from '@babel/types';
/**
 * Is the given `expression` an identifier with the correct name
 * @param {?} expression The expression to check.
 * @param {?} name
 * @return {?}
 */
export function isNamedIdentifier(expression, name) {
    return expression.isIdentifier() && expression.node.name === name;
}
/**
 * Is the given `identifier` declared globally.
 * @param {?} identifier The identifier to check.
 * @return {?}
 */
export function isGlobalIdentifier(identifier) {
    return (!identifier.scope || !identifier.scope.hasBinding(identifier.node.name));
}
/**
 * Build a translated expression to replace the call to `$localize`.
 * @param {?} messageParts The static parts of the message.
 * @param {?} substitutions The expressions to substitute into the message.
 * @return {?}
 */
export function buildLocalizeReplacement(messageParts, substitutions) {
    /** @type {?} */
    var mappedString = t.stringLiteral(messageParts[0]);
    for (var i = 1; i < messageParts.length; i++) {
        mappedString = t.binaryExpression('+', mappedString, wrapInParensIfNecessary(substitutions[i - 1]));
        mappedString = t.binaryExpression('+', mappedString, t.stringLiteral(messageParts[i]));
    }
    return mappedString;
}
/**
 * Extract the message parts from the given `call` (to `$localize`).
 *
 * The message parts will either by the first argument to the `call` or it will be wrapped in call
 * to a helper function like `__makeTemplateObject`.
 *
 * @param {?} call The AST node of the call to process.
 * @return {?}
 */
export function unwrapMessagePartsFromLocalizeCall(call) {
    /** @type {?} */
    var cooked = (/** @type {?} */ (call.get('arguments')[0]));
    if (cooked === undefined) {
        throw new BabelParseError(call.node, '`$localize` called without any arguments.');
    }
    if (!cooked.isExpression()) {
        throw new BabelParseError(cooked.node, 'Unexpected argument to `$localize` (expected an array).');
    }
    // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.
    /** @type {?} */
    var raw = cooked;
    // Check for cached call of the form `x || x = __makeTemplateObject(...)`
    if (cooked.isLogicalExpression() &&
        cooked.node.operator === '||' &&
        cooked.get('left').isIdentifier()) {
        /** @type {?} */
        var right = cooked.get('right');
        if (right.isAssignmentExpression()) {
            cooked = right.get('right');
            if (!cooked.isExpression()) {
                throw new BabelParseError(cooked.node, 'Unexpected "makeTemplateObject()" function (expected an expression).');
            }
        }
    }
    // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.
    if (cooked.isCallExpression()) {
        /** @type {?} */
        var cookedCall = cooked;
        if (cookedCall.get('arguments').length === 0) {
            // No arguments so perhaps it is a `__templateObject()` call.
            // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.
            cookedCall = unwrapLazyLoadHelperCall(cookedCall);
        }
        cooked = cookedCall.get('arguments')[0];
        if (!cooked.isExpression()) {
            throw new BabelParseError(cooked.node, 'Unexpected `cooked` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        /** @type {?} */
        var arg2 = cookedCall.get('arguments')[1];
        if (arg2 && !arg2.isExpression()) {
            throw new BabelParseError(arg2.node, 'Unexpected `raw` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        // If there is no second argument then assume that raw and cooked are the same
        raw = arg2 !== undefined ? arg2 : cooked;
    }
    /** @type {?} */
    var cookedStrings = unwrapStringLiteralArray(cooked.node);
    /** @type {?} */
    var rawStrings = unwrapStringLiteralArray(raw.node);
    return ɵmakeTemplateObject(cookedStrings, rawStrings);
}
/**
 * @param {?} call
 * @return {?}
 */
export function unwrapSubstitutionsFromLocalizeCall(call) {
    /** @type {?} */
    var expressions = call.arguments.splice(1);
    if (!isArrayOfExpressions(expressions)) {
        /** @type {?} */
        var badExpression = (/** @type {?} */ (expressions.find((/**
         * @param {?} expression
         * @return {?}
         */
        function (expression) { return !t.isExpression(expression); }))));
        throw new BabelParseError(badExpression, 'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).');
    }
    return expressions;
}
/**
 * @param {?} elements
 * @return {?}
 */
export function unwrapMessagePartsFromTemplateLiteral(elements) {
    /** @type {?} */
    var cooked = elements.map((/**
     * @param {?} q
     * @return {?}
     */
    function (q) {
        if (q.value.cooked === undefined) {
            throw new BabelParseError(q, "Unexpected undefined message part in \"" + elements.map((/**
             * @param {?} eq
             * @return {?}
             */
            function (eq) { return eq.value.cooked; })) + "\"");
        }
        return q.value.cooked;
    }));
    /** @type {?} */
    var raw = elements.map((/**
     * @param {?} q
     * @return {?}
     */
    function (q) { return q.value.raw; }));
    return ɵmakeTemplateObject(cooked, raw);
}
/**
 * Wrap the given `expression` in parentheses if it is a binary expression.
 *
 * This ensures that this expression is evaluated correctly if it is embedded in another expression.
 *
 * @param {?} expression The expression to potentially wrap.
 * @return {?}
 */
export function wrapInParensIfNecessary(expression) {
    if (t.isBinaryExpression(expression)) {
        return t.parenthesizedExpression(expression);
    }
    else {
        return expression;
    }
}
/**
 * Extract the string values from an `array` of string literals.
 * @param {?} array The array to unwrap.
 * @return {?}
 */
export function unwrapStringLiteralArray(array) {
    if (!isStringLiteralArray(array)) {
        throw new BabelParseError(array, 'Unexpected messageParts for `$localize` (expected an array of strings).');
    }
    return array.elements.map((/**
     * @param {?} str
     * @return {?}
     */
    function (str) { return str.value; }));
}
/**
 * This expression is believed to be a call to a "lazy-load" template object helper function.
 * This is expected to be of the form:
 *
 * ```ts
 *  function _templateObject() {
 *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);
 *    return _templateObject = function() { return e }, e
 *  }
 * ```
 *
 * We unwrap this to return the call to `_taggedTemplateLiteral()`.
 *
 * @param {?} call the call expression to unwrap
 * @return {?} the  call expression
 */
export function unwrapLazyLoadHelperCall(call) {
    /** @type {?} */
    var callee = (/** @type {?} */ (call.get('callee')));
    if (!callee.isIdentifier()) {
        throw new BabelParseError(callee.node, 'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).');
    }
    /** @type {?} */
    var lazyLoadBinding = call.scope.getBinding(callee.node.name);
    if (!lazyLoadBinding) {
        throw new BabelParseError(callee.node, 'Missing declaration for lazy-load helper function');
    }
    /** @type {?} */
    var lazyLoadFn = lazyLoadBinding.path;
    if (!lazyLoadFn.isFunctionDeclaration()) {
        throw new BabelParseError(((/** @type {?} */ (lazyLoadFn))).node, 'Unexpected expression (expected a function declaration');
    }
    /** @type {?} */
    var returnedNode = getReturnedExpression(lazyLoadFn);
    if (returnedNode.isCallExpression()) {
        return returnedNode;
    }
    if (returnedNode.isIdentifier()) {
        /** @type {?} */
        var identifierName = returnedNode.node.name;
        /** @type {?} */
        var declaration = returnedNode.scope.getBinding(identifierName);
        if (declaration === undefined) {
            throw new BabelParseError(returnedNode.node, 'Missing declaration for return value from helper.');
        }
        if (!declaration.path.isVariableDeclarator()) {
            throw new BabelParseError(((/** @type {?} */ (declaration))).path.node, 'Unexpected helper return value declaration (expected a variable declaration).');
        }
        /** @type {?} */
        var initializer = declaration.path.get('init');
        if (!initializer.isCallExpression()) {
            throw new BabelParseError(declaration.path.node, 'Unexpected return value from helper (expected a call expression).');
        }
        // Remove the lazy load helper if this is the only reference to it.
        if (lazyLoadBinding.references === 1) {
            lazyLoadFn.remove();
        }
        return initializer;
    }
    return call;
}
/**
 * @param {?} fn
 * @return {?}
 */
function getReturnedExpression(fn) {
    var e_1, _a;
    /** @type {?} */
    var bodyStatements = ((/** @type {?} */ (fn.get('body')))).get('body');
    try {
        for (var bodyStatements_1 = __values(bodyStatements), bodyStatements_1_1 = bodyStatements_1.next(); !bodyStatements_1_1.done; bodyStatements_1_1 = bodyStatements_1.next()) {
            var statement = bodyStatements_1_1.value;
            if (statement.isReturnStatement()) {
                /** @type {?} */
                var argument = statement.get('argument');
                if (argument.isSequenceExpression()) {
                    /** @type {?} */
                    var expressions = argument.get('expressions');
                    return Array.isArray(expressions)
                        ? expressions[expressions.length - 1]
                        : expressions;
                }
                else if (argument.isExpression()) {
                    return argument;
                }
                else {
                    throw new BabelParseError(statement.node, 'Invalid return argument in helper function (expected an expression).');
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (bodyStatements_1_1 && !bodyStatements_1_1.done && (_a = bodyStatements_1.return)) _a.call(bodyStatements_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    throw new BabelParseError(fn.node, 'Missing return statement in helper function.');
}
/**
 * Is the given `node` an array of literal strings?
 *
 * @param {?} node The node to test.
 * @return {?}
 */
export function isStringLiteralArray(node) {
    return (t.isArrayExpression(node) &&
        node.elements.every((/**
         * @param {?} element
         * @return {?}
         */
        function (element) { return t.isStringLiteral(element); })));
}
/**
 * Are all the given `nodes` expressions?
 * @param {?} nodes The nodes to test.
 * @return {?}
 */
export function isArrayOfExpressions(nodes) {
    return nodes.every((/**
     * @param {?} element
     * @return {?}
     */
    function (element) { return t.isExpression(element); }));
}
/**
 * Options that affect how the `makeEsXXXTranslatePlugin()` functions work.
 * @record
 */
export function TranslatePluginOptions() { }
if (false) {
    /** @type {?|undefined} */
    TranslatePluginOptions.prototype.missingTranslation;
    /** @type {?|undefined} */
    TranslatePluginOptions.prototype.localizeName;
}
/**
 * Translate the text of the given message, using the given translations.
 *
 * Logs as warning if the translation is not available
 * @param {?} diagnostics
 * @param {?} translations
 * @param {?} messageParts
 * @param {?} substitutions
 * @param {?} missingTranslation
 * @return {?}
 */
export function translate(diagnostics, translations, messageParts, substitutions, missingTranslation) {
    try {
        return ɵtranslate(translations, messageParts, substitutions);
    }
    catch (e) {
        if (ɵisMissingTranslationError(e)) {
            if (missingTranslation === 'error') {
                diagnostics.error(e.message);
            }
            else if (missingTranslation === 'warning') {
                diagnostics.warn(e.message);
            }
            // Return the parsed message because this will have the meta blocks stripped
            return [
                ɵmakeTemplateObject(e.parsedMessage.messageParts, e.parsedMessage.messageParts),
                substitutions
            ];
        }
        else {
            diagnostics.error(e.message);
            return [messageParts, substitutions];
        }
    }
}
var BabelParseError = /** @class */ (function (_super) {
    __extends(BabelParseError, _super);
    function BabelParseError(node, message) {
        var _this = _super.call(this, message) || this;
        _this.node = node;
        _this.type = 'BabelParseError';
        return _this;
    }
    return BabelParseError;
}(Error));
export { BabelParseError };
if (false) {
    /**
     * @type {?}
     * @private
     */
    BabelParseError.prototype.type;
    /** @type {?} */
    BabelParseError.prototype.node;
}
/**
 * @param {?} e
 * @return {?}
 */
export function isBabelParseError(e) {
    return e.type === 'BabelParseError';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic291cmNlX2ZpbGVfdXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbG9jbC9jbGkvIiwic291cmNlcyI6WyJjbWRzL2V4dHJhY3Qvc291cmNlX2ZpbGVfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQU9BLE9BQU8sRUFFTCwwQkFBMEIsRUFDMUIsbUJBQW1CLEVBQ25CLFVBQVUsRUFDWCxNQUFNLG1CQUFtQixDQUFDO0FBRTNCLE9BQU8sS0FBSyxDQUFDLE1BQU0sY0FBYyxDQUFDOzs7Ozs7O0FBUWxDLE1BQU0sVUFBVSxpQkFBaUIsQ0FDL0IsVUFBb0IsRUFDcEIsSUFBWTtJQUVaLE9BQU8sVUFBVSxDQUFDLFlBQVksRUFBRSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQztBQUNwRSxDQUFDOzs7Ozs7QUFNRCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsVUFBa0M7SUFDbkUsT0FBTyxDQUNMLENBQUMsVUFBVSxDQUFDLEtBQUssSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ3hFLENBQUM7QUFDSixDQUFDOzs7Ozs7O0FBT0QsTUFBTSxVQUFVLHdCQUF3QixDQUN0QyxZQUFrQyxFQUNsQyxhQUFzQzs7UUFFbEMsWUFBWSxHQUFpQixDQUFDLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUM1QyxZQUFZLEdBQUcsQ0FBQyxDQUFDLGdCQUFnQixDQUMvQixHQUFHLEVBQ0gsWUFBWSxFQUNaLHVCQUF1QixDQUFDLGFBQWEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDOUMsQ0FBQztRQUNGLFlBQVksR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQy9CLEdBQUcsRUFDSCxZQUFZLEVBQ1osQ0FBQyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDakMsQ0FBQztLQUNIO0lBQ0QsT0FBTyxZQUFZLENBQUM7QUFDdEIsQ0FBQzs7Ozs7Ozs7OztBQVVELE1BQU0sVUFBVSxrQ0FBa0MsQ0FDaEQsSUFBZ0M7O1FBRTVCLE1BQU0sR0FBRyxtQkFBQSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFPO0lBRTVDLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtRQUN4QixNQUFNLElBQUksZUFBZSxDQUN2QixJQUFJLENBQUMsSUFBSSxFQUNULDJDQUEyQyxDQUM1QyxDQUFDO0tBQ0g7SUFDRCxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxFQUFFO1FBQzFCLE1BQU0sSUFBSSxlQUFlLENBQ3ZCLE1BQU0sQ0FBQyxJQUFJLEVBQ1gseURBQXlELENBQzFELENBQUM7S0FDSDs7O1FBR0csR0FBRyxHQUFHLE1BQU07SUFFaEIseUVBQXlFO0lBQ3pFLElBQ0UsTUFBTSxDQUFDLG1CQUFtQixFQUFFO1FBQzVCLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLElBQUk7UUFDN0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLEVBQUUsRUFDakM7O1lBQ00sS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO1FBQ2pDLElBQUksS0FBSyxDQUFDLHNCQUFzQixFQUFFLEVBQUU7WUFDbEMsTUFBTSxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsRUFBRTtnQkFDMUIsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsTUFBTSxDQUFDLElBQUksRUFDWCxzRUFBc0UsQ0FDdkUsQ0FBQzthQUNIO1NBQ0Y7S0FDRjtJQUVELCtFQUErRTtJQUMvRSxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFOztZQUN6QixVQUFVLEdBQUcsTUFBTTtRQUN2QixJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM1Qyw2REFBNkQ7WUFDN0QscUVBQXFFO1lBQ3JFLFVBQVUsR0FBRyx3QkFBd0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUNuRDtRQUVELE1BQU0sR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLEVBQUU7WUFDMUIsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsTUFBTSxDQUFDLElBQUksRUFDWCwrRkFBK0YsQ0FDaEcsQ0FBQztTQUNIOztZQUNLLElBQUksR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBRTtZQUNoQyxNQUFNLElBQUksZUFBZSxDQUN2QixJQUFJLENBQUMsSUFBSSxFQUNULDRGQUE0RixDQUM3RixDQUFDO1NBQ0g7UUFDRCw4RUFBOEU7UUFDOUUsR0FBRyxHQUFHLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0tBQzFDOztRQUVLLGFBQWEsR0FBRyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDOztRQUNyRCxVQUFVLEdBQUcsd0JBQXdCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztJQUNyRCxPQUFPLG1CQUFtQixDQUFDLGFBQWEsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN4RCxDQUFDOzs7OztBQUVELE1BQU0sVUFBVSxtQ0FBbUMsQ0FDakQsSUFBc0I7O1FBRWhCLFdBQVcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDNUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxFQUFFOztZQUNoQyxhQUFhLEdBQUcsbUJBQUEsV0FBVyxDQUFDLElBQUk7Ozs7UUFDcEMsVUFBQSxVQUFVLElBQUksT0FBQSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQTNCLENBQTJCLEVBQzFDLEVBQUM7UUFDRixNQUFNLElBQUksZUFBZSxDQUN2QixhQUFhLEVBQ2IsZ0dBQWdHLENBQ2pHLENBQUM7S0FDSDtJQUNELE9BQU8sV0FBVyxDQUFDO0FBQ3JCLENBQUM7Ozs7O0FBRUQsTUFBTSxVQUFVLHFDQUFxQyxDQUNuRCxRQUE2Qjs7UUFFdkIsTUFBTSxHQUFHLFFBQVEsQ0FBQyxHQUFHOzs7O0lBQUMsVUFBQSxDQUFDO1FBQzNCLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxlQUFlLENBQ3ZCLENBQUMsRUFDRCw0Q0FBeUMsUUFBUSxDQUFDLEdBQUc7Ozs7WUFDbkQsVUFBQSxFQUFFLElBQUksT0FBQSxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBZixDQUFlLEVBQ3RCLE9BQUcsQ0FDTCxDQUFDO1NBQ0g7UUFDRCxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQ3hCLENBQUMsRUFBQzs7UUFDSSxHQUFHLEdBQUcsUUFBUSxDQUFDLEdBQUc7Ozs7SUFBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFYLENBQVcsRUFBQztJQUMxQyxPQUFPLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMxQyxDQUFDOzs7Ozs7Ozs7QUFTRCxNQUFNLFVBQVUsdUJBQXVCLENBQ3JDLFVBQXdCO0lBRXhCLElBQUksQ0FBQyxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQ3BDLE9BQU8sQ0FBQyxDQUFDLHVCQUF1QixDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQzlDO1NBQU07UUFDTCxPQUFPLFVBQVUsQ0FBQztLQUNuQjtBQUNILENBQUM7Ozs7OztBQU1ELE1BQU0sVUFBVSx3QkFBd0IsQ0FBQyxLQUFtQjtJQUMxRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsS0FBSyxFQUNMLHlFQUF5RSxDQUMxRSxDQUFDO0tBQ0g7SUFDRCxPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRzs7OztJQUFDLFVBQUMsR0FBb0IsSUFBSyxPQUFBLEdBQUcsQ0FBQyxLQUFLLEVBQVQsQ0FBUyxFQUFDLENBQUM7QUFDakUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkQsTUFBTSxVQUFVLHdCQUF3QixDQUN0QyxJQUFnQzs7UUFFMUIsTUFBTSxHQUFHLG1CQUFBLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQU87SUFDeEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsRUFBRTtRQUMxQixNQUFNLElBQUksZUFBZSxDQUN2QixNQUFNLENBQUMsSUFBSSxFQUNYLHFGQUFxRixDQUN0RixDQUFDO0tBQ0g7O1FBQ0ssZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQy9ELElBQUksQ0FBQyxlQUFlLEVBQUU7UUFDcEIsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsTUFBTSxDQUFDLElBQUksRUFDWCxtREFBbUQsQ0FDcEQsQ0FBQztLQUNIOztRQUNLLFVBQVUsR0FBRyxlQUFlLENBQUMsSUFBSTtJQUN2QyxJQUFJLENBQUMsVUFBVSxDQUFDLHFCQUFxQixFQUFFLEVBQUU7UUFDdkMsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsQ0FBQyxtQkFBQSxVQUFVLEVBQU8sQ0FBQyxDQUFDLElBQUksRUFDeEIsd0RBQXdELENBQ3pELENBQUM7S0FDSDs7UUFDSyxZQUFZLEdBQUcscUJBQXFCLENBQUMsVUFBVSxDQUFDO0lBRXRELElBQUksWUFBWSxDQUFDLGdCQUFnQixFQUFFLEVBQUU7UUFDbkMsT0FBTyxZQUFZLENBQUM7S0FDckI7SUFFRCxJQUFJLFlBQVksQ0FBQyxZQUFZLEVBQUUsRUFBRTs7WUFDekIsY0FBYyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSTs7WUFDdkMsV0FBVyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztRQUNqRSxJQUFJLFdBQVcsS0FBSyxTQUFTLEVBQUU7WUFDN0IsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsWUFBWSxDQUFDLElBQUksRUFDakIsbURBQW1ELENBQ3BELENBQUM7U0FDSDtRQUNELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEVBQUU7WUFDNUMsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsQ0FBQyxtQkFBQSxXQUFXLEVBQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQzlCLCtFQUErRSxDQUNoRixDQUFDO1NBQ0g7O1lBQ0ssV0FBVyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQztRQUNoRCxJQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFnQixFQUFFLEVBQUU7WUFDbkMsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQ3JCLG1FQUFtRSxDQUNwRSxDQUFDO1NBQ0g7UUFFRCxtRUFBbUU7UUFDbkUsSUFBSSxlQUFlLENBQUMsVUFBVSxLQUFLLENBQUMsRUFBRTtZQUNwQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDckI7UUFFRCxPQUFPLFdBQVcsQ0FBQztLQUNwQjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQzs7Ozs7QUFFRCxTQUFTLHFCQUFxQixDQUM1QixFQUFtQzs7O1FBRTdCLGNBQWMsR0FBRyxDQUFDLG1CQUFBLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUM7O1FBQzFELEtBQXdCLElBQUEsbUJBQUEsU0FBQSxjQUFjLENBQUEsOENBQUEsMEVBQUU7WUFBbkMsSUFBTSxTQUFTLDJCQUFBO1lBQ2xCLElBQUksU0FBUyxDQUFDLGlCQUFpQixFQUFFLEVBQUU7O29CQUMzQixRQUFRLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7Z0JBQzFDLElBQUksUUFBUSxDQUFDLG9CQUFvQixFQUFFLEVBQUU7O3dCQUM3QixXQUFXLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7b0JBQy9DLE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7d0JBQy9CLENBQUMsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7d0JBQ3JDLENBQUMsQ0FBQyxXQUFXLENBQUM7aUJBQ2pCO3FCQUFNLElBQUksUUFBUSxDQUFDLFlBQVksRUFBRSxFQUFFO29CQUNsQyxPQUFPLFFBQVEsQ0FBQztpQkFDakI7cUJBQU07b0JBQ0wsTUFBTSxJQUFJLGVBQWUsQ0FDdkIsU0FBUyxDQUFDLElBQUksRUFDZCxzRUFBc0UsQ0FDdkUsQ0FBQztpQkFDSDthQUNGO1NBQ0Y7Ozs7Ozs7OztJQUNELE1BQU0sSUFBSSxlQUFlLENBQ3ZCLEVBQUUsQ0FBQyxJQUFJLEVBQ1AsOENBQThDLENBQy9DLENBQUM7QUFDSixDQUFDOzs7Ozs7O0FBT0QsTUFBTSxVQUFVLG9CQUFvQixDQUNsQyxJQUFZO0lBRVosT0FBTyxDQUNMLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLOzs7O1FBQUMsVUFBQSxPQUFPLElBQUksT0FBQSxDQUFDLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxFQUExQixDQUEwQixFQUFDLENBQzNELENBQUM7QUFDSixDQUFDOzs7Ozs7QUFNRCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsS0FBZTtJQUNsRCxPQUFPLEtBQUssQ0FBQyxLQUFLOzs7O0lBQUMsVUFBQSxPQUFPLElBQUksT0FBQSxDQUFDLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxFQUF2QixDQUF1QixFQUFDLENBQUM7QUFDekQsQ0FBQzs7Ozs7QUFHRCw0Q0FHQzs7O0lBRkMsb0RBQWdEOztJQUNoRCw4Q0FBc0I7Ozs7Ozs7Ozs7Ozs7QUFheEIsTUFBTSxVQUFVLFNBQVMsQ0FDdkIsV0FBd0IsRUFDeEIsWUFBZ0QsRUFDaEQsWUFBa0MsRUFDbEMsYUFBNkIsRUFDN0Isa0JBQThDO0lBRTlDLElBQUk7UUFDRixPQUFPLFVBQVUsQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0tBQzlEO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixJQUFJLDBCQUEwQixDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2pDLElBQUksa0JBQWtCLEtBQUssT0FBTyxFQUFFO2dCQUNsQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUM5QjtpQkFBTSxJQUFJLGtCQUFrQixLQUFLLFNBQVMsRUFBRTtnQkFDM0MsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDN0I7WUFDRCw0RUFBNEU7WUFDNUUsT0FBTztnQkFDTCxtQkFBbUIsQ0FDakIsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQzVCLENBQUMsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUM3QjtnQkFDRCxhQUFhO2FBQ2QsQ0FBQztTQUNIO2FBQU07WUFDTCxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM3QixPQUFPLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1NBQ3RDO0tBQ0Y7QUFDSCxDQUFDO0FBRUQ7SUFBcUMsbUNBQUs7SUFFeEMseUJBQW1CLElBQVksRUFBRSxPQUFlO1FBQWhELFlBQ0Usa0JBQU0sT0FBTyxDQUFDLFNBQ2Y7UUFGa0IsVUFBSSxHQUFKLElBQUksQ0FBUTtRQURkLFVBQUksR0FBRyxpQkFBaUIsQ0FBQzs7SUFHMUMsQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0FBQyxBQUxELENBQXFDLEtBQUssR0FLekM7Ozs7Ozs7SUFKQywrQkFBMEM7O0lBQzlCLCtCQUFtQjs7Ozs7O0FBS2pDLE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxDQUFNO0lBQ3RDLE9BQU8sQ0FBQyxDQUFDLElBQUksS0FBSyxpQkFBaUIsQ0FBQztBQUN0QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcbiAgybVQYXJzZWRUcmFuc2xhdGlvbixcbiAgybVpc01pc3NpbmdUcmFuc2xhdGlvbkVycm9yLFxuICDJtW1ha2VUZW1wbGF0ZU9iamVjdCxcbiAgybV0cmFuc2xhdGVcbn0gZnJvbSAnQGFuZ3VsYXIvbG9jYWxpemUnO1xuaW1wb3J0IHsgTm9kZVBhdGggfSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0ICogYXMgdCBmcm9tICdAYmFiZWwvdHlwZXMnO1xuaW1wb3J0IHsgUGFyc2VkVHJhbnNsYXRpb24gfSBmcm9tICdAYW5ndWxhci9sb2NhbGl6ZS9zcmMvdXRpbHMnO1xuaW1wb3J0IHsgRGlhZ25vc3RpY3MgfSBmcm9tICcuLi9jb21tb24vZGlhZ25vc3RpY3MnO1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBgZXhwcmVzc2lvbmAgYW4gaWRlbnRpZmllciB3aXRoIHRoZSBjb3JyZWN0IG5hbWVcbiAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIGNoZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lZElkZW50aWZpZXIoXG4gIGV4cHJlc3Npb246IE5vZGVQYXRoLFxuICBuYW1lOiBzdHJpbmdcbik6IGV4cHJlc3Npb24gaXMgTm9kZVBhdGgge1xuICByZXR1cm4gZXhwcmVzc2lvbi5pc0lkZW50aWZpZXIoKSAmJiBleHByZXNzaW9uLm5vZGUubmFtZSA9PT0gbmFtZTtcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gYGlkZW50aWZpZXJgIGRlY2xhcmVkIGdsb2JhbGx5LlxuICogQHBhcmFtIGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0dsb2JhbElkZW50aWZpZXIoaWRlbnRpZmllcjogTm9kZVBhdGg8dC5JZGVudGlmaWVyPikge1xuICByZXR1cm4gKFxuICAgICFpZGVudGlmaWVyLnNjb3BlIHx8ICFpZGVudGlmaWVyLnNjb3BlLmhhc0JpbmRpbmcoaWRlbnRpZmllci5ub2RlLm5hbWUpXG4gICk7XG59XG5cbi8qKlxuICogQnVpbGQgYSB0cmFuc2xhdGVkIGV4cHJlc3Npb24gdG8gcmVwbGFjZSB0aGUgY2FsbCB0byBgJGxvY2FsaXplYC5cbiAqIEBwYXJhbSBtZXNzYWdlUGFydHMgVGhlIHN0YXRpYyBwYXJ0cyBvZiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSBzdWJzdGl0dXRpb25zIFRoZSBleHByZXNzaW9ucyB0byBzdWJzdGl0dXRlIGludG8gdGhlIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExvY2FsaXplUmVwbGFjZW1lbnQoXG4gIG1lc3NhZ2VQYXJ0czogVGVtcGxhdGVTdHJpbmdzQXJyYXksXG4gIHN1YnN0aXR1dGlvbnM6IHJlYWRvbmx5IHQuRXhwcmVzc2lvbltdXG4pOiB0LkV4cHJlc3Npb24ge1xuICBsZXQgbWFwcGVkU3RyaW5nOiB0LkV4cHJlc3Npb24gPSB0LnN0cmluZ0xpdGVyYWwobWVzc2FnZVBhcnRzWzBdKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBtZXNzYWdlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBwZWRTdHJpbmcgPSB0LmJpbmFyeUV4cHJlc3Npb24oXG4gICAgICAnKycsXG4gICAgICBtYXBwZWRTdHJpbmcsXG4gICAgICB3cmFwSW5QYXJlbnNJZk5lY2Vzc2FyeShzdWJzdGl0dXRpb25zW2kgLSAxXSlcbiAgICApO1xuICAgIG1hcHBlZFN0cmluZyA9IHQuYmluYXJ5RXhwcmVzc2lvbihcbiAgICAgICcrJyxcbiAgICAgIG1hcHBlZFN0cmluZyxcbiAgICAgIHQuc3RyaW5nTGl0ZXJhbChtZXNzYWdlUGFydHNbaV0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWFwcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIG1lc3NhZ2UgcGFydHMgZnJvbSB0aGUgZ2l2ZW4gYGNhbGxgICh0byBgJGxvY2FsaXplYCkuXG4gKlxuICogVGhlIG1lc3NhZ2UgcGFydHMgd2lsbCBlaXRoZXIgYnkgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBgY2FsbGAgb3IgaXQgd2lsbCBiZSB3cmFwcGVkIGluIGNhbGxcbiAqIHRvIGEgaGVscGVyIGZ1bmN0aW9uIGxpa2UgYF9fbWFrZVRlbXBsYXRlT2JqZWN0YC5cbiAqXG4gKiBAcGFyYW0gY2FsbCBUaGUgQVNUIG5vZGUgb2YgdGhlIGNhbGwgdG8gcHJvY2Vzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE1lc3NhZ2VQYXJ0c0Zyb21Mb2NhbGl6ZUNhbGwoXG4gIGNhbGw6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+XG4pOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSB7XG4gIGxldCBjb29rZWQgPSBjYWxsLmdldCgnYXJndW1lbnRzJylbMF0gYXMgYW55O1xuXG4gIGlmIChjb29rZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICBjYWxsLm5vZGUsXG4gICAgICAnYCRsb2NhbGl6ZWAgY2FsbGVkIHdpdGhvdXQgYW55IGFyZ3VtZW50cy4nXG4gICAgKTtcbiAgfVxuICBpZiAoIWNvb2tlZC5pc0V4cHJlc3Npb24oKSkge1xuICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICBjb29rZWQubm9kZSxcbiAgICAgICdVbmV4cGVjdGVkIGFyZ3VtZW50IHRvIGAkbG9jYWxpemVgIChleHBlY3RlZCBhbiBhcnJheSkuJ1xuICAgICk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBubyBjYWxsIHRvIGBfX21ha2VUZW1wbGF0ZU9iamVjdCguLi4pYCwgdGhlbiBgcmF3YCBtdXN0IGJlIHRoZSBzYW1lIGFzIGBjb29rZWRgLlxuICBsZXQgcmF3ID0gY29va2VkO1xuXG4gIC8vIENoZWNrIGZvciBjYWNoZWQgY2FsbCBvZiB0aGUgZm9ybSBgeCB8fCB4ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoLi4uKWBcbiAgaWYgKFxuICAgIGNvb2tlZC5pc0xvZ2ljYWxFeHByZXNzaW9uKCkgJiZcbiAgICBjb29rZWQubm9kZS5vcGVyYXRvciA9PT0gJ3x8JyAmJlxuICAgIGNvb2tlZC5nZXQoJ2xlZnQnKS5pc0lkZW50aWZpZXIoKVxuICApIHtcbiAgICBjb25zdCByaWdodCA9IGNvb2tlZC5nZXQoJ3JpZ2h0Jyk7XG4gICAgaWYgKHJpZ2h0LmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSkge1xuICAgICAgY29va2VkID0gcmlnaHQuZ2V0KCdyaWdodCcpO1xuICAgICAgaWYgKCFjb29rZWQuaXNFeHByZXNzaW9uKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJhYmVsUGFyc2VFcnJvcihcbiAgICAgICAgICBjb29rZWQubm9kZSxcbiAgICAgICAgICAnVW5leHBlY3RlZCBcIm1ha2VUZW1wbGF0ZU9iamVjdCgpXCIgZnVuY3Rpb24gKGV4cGVjdGVkIGFuIGV4cHJlc3Npb24pLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmb3IgYF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KWAgb3IgYF9fdGVtcGxhdGVPYmplY3QoKWAgY2FsbHMuXG4gIGlmIChjb29rZWQuaXNDYWxsRXhwcmVzc2lvbigpKSB7XG4gICAgbGV0IGNvb2tlZENhbGwgPSBjb29rZWQ7XG4gICAgaWYgKGNvb2tlZENhbGwuZ2V0KCdhcmd1bWVudHMnKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIGFyZ3VtZW50cyBzbyBwZXJoYXBzIGl0IGlzIGEgYF9fdGVtcGxhdGVPYmplY3QoKWAgY2FsbC5cbiAgICAgIC8vIFVud3JhcCB0aGlzIHRvIGdldCB0aGUgYF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoY29va2VkLCByYXcpYCBjYWxsLlxuICAgICAgY29va2VkQ2FsbCA9IHVud3JhcExhenlMb2FkSGVscGVyQ2FsbChjb29rZWRDYWxsKTtcbiAgICB9XG5cbiAgICBjb29rZWQgPSBjb29rZWRDYWxsLmdldCgnYXJndW1lbnRzJylbMF07XG4gICAgaWYgKCFjb29rZWQuaXNFeHByZXNzaW9uKCkpIHtcbiAgICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICAgIGNvb2tlZC5ub2RlLFxuICAgICAgICAnVW5leHBlY3RlZCBgY29va2VkYCBhcmd1bWVudCB0byB0aGUgXCJtYWtlVGVtcGxhdGVPYmplY3QoKVwiIGZ1bmN0aW9uIChleHBlY3RlZCBhbiBleHByZXNzaW9uKS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhcmcyID0gY29va2VkQ2FsbC5nZXQoJ2FyZ3VtZW50cycpWzFdO1xuICAgIGlmIChhcmcyICYmICFhcmcyLmlzRXhwcmVzc2lvbigpKSB7XG4gICAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgICBhcmcyLm5vZGUsXG4gICAgICAgICdVbmV4cGVjdGVkIGByYXdgIGFyZ3VtZW50IHRvIHRoZSBcIm1ha2VUZW1wbGF0ZU9iamVjdCgpXCIgZnVuY3Rpb24gKGV4cGVjdGVkIGFuIGV4cHJlc3Npb24pLidcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHNlY29uZCBhcmd1bWVudCB0aGVuIGFzc3VtZSB0aGF0IHJhdyBhbmQgY29va2VkIGFyZSB0aGUgc2FtZVxuICAgIHJhdyA9IGFyZzIgIT09IHVuZGVmaW5lZCA/IGFyZzIgOiBjb29rZWQ7XG4gIH1cblxuICBjb25zdCBjb29rZWRTdHJpbmdzID0gdW53cmFwU3RyaW5nTGl0ZXJhbEFycmF5KGNvb2tlZC5ub2RlKTtcbiAgY29uc3QgcmF3U3RyaW5ncyA9IHVud3JhcFN0cmluZ0xpdGVyYWxBcnJheShyYXcubm9kZSk7XG4gIHJldHVybiDJtW1ha2VUZW1wbGF0ZU9iamVjdChjb29rZWRTdHJpbmdzLCByYXdTdHJpbmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFN1YnN0aXR1dGlvbnNGcm9tTG9jYWxpemVDYWxsKFxuICBjYWxsOiB0LkNhbGxFeHByZXNzaW9uXG4pOiB0LkV4cHJlc3Npb25bXSB7XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gY2FsbC5hcmd1bWVudHMuc3BsaWNlKDEpO1xuICBpZiAoIWlzQXJyYXlPZkV4cHJlc3Npb25zKGV4cHJlc3Npb25zKSkge1xuICAgIGNvbnN0IGJhZEV4cHJlc3Npb24gPSBleHByZXNzaW9ucy5maW5kKFxuICAgICAgZXhwcmVzc2lvbiA9PiAhdC5pc0V4cHJlc3Npb24oZXhwcmVzc2lvbilcbiAgICApITtcbiAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgYmFkRXhwcmVzc2lvbixcbiAgICAgICdJbnZhbGlkIHN1YnN0aXR1dGlvbnMgZm9yIGAkbG9jYWxpemVgIChleHBlY3RlZCBhbGwgc3Vic3RpdHV0aW9uIGFyZ3VtZW50cyB0byBiZSBleHByZXNzaW9ucykuJ1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIGV4cHJlc3Npb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwTWVzc2FnZVBhcnRzRnJvbVRlbXBsYXRlTGl0ZXJhbChcbiAgZWxlbWVudHM6IHQuVGVtcGxhdGVFbGVtZW50W11cbik6IFRlbXBsYXRlU3RyaW5nc0FycmF5IHtcbiAgY29uc3QgY29va2VkID0gZWxlbWVudHMubWFwKHEgPT4ge1xuICAgIGlmIChxLnZhbHVlLmNvb2tlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgICBxLFxuICAgICAgICBgVW5leHBlY3RlZCB1bmRlZmluZWQgbWVzc2FnZSBwYXJ0IGluIFwiJHtlbGVtZW50cy5tYXAoXG4gICAgICAgICAgZXEgPT4gZXEudmFsdWUuY29va2VkXG4gICAgICAgICl9XCJgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcS52YWx1ZS5jb29rZWQ7XG4gIH0pO1xuICBjb25zdCByYXcgPSBlbGVtZW50cy5tYXAocSA9PiBxLnZhbHVlLnJhdyk7XG4gIHJldHVybiDJtW1ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdyk7XG59XG5cbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGluIHBhcmVudGhlc2VzIGlmIGl0IGlzIGEgYmluYXJ5IGV4cHJlc3Npb24uXG4gKlxuICogVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBleHByZXNzaW9uIGlzIGV2YWx1YXRlZCBjb3JyZWN0bHkgaWYgaXQgaXMgZW1iZWRkZWQgaW4gYW5vdGhlciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBvdGVudGlhbGx5IHdyYXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwSW5QYXJlbnNJZk5lY2Vzc2FyeShcbiAgZXhwcmVzc2lvbjogdC5FeHByZXNzaW9uXG4pOiB0LkV4cHJlc3Npb24ge1xuICBpZiAodC5pc0JpbmFyeUV4cHJlc3Npb24oZXhwcmVzc2lvbikpIHtcbiAgICByZXR1cm4gdC5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHN0cmluZyB2YWx1ZXMgZnJvbSBhbiBgYXJyYXlgIG9mIHN0cmluZyBsaXRlcmFscy5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gdW53cmFwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwU3RyaW5nTGl0ZXJhbEFycmF5KGFycmF5OiB0LkV4cHJlc3Npb24pOiBzdHJpbmdbXSB7XG4gIGlmICghaXNTdHJpbmdMaXRlcmFsQXJyYXkoYXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEJhYmVsUGFyc2VFcnJvcihcbiAgICAgIGFycmF5LFxuICAgICAgJ1VuZXhwZWN0ZWQgbWVzc2FnZVBhcnRzIGZvciBgJGxvY2FsaXplYCAoZXhwZWN0ZWQgYW4gYXJyYXkgb2Ygc3RyaW5ncykuJ1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LmVsZW1lbnRzLm1hcCgoc3RyOiB0LlN0cmluZ0xpdGVyYWwpID0+IHN0ci52YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBleHByZXNzaW9uIGlzIGJlbGlldmVkIHRvIGJlIGEgY2FsbCB0byBhIFwibGF6eS1sb2FkXCIgdGVtcGxhdGUgb2JqZWN0IGhlbHBlciBmdW5jdGlvbi5cbiAqIFRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdGhlIGZvcm06XG4gKlxuICogYGBgdHNcbiAqICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gKiAgICB2YXIgZSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoWydjb29rZWQgc3RyaW5nJywgJ3JhdyBzdHJpbmcnXSk7XG4gKiAgICByZXR1cm4gX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBlIH0sIGVcbiAqICB9XG4gKiBgYGBcbiAqXG4gKiBXZSB1bndyYXAgdGhpcyB0byByZXR1cm4gdGhlIGNhbGwgdG8gYF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoKWAuXG4gKlxuICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgZXhwcmVzc2lvbiB0byB1bndyYXBcbiAqIEByZXR1cm5zIHRoZSAgY2FsbCBleHByZXNzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBMYXp5TG9hZEhlbHBlckNhbGwoXG4gIGNhbGw6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+XG4pOiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPiB7XG4gIGNvbnN0IGNhbGxlZSA9IGNhbGwuZ2V0KCdjYWxsZWUnKSBhcyBhbnk7XG4gIGlmICghY2FsbGVlLmlzSWRlbnRpZmllcigpKSB7XG4gICAgdGhyb3cgbmV3IEJhYmVsUGFyc2VFcnJvcihcbiAgICAgIGNhbGxlZS5ub2RlLFxuICAgICAgJ1VuZXhwZWN0ZWQgbGF6eS1sb2FkIGhlbHBlciBjYWxsIChleHBlY3RlZCBhIGNhbGwgb2YgdGhlIGZvcm0gYF90ZW1wbGF0ZU9iamVjdCgpYCkuJ1xuICAgICk7XG4gIH1cbiAgY29uc3QgbGF6eUxvYWRCaW5kaW5nID0gY2FsbC5zY29wZS5nZXRCaW5kaW5nKGNhbGxlZS5ub2RlLm5hbWUpO1xuICBpZiAoIWxhenlMb2FkQmluZGluZykge1xuICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICBjYWxsZWUubm9kZSxcbiAgICAgICdNaXNzaW5nIGRlY2xhcmF0aW9uIGZvciBsYXp5LWxvYWQgaGVscGVyIGZ1bmN0aW9uJ1xuICAgICk7XG4gIH1cbiAgY29uc3QgbGF6eUxvYWRGbiA9IGxhenlMb2FkQmluZGluZy5wYXRoO1xuICBpZiAoIWxhenlMb2FkRm4uaXNGdW5jdGlvbkRlY2xhcmF0aW9uKCkpIHtcbiAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgKGxhenlMb2FkRm4gYXMgYW55KS5ub2RlLFxuICAgICAgJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbiAoZXhwZWN0ZWQgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbidcbiAgICApO1xuICB9XG4gIGNvbnN0IHJldHVybmVkTm9kZSA9IGdldFJldHVybmVkRXhwcmVzc2lvbihsYXp5TG9hZEZuKTtcblxuICBpZiAocmV0dXJuZWROb2RlLmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiByZXR1cm5lZE5vZGU7XG4gIH1cblxuICBpZiAocmV0dXJuZWROb2RlLmlzSWRlbnRpZmllcigpKSB7XG4gICAgY29uc3QgaWRlbnRpZmllck5hbWUgPSByZXR1cm5lZE5vZGUubm9kZS5uYW1lO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gcmV0dXJuZWROb2RlLnNjb3BlLmdldEJpbmRpbmcoaWRlbnRpZmllck5hbWUpO1xuICAgIGlmIChkZWNsYXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgICByZXR1cm5lZE5vZGUubm9kZSxcbiAgICAgICAgJ01pc3NpbmcgZGVjbGFyYXRpb24gZm9yIHJldHVybiB2YWx1ZSBmcm9tIGhlbHBlci4nXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWRlY2xhcmF0aW9uLnBhdGguaXNWYXJpYWJsZURlY2xhcmF0b3IoKSkge1xuICAgICAgdGhyb3cgbmV3IEJhYmVsUGFyc2VFcnJvcihcbiAgICAgICAgKGRlY2xhcmF0aW9uIGFzIGFueSkucGF0aC5ub2RlLFxuICAgICAgICAnVW5leHBlY3RlZCBoZWxwZXIgcmV0dXJuIHZhbHVlIGRlY2xhcmF0aW9uIChleHBlY3RlZCBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uKS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsaXplciA9IGRlY2xhcmF0aW9uLnBhdGguZ2V0KCdpbml0Jyk7XG4gICAgaWYgKCFpbml0aWFsaXplci5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICAgIGRlY2xhcmF0aW9uLnBhdGgubm9kZSxcbiAgICAgICAgJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gaGVscGVyIChleHBlY3RlZCBhIGNhbGwgZXhwcmVzc2lvbikuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIGxhenkgbG9hZCBoZWxwZXIgaWYgdGhpcyBpcyB0aGUgb25seSByZWZlcmVuY2UgdG8gaXQuXG4gICAgaWYgKGxhenlMb2FkQmluZGluZy5yZWZlcmVuY2VzID09PSAxKSB7XG4gICAgICBsYXp5TG9hZEZuLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsaXplcjtcbiAgfVxuICByZXR1cm4gY2FsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UmV0dXJuZWRFeHByZXNzaW9uKFxuICBmbjogTm9kZVBhdGg8dC5GdW5jdGlvbkRlY2xhcmF0aW9uPlxuKTogTm9kZVBhdGg8dC5FeHByZXNzaW9uPiB7XG4gIGNvbnN0IGJvZHlTdGF0ZW1lbnRzID0gKGZuLmdldCgnYm9keScpIGFzIGFueSkuZ2V0KCdib2R5Jyk7XG4gIGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIGJvZHlTdGF0ZW1lbnRzKSB7XG4gICAgaWYgKHN0YXRlbWVudC5pc1JldHVyblN0YXRlbWVudCgpKSB7XG4gICAgICBjb25zdCBhcmd1bWVudCA9IHN0YXRlbWVudC5nZXQoJ2FyZ3VtZW50Jyk7XG4gICAgICBpZiAoYXJndW1lbnQuaXNTZXF1ZW5jZUV4cHJlc3Npb24oKSkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IGFyZ3VtZW50LmdldCgnZXhwcmVzc2lvbnMnKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbnMpXG4gICAgICAgICAgPyBleHByZXNzaW9uc1tleHByZXNzaW9ucy5sZW5ndGggLSAxXVxuICAgICAgICAgIDogZXhwcmVzc2lvbnM7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50LmlzRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICAgICAgc3RhdGVtZW50Lm5vZGUsXG4gICAgICAgICAgJ0ludmFsaWQgcmV0dXJuIGFyZ3VtZW50IGluIGhlbHBlciBmdW5jdGlvbiAoZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbikuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgIGZuLm5vZGUsXG4gICAgJ01pc3NpbmcgcmV0dXJuIHN0YXRlbWVudCBpbiBoZWxwZXIgZnVuY3Rpb24uJ1xuICApO1xufVxuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBgbm9kZWAgYW4gYXJyYXkgb2YgbGl0ZXJhbCBzdHJpbmdzP1xuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHRlc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWxBcnJheShcbiAgbm9kZTogdC5Ob2RlXG4pOiBub2RlIGlzIHQuRXhwcmVzc2lvbiAmIHsgZWxlbWVudHM6IHQuU3RyaW5nTGl0ZXJhbFtdIH0ge1xuICByZXR1cm4gKFxuICAgIHQuaXNBcnJheUV4cHJlc3Npb24obm9kZSkgJiZcbiAgICBub2RlLmVsZW1lbnRzLmV2ZXJ5KGVsZW1lbnQgPT4gdC5pc1N0cmluZ0xpdGVyYWwoZWxlbWVudCkpXG4gICk7XG59XG5cbi8qKlxuICogQXJlIGFsbCB0aGUgZ2l2ZW4gYG5vZGVzYCBleHByZXNzaW9ucz9cbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZXMgdG8gdGVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlPZkV4cHJlc3Npb25zKG5vZGVzOiB0Lk5vZGVbXSk6IG5vZGVzIGlzIHQuRXhwcmVzc2lvbltdIHtcbiAgcmV0dXJuIG5vZGVzLmV2ZXJ5KGVsZW1lbnQgPT4gdC5pc0V4cHJlc3Npb24oZWxlbWVudCkpO1xufVxuXG4vKiogT3B0aW9ucyB0aGF0IGFmZmVjdCBob3cgdGhlIGBtYWtlRXNYWFhUcmFuc2xhdGVQbHVnaW4oKWAgZnVuY3Rpb25zIHdvcmsuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0ZVBsdWdpbk9wdGlvbnMge1xuICBtaXNzaW5nVHJhbnNsYXRpb24/OiBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneTtcbiAgbG9jYWxpemVOYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEhvdyB0byBoYW5kbGUgbWlzc2luZyB0cmFuc2xhdGlvbnMuXG4gKi9cbmV4cG9ydCB0eXBlIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gJ2Vycm9yJyB8ICd3YXJuaW5nJyB8ICdpZ25vcmUnO1xuXG4vKipcbiAqIFRyYW5zbGF0ZSB0aGUgdGV4dCBvZiB0aGUgZ2l2ZW4gbWVzc2FnZSwgdXNpbmcgdGhlIGdpdmVuIHRyYW5zbGF0aW9ucy5cbiAqXG4gKiBMb2dzIGFzIHdhcm5pbmcgaWYgdGhlIHRyYW5zbGF0aW9uIGlzIG5vdCBhdmFpbGFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShcbiAgZGlhZ25vc3RpY3M6IERpYWdub3N0aWNzLFxuICB0cmFuc2xhdGlvbnM6IFJlY29yZDxzdHJpbmcsIMm1UGFyc2VkVHJhbnNsYXRpb24+LFxuICBtZXNzYWdlUGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LFxuICBzdWJzdGl0dXRpb25zOiByZWFkb25seSBhbnlbXSxcbiAgbWlzc2luZ1RyYW5zbGF0aW9uOiBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVxuKTogW1RlbXBsYXRlU3RyaW5nc0FycmF5LCByZWFkb25seSBhbnlbXV0ge1xuICB0cnkge1xuICAgIHJldHVybiDJtXRyYW5zbGF0ZSh0cmFuc2xhdGlvbnMsIG1lc3NhZ2VQYXJ0cywgc3Vic3RpdHV0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoybVpc01pc3NpbmdUcmFuc2xhdGlvbkVycm9yKGUpKSB7XG4gICAgICBpZiAobWlzc2luZ1RyYW5zbGF0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgIGRpYWdub3N0aWNzLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKG1pc3NpbmdUcmFuc2xhdGlvbiA9PT0gJ3dhcm5pbmcnKSB7XG4gICAgICAgIGRpYWdub3N0aWNzLndhcm4oZS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIC8vIFJldHVybiB0aGUgcGFyc2VkIG1lc3NhZ2UgYmVjYXVzZSB0aGlzIHdpbGwgaGF2ZSB0aGUgbWV0YSBibG9ja3Mgc3RyaXBwZWRcbiAgICAgIHJldHVybiBbXG4gICAgICAgIMm1bWFrZVRlbXBsYXRlT2JqZWN0KFxuICAgICAgICAgIGUucGFyc2VkTWVzc2FnZS5tZXNzYWdlUGFydHMsXG4gICAgICAgICAgZS5wYXJzZWRNZXNzYWdlLm1lc3NhZ2VQYXJ0c1xuICAgICAgICApLFxuICAgICAgICBzdWJzdGl0dXRpb25zXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWFnbm9zdGljcy5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIFttZXNzYWdlUGFydHMsIHN1YnN0aXR1dGlvbnNdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFiZWxQYXJzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IHR5cGUgPSAnQmFiZWxQYXJzZUVycm9yJztcbiAgY29uc3RydWN0b3IocHVibGljIG5vZGU6IHQuTm9kZSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFiZWxQYXJzZUVycm9yKGU6IGFueSk6IGUgaXMgQmFiZWxQYXJzZUVycm9yIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ0JhYmVsUGFyc2VFcnJvcic7XG59XG4iXX0=