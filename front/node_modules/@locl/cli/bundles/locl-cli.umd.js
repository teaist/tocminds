(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('fs'), require('glob'), require('path'), require('chalk'), require('@babel/core'), require('@angular/localize'), require('@babel/types'), require('yargs'), require('find-up')) :
    typeof define === 'function' && define.amd ? define('@locl/cli', ['exports', '@angular/core', 'fs', 'glob', 'path', 'chalk', '@babel/core', '@angular/localize', '@babel/types', 'yargs', 'find-up'], factory) :
    (global = global || self, factory((global.locl = global.locl || {}, global.locl.cli = {}), global.ng.core, global.fs, global.glob, global.path, global.chalk, global.core$1, global.ng.localize, global.types, global.yargs, global.findUp));
}(this, (function (exports, core, fs, glob, path, chalk, core$1, localize, types, yargs, findUp) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/cli.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // not used, only there to make ng-packagr happy
    var CliModule = /** @class */ (function () {
        function CliModule() {
        }
        CliModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        declarations: [],
                        exports: []
                    },] }
        ];
        return CliModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/common/diagnostics.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This class is used to collect and then report warnings and errors that occur during the execution
     * of the tools.
     */
    var /**
     * This class is used to collect and then report warnings and errors that occur during the execution
     * of the tools.
     */
    Diagnostics = /** @class */ (function () {
        function Diagnostics() {
            this.messages = [];
        }
        Object.defineProperty(Diagnostics.prototype, "hasErrors", {
            get: /**
             * @return {?}
             */
            function () {
                return this.messages.some((/**
                 * @param {?} m
                 * @return {?}
                 */
                function (m) { return m.type === 'error'; }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} message
         * @return {?}
         */
        Diagnostics.prototype.log = /**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            this.messages.push({ type: '', message: message });
        };
        /**
         * @param {?} message
         * @return {?}
         */
        Diagnostics.prototype.warn = /**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            this.messages.push({ type: 'warning', message: message });
        };
        /**
         * @param {?} message
         * @return {?}
         */
        Diagnostics.prototype.error = /**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            this.messages.push({ type: 'error', message: message });
        };
        /**
         * @param {?} message
         * @return {?}
         */
        Diagnostics.prototype.formatDiagnostics = /**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            /** @type {?} */
            var errors = (/** @type {?} */ (this.messages)).filter((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return d.type === 'error'; })).map((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return ' - ' + d.message; }));
            /** @type {?} */
            var warnings = (/** @type {?} */ (this.messages)).filter((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return d.type === 'warning'; })).map((/**
             * @param {?} d
             * @return {?}
             */
            function (d) { return ' - ' + d.message; }));
            if (errors.length) {
                message += '\nERRORS:\n' + errors.join('\n');
            }
            if (warnings.length) {
                message += '\nWARNINGS:\n' + warnings.join('\n');
            }
            return message;
        };
        /**
         * @return {?}
         */
        Diagnostics.prototype.logMessages = /**
         * @return {?}
         */
        function () {
            while (this.messages.length) {
                /** @type {?} */
                var m = this.messages.shift();
                switch (m.type) {
                    case 'warning':
                        console.warn(chalk.yellow("Warning: " + m.message));
                        break;
                    case 'error':
                        console.error(chalk.red("Error: " + m.message));
                        break;
                    default:
                        console.log(chalk.blue("" + m.message));
                }
            }
        };
        return Diagnostics;
    }());
    if (false) {
        /** @type {?} */
        Diagnostics.prototype.messages;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/common/file_utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FileUtils = /** @class */ (function () {
        function FileUtils() {
        }
        /**
         * @param {?} absolutePath
         * @return {?}
         */
        FileUtils.readFile = /**
         * @param {?} absolutePath
         * @return {?}
         */
        function (absolutePath) {
            return fs.readFileSync(absolutePath, 'utf8');
        };
        /**
         * @param {?} absolutePath
         * @return {?}
         */
        FileUtils.readFileBuffer = /**
         * @param {?} absolutePath
         * @return {?}
         */
        function (absolutePath) {
            return fs.readFileSync(absolutePath);
        };
        /**
         * @param {?} absolutePath
         * @param {?} contents
         * @return {?}
         */
        FileUtils.writeFile = /**
         * @param {?} absolutePath
         * @param {?} contents
         * @return {?}
         */
        function (absolutePath, contents) {
            FileUtils.ensureDir(path.dirname(absolutePath));
            fs.writeFileSync(absolutePath, contents);
        };
        /**
         * @param {?} absolutePath
         * @return {?}
         */
        FileUtils.ensureDir = /**
         * @param {?} absolutePath
         * @return {?}
         */
        function (absolutePath) {
            /** @type {?} */
            var parents = [];
            while (!FileUtils.isRoot(absolutePath) && !fs.existsSync(absolutePath)) {
                parents.push(absolutePath);
                absolutePath = path.dirname(absolutePath);
            }
            while (parents.length) {
                fs.mkdirSync((/** @type {?} */ (parents.pop())));
            }
        };
        /**
         * @param {?} p
         * @return {?}
         */
        FileUtils.remove = /**
         * @param {?} p
         * @return {?}
         */
        function (p) {
            /** @type {?} */
            var stat = fs.statSync(p);
            if (stat.isFile()) {
                fs.unlinkSync(p);
            }
            else if (stat.isDirectory()) {
                fs.readdirSync(p).forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                function (child) {
                    /** @type {?} */
                    var absChild = path.resolve(p, child);
                    FileUtils.remove(absChild);
                }));
                fs.rmdirSync(p);
            }
        };
        /**
         * @param {?} absolutePath
         * @return {?}
         */
        FileUtils.isRoot = /**
         * @param {?} absolutePath
         * @return {?}
         */
        function (absolutePath) {
            return path.dirname(absolutePath) === absolutePath;
        };
        /**
         * @param {?} files
         * @param {?} pattern
         * @param {?=} replaceValue
         * @return {?}
         */
        FileUtils.dedup = /**
         * @param {?} files
         * @param {?} pattern
         * @param {?=} replaceValue
         * @return {?}
         */
        function (files, pattern, replaceValue) {
            if (replaceValue === void 0) { replaceValue = ''; }
            /** @type {?} */
            var filesSet = files.map((/**
             * @param {?} file
             * @return {?}
             */
            function (file) { return file.replace(pattern, replaceValue); }));
            /** @type {?} */
            var dedup = [];
            /** @type {?} */
            var indexes = [];
            filesSet.forEach((/**
             * @param {?} file
             * @param {?} index
             * @return {?}
             */
            function (file, index) {
                if (dedup.indexOf(file) === -1) {
                    dedup.push(file);
                    indexes.push(index);
                }
            }));
            return indexes.map((/**
             * @param {?} index
             * @return {?}
             */
            function (index) { return files[index]; }));
        };
        return FileUtils;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/translation_files/json_translation_serializer.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function SimpleJsonTranslationFile() { }
    if (false) {
        /** @type {?} */
        SimpleJsonTranslationFile.prototype.locale;
        /** @type {?} */
        SimpleJsonTranslationFile.prototype.translations;
    }
    var JsonTranslationSerializer = /** @class */ (function () {
        function JsonTranslationSerializer() {
        }
        /**
         * @param {?} messages
         * @param {?} locale
         * @return {?}
         */
        JsonTranslationSerializer.prototype.renderFile = /**
         * @param {?} messages
         * @param {?} locale
         * @return {?}
         */
        function (messages, locale) {
            /** @type {?} */
            var fileObj = {
                locale: locale,
                translations: {}
            };
            messages.forEach((/**
             * @param {?} message
             * @return {?}
             */
            function (message) {
                fileObj.translations[((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId] =
                    ((/** @type {?} */ (message))).text ||
                        ((/** @type {?} */ (message))).messageString;
            }));
            return JSON.stringify(fileObj, null, 2);
        };
        return JsonTranslationSerializer;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/translation_files/xml_file.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @record
     */
    function Options() { }
    if (false) {
        /** @type {?|undefined} */
        Options.prototype.selfClosing;
        /** @type {?|undefined} */
        Options.prototype.preserveWhitespace;
    }
    var XmlFile = /** @class */ (function () {
        function XmlFile() {
            this.output = '';
            this.indent = '';
            this.elements = [];
            this.preservingWhitespace = false;
        }
        /**
         * @return {?}
         */
        XmlFile.prototype.toString = /**
         * @return {?}
         */
        function () {
            return this.output;
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} name
         * @param {?=} attributes
         * @param {?=} __2
         * @return {THIS}
         */
        XmlFile.prototype.startTag = /**
         * @template THIS
         * @this {THIS}
         * @param {?} name
         * @param {?=} attributes
         * @param {?=} __2
         * @return {THIS}
         */
        function (name, attributes, _a) {
            var _this = this;
            if (attributes === void 0) { attributes = {}; }
            var _b = _a === void 0 ? {} : _a, _c = _b.selfClosing, selfClosing = _c === void 0 ? false : _c, preserveWhitespace = _b.preserveWhitespace;
            if (!(/** @type {?} */ (this)).preservingWhitespace) {
                (/** @type {?} */ (this)).output += (/** @type {?} */ (this)).indent;
            }
            (/** @type {?} */ (this)).output += "<" + name;
            Object.keys(attributes).forEach((/**
             * @param {?} attrName
             * @return {?}
             */
            function (attrName) {
                if (attributes[attrName]) {
                    (/** @type {?} */ (_this)).output += " " + attrName + "=\"" + escapeXml(attributes[attrName]) + "\"";
                }
            }));
            if (selfClosing) {
                (/** @type {?} */ (this)).output += '/>';
            }
            else {
                (/** @type {?} */ (this)).output += '>';
                (/** @type {?} */ (this)).elements.push(name);
                (/** @type {?} */ (this)).incIndent();
            }
            if (preserveWhitespace !== undefined) {
                (/** @type {?} */ (this)).preservingWhitespace = preserveWhitespace;
            }
            if (!(/** @type {?} */ (this)).preservingWhitespace) {
                (/** @type {?} */ (this)).output += "\n";
            }
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} name
         * @param {?=} __1
         * @return {THIS}
         */
        XmlFile.prototype.endTag = /**
         * @template THIS
         * @this {THIS}
         * @param {?} name
         * @param {?=} __1
         * @return {THIS}
         */
        function (name, _a) {
            var preserveWhitespace = (_a === void 0 ? {} : _a).preserveWhitespace;
            /** @type {?} */
            var expectedTag = (/** @type {?} */ (this)).elements.pop();
            if (expectedTag !== name) {
                throw new Error("Unexpected closing tag: \"" + name + "\", expected: \"" + expectedTag + "\"");
            }
            (/** @type {?} */ (this)).decIndent();
            if (!(/** @type {?} */ (this)).preservingWhitespace) {
                (/** @type {?} */ (this)).output += (/** @type {?} */ (this)).indent;
            }
            (/** @type {?} */ (this)).output += "</" + name + ">";
            if (preserveWhitespace !== undefined) {
                (/** @type {?} */ (this)).preservingWhitespace = preserveWhitespace;
            }
            if (!(/** @type {?} */ (this)).preservingWhitespace) {
                (/** @type {?} */ (this)).output += "\n";
            }
            return (/** @type {?} */ (this));
        };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} str
         * @return {THIS}
         */
        XmlFile.prototype.text = /**
         * @template THIS
         * @this {THIS}
         * @param {?} str
         * @return {THIS}
         */
        function (str) {
            (/** @type {?} */ (this)).output += escapeXml(str);
            return (/** @type {?} */ (this));
        };
        /**
         * @return {?}
         */
        XmlFile.prototype.startPreserveWhitespace = /**
         * @return {?}
         */
        function () {
            this.preservingWhitespace = true;
        };
        /**
         * @return {?}
         */
        XmlFile.prototype.stopPreserveWhitespace = /**
         * @return {?}
         */
        function () {
            this.preservingWhitespace = false;
        };
        /**
         * @private
         * @return {?}
         */
        XmlFile.prototype.incIndent = /**
         * @private
         * @return {?}
         */
        function () {
            this.indent = this.indent + '  ';
        };
        /**
         * @private
         * @return {?}
         */
        XmlFile.prototype.decIndent = /**
         * @private
         * @return {?}
         */
        function () {
            this.indent = this.indent.slice(0, -2);
        };
        return XmlFile;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        XmlFile.prototype.output;
        /**
         * @type {?}
         * @private
         */
        XmlFile.prototype.indent;
        /**
         * @type {?}
         * @private
         */
        XmlFile.prototype.elements;
        /**
         * @type {?}
         * @private
         */
        XmlFile.prototype.preservingWhitespace;
    }
    /** @type {?} */
    var _ESCAPED_CHARS = [
        [/&/g, '&amp;'],
        [/"/g, '&quot;'],
        [/'/g, '&apos;'],
        [/</g, '&lt;'],
        [/>/g, '&gt;']
    ];
    /**
     * @param {?} text
     * @return {?}
     */
    function escapeXml(text) {
        return _ESCAPED_CHARS.reduce((/**
         * @param {?} t
         * @param {?} entry
         * @return {?}
         */
        function (t, entry) { return t.replace(entry[0], entry[1]); }), text);
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/translation_files/xliff1_translation_serializer.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Xliff1TranslationSerializer = /** @class */ (function () {
        function Xliff1TranslationSerializer() {
        }
        /**
         * @param {?} messages
         * @param {?} locale
         * @param {?=} isTarget
         * @return {?}
         */
        Xliff1TranslationSerializer.prototype.renderFile = /**
         * @param {?} messages
         * @param {?} locale
         * @param {?=} isTarget
         * @return {?}
         */
        function (messages, locale, isTarget) {
            var _a;
            var _this = this;
            if (isTarget === void 0) { isTarget = false; }
            /** @type {?} */
            var xml = new XmlFile();
            xml.startTag('xliff', {
                version: '1.2',
                xmlns: 'urn:oasis:names:tc:xliff:document:1.2'
            });
            /** @type {?} */
            var fileAttrs = (_a = {},
                _a['source-language'] = isTarget ? undefined : locale,
                _a['target-language'] = locale,
                _a.datatype = 'plaintext',
                _a);
            xml.startTag('file', fileAttrs);
            xml.startTag('body');
            messages.forEach((/**
             * @param {?} message
             * @return {?}
             */
            function (message) {
                xml.startTag('trans-unit', {
                    id: ((/** @type {?} */ (message))).id ||
                        ((/** @type {?} */ (message))).messageId,
                    datatype: 'html'
                });
                if (!isTarget) {
                    _this.generateMessageTag(xml, 'source', message);
                }
                _this.generateMessageTag(xml, 'target', message);
                if (message.description) {
                    _this.renderNote(xml, 'description', message.description);
                }
                if (message.meaning) {
                    _this.renderNote(xml, 'meaning', message.meaning);
                }
                xml.endTag('trans-unit');
            }));
            xml.endTag('body');
            xml.endTag('file');
            xml.endTag('xliff');
            return xml.toString();
        };
        /**
         * @private
         * @param {?} xml
         * @param {?} tagName
         * @param {?} message
         * @return {?}
         */
        Xliff1TranslationSerializer.prototype.generateMessageTag = /**
         * @private
         * @param {?} xml
         * @param {?} tagName
         * @param {?} message
         * @return {?}
         */
        function (xml, tagName, message) {
            xml.startTag(tagName, {}, { preserveWhitespace: true });
            this.renderMessage(xml, message);
            xml.endTag(tagName, { preserveWhitespace: false });
        };
        /**
         * @private
         * @param {?} xml
         * @param {?} message
         * @return {?}
         */
        Xliff1TranslationSerializer.prototype.renderMessage = /**
         * @private
         * @param {?} xml
         * @param {?} message
         * @return {?}
         */
        function (xml, message) {
            xml.text(message.messageParts[0]);
            for (var i = 1; i < message.messageParts.length; i++) {
                xml.startTag('x', { id: message.placeholderNames[i - 1] }, { selfClosing: true });
                xml.text(message.messageParts[i]);
            }
        };
        /**
         * @private
         * @param {?} xml
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        Xliff1TranslationSerializer.prototype.renderNote = /**
         * @private
         * @param {?} xml
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        function (xml, name, value) {
            xml.startTag('note', { priority: '1', from: name }, { preserveWhitespace: true });
            xml.text(value);
            xml.endTag('note', { preserveWhitespace: false });
        };
        return Xliff1TranslationSerializer;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/translation_files/xliff2_translation_serializer.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Xliff2TranslationSerializer = /** @class */ (function () {
        function Xliff2TranslationSerializer() {
        }
        /**
         * @param {?} messages
         * @param {?} locale
         * @param {?=} isTarget
         * @return {?}
         */
        Xliff2TranslationSerializer.prototype.renderFile = /**
         * @param {?} messages
         * @param {?} locale
         * @param {?=} isTarget
         * @return {?}
         */
        function (messages, locale, isTarget) {
            var _this = this;
            if (isTarget === void 0) { isTarget = false; }
            /** @type {?} */
            var xml = new XmlFile();
            xml.startTag('xliff', {
                version: '2.0',
                xmlns: 'urn:oasis:names:tc:xliff:document:2.0',
                srcLang: locale,
                trgLang: locale
            });
            xml.startTag('file');
            messages.forEach((/**
             * @param {?} message
             * @return {?}
             */
            function (message) {
                xml.startTag('unit', {
                    id: ((/** @type {?} */ (message))).id ||
                        ((/** @type {?} */ (message))).messageId
                });
                if (message.meaning || message.description) {
                    xml.startTag('notes');
                    if (message.description) {
                        _this.renderNote(xml, 'description', message.description);
                    }
                    if (message.meaning) {
                        _this.renderNote(xml, 'meaning', message.meaning);
                    }
                    xml.endTag('notes');
                }
                xml.startTag('segment');
                if (!isTarget) {
                    _this.generateMessageTag(xml, 'source', message);
                }
                _this.generateMessageTag(xml, 'target', message);
                xml.endTag('segment');
                xml.endTag('unit');
            }));
            xml.endTag('file');
            xml.endTag('xliff');
            return xml.toString();
        };
        /**
         * @private
         * @param {?} xml
         * @param {?} tagName
         * @param {?} message
         * @return {?}
         */
        Xliff2TranslationSerializer.prototype.generateMessageTag = /**
         * @private
         * @param {?} xml
         * @param {?} tagName
         * @param {?} message
         * @return {?}
         */
        function (xml, tagName, message) {
            xml.startTag(tagName, {}, { preserveWhitespace: true });
            this.renderMessage(xml, message);
            xml.endTag(tagName, { preserveWhitespace: false });
        };
        /**
         * @private
         * @param {?} xml
         * @param {?} message
         * @return {?}
         */
        Xliff2TranslationSerializer.prototype.renderMessage = /**
         * @private
         * @param {?} xml
         * @param {?} message
         * @return {?}
         */
        function (xml, message) {
            xml.text(message.messageParts[0]);
            for (var i = 1; i < message.messageParts.length; i++) {
                /** @type {?} */
                var placeholderName = message.placeholderNames[i - 1];
                if (placeholderName.startsWith('START_')) {
                    xml.startTag('pc', {
                        id: "" + i,
                        equivStart: placeholderName,
                        equivEnd: placeholderName.replace(/^START/, 'CLOSE')
                    });
                }
                else if (placeholderName.startsWith('CLOSE_')) {
                    xml.endTag('pc');
                }
                else {
                    xml.startTag('ph', { id: "" + i, equiv: placeholderName }, { selfClosing: true });
                }
                xml.text(message.messageParts[i]);
            }
        };
        /**
         * @private
         * @param {?} xml
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        Xliff2TranslationSerializer.prototype.renderNote = /**
         * @private
         * @param {?} xml
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        function (xml, name, value) {
            xml.startTag('note', { category: name }, { preserveWhitespace: true });
            xml.text(value);
            xml.endTag('note', { preserveWhitespace: false });
        };
        return Xliff2TranslationSerializer;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/translation_files/xmb_translation_serializer.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";
    var XmbTranslationSerializer = /** @class */ (function () {
        function XmbTranslationSerializer() {
        }
        /**
         * @param {?} messages
         * @return {?}
         */
        XmbTranslationSerializer.prototype.renderFile = /**
         * @param {?} messages
         * @return {?}
         */
        function (messages) {
            var _this = this;
            /** @type {?} */
            var xml = new XmlFile();
            xml.startTag('messagebundle');
            messages.forEach((/**
             * @param {?} message
             * @return {?}
             */
            function (message) {
                xml.startTag('msg', {
                    id: ((/** @type {?} */ (message))).id ||
                        ((/** @type {?} */ (message))).messageId,
                    desc: message.description,
                    meaning: message.meaning
                }, { preserveWhitespace: true });
                _this.renderMessage(xml, message);
                xml.endTag('msg', { preserveWhitespace: false });
            }));
            xml.endTag('messagebundle');
            return xml.toString();
        };
        /**
         * @private
         * @param {?} xml
         * @param {?} message
         * @return {?}
         */
        XmbTranslationSerializer.prototype.renderMessage = /**
         * @private
         * @param {?} xml
         * @param {?} message
         * @return {?}
         */
        function (xml, message) {
            xml.text(message.messageParts[0]);
            for (var i = 1; i < message.messageParts.length; i++) {
                xml.startTag('ph', { name: message.placeholderNames[i - 1] }, { selfClosing: true });
                xml.text(message.messageParts[i]);
            }
        };
        return XmbTranslationSerializer;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/translation_files/xtb_translation_serializer.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DOCTYPE$1 = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE translationbundle [\n<!ELEMENT translationbundle (translation)*>\n<!ATTLIST translationbundle lang CDATA #REQUIRED>\n\n<!ELEMENT translation (#PCDATA|ph)*>\n<!ATTLIST translation id CDATA #REQUIRED>\n<!ATTLIST translation desc CDATA #IMPLIED>\n<!ATTLIST translation meaning CDATA #IMPLIED>\n<!ATTLIST translation xml:space (default|preserve) \"default\">\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>\n]>\n";
    var XtbTranslationSerializer = /** @class */ (function () {
        function XtbTranslationSerializer() {
        }
        /**
         * @param {?} messages
         * @param {?} locale
         * @return {?}
         */
        XtbTranslationSerializer.prototype.renderFile = /**
         * @param {?} messages
         * @param {?} locale
         * @return {?}
         */
        function (messages, locale) {
            var _this = this;
            /** @type {?} */
            var xml = new XmlFile();
            xml.startTag('translationbundle', { lang: locale });
            messages.forEach((/**
             * @param {?} message
             * @return {?}
             */
            function (message) {
                xml.startTag('translation', {
                    id: ((/** @type {?} */ (message))).id ||
                        ((/** @type {?} */ (message))).messageId,
                    desc: message.description,
                    meaning: message.meaning
                }, { preserveWhitespace: true });
                _this.renderMessage(xml, message);
                xml.endTag('translation', { preserveWhitespace: false });
            }));
            xml.endTag('translationbundle');
            return DOCTYPE$1 + xml.toString();
        };
        /**
         * @private
         * @param {?} xml
         * @param {?} message
         * @return {?}
         */
        XtbTranslationSerializer.prototype.renderMessage = /**
         * @private
         * @param {?} xml
         * @param {?} message
         * @return {?}
         */
        function (xml, message) {
            xml.text(message.messageParts[0]);
            for (var i = 1; i < message.messageParts.length; i++) {
                xml.startTag('ph', { name: message.placeholderNames[i - 1] }, { selfClosing: true });
                xml.text(message.messageParts[i]);
            }
        };
        return XtbTranslationSerializer;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/common/util.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} format
     * @return {?}
     */
    function getTranslationSerializer(format) {
        switch (format) {
            case 'json':
                return new JsonTranslationSerializer();
            case 'xliff1':
            case 'xlf':
                return new Xliff1TranslationSerializer();
            case 'xliff2':
            case 'xlf2':
                return new Xliff2TranslationSerializer();
            case 'xmb':
                return new XmbTranslationSerializer();
            case 'xtb':
                return new XtbTranslationSerializer();
        }
    }
    /**
     * @param {?} format
     * @return {?}
     */
    function getExtension(format) {
        switch (format) {
            case 'json':
            case 'xmb':
            case 'xtb':
                return format;
            default:
                return 'xlf';
        }
    }
    /**
     * The character used to mark the start and end of a "block" in a `$localize` tagged string.
     * A block can indicate metadata about the message or specify a name of a placeholder for a
     * substitution expressions.
     *
     * For example:
     *
     * ```ts
     * $localize`Hello, ${title}:title:!`;
     * $localize`:meaning|description\@\@id:source message text`;
     * ```
     * @type {?}
     */
    var BLOCK_MARKER = ':';
    /**
     * Find the end of a "marked block" indicated by the first non-escaped colon.
     *
     * @throws an error if the block is unterminated
     * @param {?} cooked The cooked string (where escaped chars have been processed)
     * @param {?} raw The raw string (where escape sequences are still in place)
     *
     * @return {?} the index of the end of block marker
     */
    function findEndOfBlock(cooked, raw) {
        /************************************************************************************************
         * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.
         * (See that file for more explanation of why.)
         ************************************************************************************************/
        for (var cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {
            if (raw[rawIndex] === '\\') {
                rawIndex++;
            }
            else if (cooked[cookedIndex] === BLOCK_MARKER) {
                return cookedIndex;
            }
        }
        throw new Error("Unterminated $localize metadata block in \"" + raw + "\".");
    }
    /**
     * Split a message part (`cooked` + `raw`) into an optional delimited "block" off the front and the
     * rest of the text of the message part.
     *
     * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the
     * start and end of the block.
     *
     * If the block is in the first message part then it will be metadata about the whole message:
     * meaning, description, id.  Otherwise it will be metadata about the immediately preceding
     * substitution: placeholder name.
     *
     * Since blocks are optional, it is possible that the content of a message block actually starts
     * with a block marker. In this case the marker must be escaped `\:`.
     *
     * @throws an error if the `block` is unterminated
     * @param {?} cooked The cooked version of the message part to parse.
     * @param {?} raw The raw version of the message part to parse.
     * @return {?} An object containing the `text` of the message part and the text of the `block`, if it
     * exists.
     */
    function splitBlock(cooked, raw) {
        if (raw.charAt(0) !== BLOCK_MARKER) {
            return { text: cooked };
        }
        else {
            /** @type {?} */
            var endOfBlock = findEndOfBlock(cooked, raw);
            return {
                block: cooked.substring(1, endOfBlock),
                text: cooked.substring(endOfBlock + 1)
            };
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    function computePlaceholderName(index) {
        return index === 1 ? 'PH' : "PH_" + (index - 1);
    }
    /**
     * @param {?} id
     * @param {?} translation
     * @return {?}
     */
    function translationToMessage(id, translation) {
        /** @type {?} */
        var messageParts = translation.messageParts;
        /** @type {?} */
        var legacyIds = [];
        /** @type {?} */
        var cleanedMessageParts = [messageParts[0]];
        /** @type {?} */
        var substitutions = {};
        /** @type {?} */
        var placeholderNames = [];
        /** @type {?} */
        var text = messageParts[0];
        for (var i = 1; i < messageParts.length; i++) {
            var _a = splitBlock(messageParts[i], messageParts.raw[i]), messagePart = _a.text, _b = _a.block, placeholderName = _b === void 0 ? translation.placeholderNames[i - 1] ||
                computePlaceholderName(i) : _b;
            text += "{$" + placeholderName + "}" + messagePart;
            if (translation.placeholderNames.length) {
                substitutions[placeholderName] = translation.placeholderNames[i - 1];
            }
            placeholderNames.push(placeholderName);
            cleanedMessageParts.push(messagePart);
        }
        return {
            id: id,
            legacyIds: legacyIds,
            substitutions: substitutions,
            text: text,
            meaning: translation.meaning || '',
            description: translation.description || '',
            messageParts: cleanedMessageParts,
            placeholderNames: placeholderNames
        };
    }
    /**
     * @record
     */
    function ParsedMessageLegacy() { }
    if (false) {
        /**
         * The key used to look up the appropriate translation target.
         * @type {?}
         */
        ParsedMessageLegacy.prototype.messageId;
        /**
         * Legacy message ids, if provided.
         *
         * In legacy message formats the message id can only be computed directly from the original
         * template source.
         *
         * Since this information is not available in `$localize` calls, the legacy message ids may be
         * attached by the compiler to the `$localize` metablock so it can be used if needed at the point
         * of translation if the translations are encoded using the legacy message id.
         * @type {?}
         */
        ParsedMessageLegacy.prototype.legacyIds;
        /**
         * A mapping of placeholder names to substitution values.
         * @type {?}
         */
        ParsedMessageLegacy.prototype.substitutions;
        /**
         * A human readable rendering of the message
         * @type {?}
         */
        ParsedMessageLegacy.prototype.messageString;
        /**
         * The meaning of the `message`, used to distinguish identical `messageString`s.
         * @type {?}
         */
        ParsedMessageLegacy.prototype.meaning;
        /**
         * The description of the `message`, used to aid translation.
         * @type {?}
         */
        ParsedMessageLegacy.prototype.description;
        /**
         * The static parts of the message.
         * @type {?}
         */
        ParsedMessageLegacy.prototype.messageParts;
        /**
         * The names of the placeholders that will be replaced with substitutions.
         * @type {?}
         */
        ParsedMessageLegacy.prototype.placeholderNames;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/source_file_utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Is the given `expression` an identifier with the correct name
     * @param {?} expression The expression to check.
     * @param {?} name
     * @return {?}
     */
    function isNamedIdentifier(expression, name) {
        return expression.isIdentifier() && expression.node.name === name;
    }
    /**
     * Is the given `identifier` declared globally.
     * @param {?} identifier The identifier to check.
     * @return {?}
     */
    function isGlobalIdentifier(identifier) {
        return (!identifier.scope || !identifier.scope.hasBinding(identifier.node.name));
    }
    /**
     * Build a translated expression to replace the call to `$localize`.
     * @param {?} messageParts The static parts of the message.
     * @param {?} substitutions The expressions to substitute into the message.
     * @return {?}
     */
    function buildLocalizeReplacement(messageParts, substitutions) {
        /** @type {?} */
        var mappedString = types.stringLiteral(messageParts[0]);
        for (var i = 1; i < messageParts.length; i++) {
            mappedString = types.binaryExpression('+', mappedString, wrapInParensIfNecessary(substitutions[i - 1]));
            mappedString = types.binaryExpression('+', mappedString, types.stringLiteral(messageParts[i]));
        }
        return mappedString;
    }
    /**
     * Extract the message parts from the given `call` (to `$localize`).
     *
     * The message parts will either by the first argument to the `call` or it will be wrapped in call
     * to a helper function like `__makeTemplateObject`.
     *
     * @param {?} call The AST node of the call to process.
     * @return {?}
     */
    function unwrapMessagePartsFromLocalizeCall(call) {
        /** @type {?} */
        var cooked = (/** @type {?} */ (call.get('arguments')[0]));
        if (cooked === undefined) {
            throw new BabelParseError(call.node, '`$localize` called without any arguments.');
        }
        if (!cooked.isExpression()) {
            throw new BabelParseError(cooked.node, 'Unexpected argument to `$localize` (expected an array).');
        }
        // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.
        /** @type {?} */
        var raw = cooked;
        // Check for cached call of the form `x || x = __makeTemplateObject(...)`
        if (cooked.isLogicalExpression() &&
            cooked.node.operator === '||' &&
            cooked.get('left').isIdentifier()) {
            /** @type {?} */
            var right = cooked.get('right');
            if (right.isAssignmentExpression()) {
                cooked = right.get('right');
                if (!cooked.isExpression()) {
                    throw new BabelParseError(cooked.node, 'Unexpected "makeTemplateObject()" function (expected an expression).');
                }
            }
        }
        // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.
        if (cooked.isCallExpression()) {
            /** @type {?} */
            var cookedCall = cooked;
            if (cookedCall.get('arguments').length === 0) {
                // No arguments so perhaps it is a `__templateObject()` call.
                // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.
                cookedCall = unwrapLazyLoadHelperCall(cookedCall);
            }
            cooked = cookedCall.get('arguments')[0];
            if (!cooked.isExpression()) {
                throw new BabelParseError(cooked.node, 'Unexpected `cooked` argument to the "makeTemplateObject()" function (expected an expression).');
            }
            /** @type {?} */
            var arg2 = cookedCall.get('arguments')[1];
            if (arg2 && !arg2.isExpression()) {
                throw new BabelParseError(arg2.node, 'Unexpected `raw` argument to the "makeTemplateObject()" function (expected an expression).');
            }
            // If there is no second argument then assume that raw and cooked are the same
            raw = arg2 !== undefined ? arg2 : cooked;
        }
        /** @type {?} */
        var cookedStrings = unwrapStringLiteralArray(cooked.node);
        /** @type {?} */
        var rawStrings = unwrapStringLiteralArray(raw.node);
        return localize.makeTemplateObject(cookedStrings, rawStrings);
    }
    /**
     * @param {?} call
     * @return {?}
     */
    function unwrapSubstitutionsFromLocalizeCall(call) {
        /** @type {?} */
        var expressions = call.arguments.splice(1);
        if (!isArrayOfExpressions(expressions)) {
            /** @type {?} */
            var badExpression = (/** @type {?} */ (expressions.find((/**
             * @param {?} expression
             * @return {?}
             */
            function (expression) { return !types.isExpression(expression); }))));
            throw new BabelParseError(badExpression, 'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).');
        }
        return expressions;
    }
    /**
     * @param {?} elements
     * @return {?}
     */
    function unwrapMessagePartsFromTemplateLiteral(elements) {
        /** @type {?} */
        var cooked = elements.map((/**
         * @param {?} q
         * @return {?}
         */
        function (q) {
            if (q.value.cooked === undefined) {
                throw new BabelParseError(q, "Unexpected undefined message part in \"" + elements.map((/**
                 * @param {?} eq
                 * @return {?}
                 */
                function (eq) { return eq.value.cooked; })) + "\"");
            }
            return q.value.cooked;
        }));
        /** @type {?} */
        var raw = elements.map((/**
         * @param {?} q
         * @return {?}
         */
        function (q) { return q.value.raw; }));
        return localize.makeTemplateObject(cooked, raw);
    }
    /**
     * Wrap the given `expression` in parentheses if it is a binary expression.
     *
     * This ensures that this expression is evaluated correctly if it is embedded in another expression.
     *
     * @param {?} expression The expression to potentially wrap.
     * @return {?}
     */
    function wrapInParensIfNecessary(expression) {
        if (types.isBinaryExpression(expression)) {
            return types.parenthesizedExpression(expression);
        }
        else {
            return expression;
        }
    }
    /**
     * Extract the string values from an `array` of string literals.
     * @param {?} array The array to unwrap.
     * @return {?}
     */
    function unwrapStringLiteralArray(array) {
        if (!isStringLiteralArray(array)) {
            throw new BabelParseError(array, 'Unexpected messageParts for `$localize` (expected an array of strings).');
        }
        return array.elements.map((/**
         * @param {?} str
         * @return {?}
         */
        function (str) { return str.value; }));
    }
    /**
     * This expression is believed to be a call to a "lazy-load" template object helper function.
     * This is expected to be of the form:
     *
     * ```ts
     *  function _templateObject() {
     *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);
     *    return _templateObject = function() { return e }, e
     *  }
     * ```
     *
     * We unwrap this to return the call to `_taggedTemplateLiteral()`.
     *
     * @param {?} call the call expression to unwrap
     * @return {?} the  call expression
     */
    function unwrapLazyLoadHelperCall(call) {
        /** @type {?} */
        var callee = (/** @type {?} */ (call.get('callee')));
        if (!callee.isIdentifier()) {
            throw new BabelParseError(callee.node, 'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).');
        }
        /** @type {?} */
        var lazyLoadBinding = call.scope.getBinding(callee.node.name);
        if (!lazyLoadBinding) {
            throw new BabelParseError(callee.node, 'Missing declaration for lazy-load helper function');
        }
        /** @type {?} */
        var lazyLoadFn = lazyLoadBinding.path;
        if (!lazyLoadFn.isFunctionDeclaration()) {
            throw new BabelParseError(((/** @type {?} */ (lazyLoadFn))).node, 'Unexpected expression (expected a function declaration');
        }
        /** @type {?} */
        var returnedNode = getReturnedExpression(lazyLoadFn);
        if (returnedNode.isCallExpression()) {
            return returnedNode;
        }
        if (returnedNode.isIdentifier()) {
            /** @type {?} */
            var identifierName = returnedNode.node.name;
            /** @type {?} */
            var declaration = returnedNode.scope.getBinding(identifierName);
            if (declaration === undefined) {
                throw new BabelParseError(returnedNode.node, 'Missing declaration for return value from helper.');
            }
            if (!declaration.path.isVariableDeclarator()) {
                throw new BabelParseError(((/** @type {?} */ (declaration))).path.node, 'Unexpected helper return value declaration (expected a variable declaration).');
            }
            /** @type {?} */
            var initializer = declaration.path.get('init');
            if (!initializer.isCallExpression()) {
                throw new BabelParseError(declaration.path.node, 'Unexpected return value from helper (expected a call expression).');
            }
            // Remove the lazy load helper if this is the only reference to it.
            if (lazyLoadBinding.references === 1) {
                lazyLoadFn.remove();
            }
            return initializer;
        }
        return call;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function getReturnedExpression(fn) {
        var e_1, _a;
        /** @type {?} */
        var bodyStatements = ((/** @type {?} */ (fn.get('body')))).get('body');
        try {
            for (var bodyStatements_1 = __values(bodyStatements), bodyStatements_1_1 = bodyStatements_1.next(); !bodyStatements_1_1.done; bodyStatements_1_1 = bodyStatements_1.next()) {
                var statement = bodyStatements_1_1.value;
                if (statement.isReturnStatement()) {
                    /** @type {?} */
                    var argument = statement.get('argument');
                    if (argument.isSequenceExpression()) {
                        /** @type {?} */
                        var expressions = argument.get('expressions');
                        return Array.isArray(expressions)
                            ? expressions[expressions.length - 1]
                            : expressions;
                    }
                    else if (argument.isExpression()) {
                        return argument;
                    }
                    else {
                        throw new BabelParseError(statement.node, 'Invalid return argument in helper function (expected an expression).');
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (bodyStatements_1_1 && !bodyStatements_1_1.done && (_a = bodyStatements_1.return)) _a.call(bodyStatements_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        throw new BabelParseError(fn.node, 'Missing return statement in helper function.');
    }
    /**
     * Is the given `node` an array of literal strings?
     *
     * @param {?} node The node to test.
     * @return {?}
     */
    function isStringLiteralArray(node) {
        return (types.isArrayExpression(node) &&
            node.elements.every((/**
             * @param {?} element
             * @return {?}
             */
            function (element) { return types.isStringLiteral(element); })));
    }
    /**
     * Are all the given `nodes` expressions?
     * @param {?} nodes The nodes to test.
     * @return {?}
     */
    function isArrayOfExpressions(nodes) {
        return nodes.every((/**
         * @param {?} element
         * @return {?}
         */
        function (element) { return types.isExpression(element); }));
    }
    /**
     * Options that affect how the `makeEsXXXTranslatePlugin()` functions work.
     * @record
     */
    function TranslatePluginOptions() { }
    if (false) {
        /** @type {?|undefined} */
        TranslatePluginOptions.prototype.missingTranslation;
        /** @type {?|undefined} */
        TranslatePluginOptions.prototype.localizeName;
    }
    /**
     * Translate the text of the given message, using the given translations.
     *
     * Logs as warning if the translation is not available
     * @param {?} diagnostics
     * @param {?} translations
     * @param {?} messageParts
     * @param {?} substitutions
     * @param {?} missingTranslation
     * @return {?}
     */
    function translate(diagnostics, translations, messageParts, substitutions, missingTranslation) {
        try {
            return localize.translate(translations, messageParts, substitutions);
        }
        catch (e) {
            if (localize.isMissingTranslationError(e)) {
                if (missingTranslation === 'error') {
                    diagnostics.error(e.message);
                }
                else if (missingTranslation === 'warning') {
                    diagnostics.warn(e.message);
                }
                // Return the parsed message because this will have the meta blocks stripped
                return [
                    localize.makeTemplateObject(e.parsedMessage.messageParts, e.parsedMessage.messageParts),
                    substitutions
                ];
            }
            else {
                diagnostics.error(e.message);
                return [messageParts, substitutions];
            }
        }
    }
    var BabelParseError = /** @class */ (function (_super) {
        __extends(BabelParseError, _super);
        function BabelParseError(node, message) {
            var _this = _super.call(this, message) || this;
            _this.node = node;
            _this.type = 'BabelParseError';
            return _this;
        }
        return BabelParseError;
    }(Error));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        BabelParseError.prototype.type;
        /** @type {?} */
        BabelParseError.prototype.node;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    function isBabelParseError(e) {
        return e.type === 'BabelParseError';
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/source_files/es2015_extract_plugin.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} messages
     * @param {?} diagnostics
     * @param {?=} localizeName
     * @return {?}
     */
    function makeEs2015ExtractPlugin(messages, diagnostics, localizeName) {
        if (localizeName === void 0) { localizeName = '$localize'; }
        return {
            visitor: {
                TaggedTemplateExpression: /**
                 * @param {?} path
                 * @return {?}
                 */
                function (path) {
                    /** @type {?} */
                    var tag = path.get('tag');
                    if (isNamedIdentifier(tag, localizeName) && isGlobalIdentifier(tag)) {
                        /** @type {?} */
                        var messageParts = unwrapMessagePartsFromTemplateLiteral(path.node.quasi.quasis);
                        /** @type {?} */
                        var message_1 = localize.parseMessage(messageParts, path.node.quasi.expressions);
                        if (!messages.find((/**
                         * @param {?} msg
                         * @return {?}
                         */
                        function (msg) {
                            return message_1.id
                                ? msg.id === message_1.id
                                : msg.messageId ===
                                    ((/** @type {?} */ (((/** @type {?} */ (message_1)))))).messageId;
                        }))) {
                            messages.push(message_1);
                        }
                    }
                }
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/source_files/es5_extract_plugin.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} messages
     * @param {?} diagnostics
     * @param {?=} localizeName
     * @return {?}
     */
    function makeEs5ExtractPlugin(messages, diagnostics, localizeName) {
        if (localizeName === void 0) { localizeName = '$localize'; }
        return {
            visitor: {
                CallExpression: /**
                 * @param {?} callPath
                 * @return {?}
                 */
                function (callPath) {
                    /** @type {?} */
                    var calleePath = callPath.get('callee');
                    if (isNamedIdentifier(calleePath, localizeName) &&
                        isGlobalIdentifier(calleePath)) {
                        /** @type {?} */
                        var messageParts = unwrapMessagePartsFromLocalizeCall(callPath);
                        /** @type {?} */
                        var expressions = unwrapSubstitutionsFromLocalizeCall(callPath.node);
                        /** @type {?} */
                        var message_1 = localize.parseMessage(messageParts, expressions);
                        if (!messages.find((/**
                         * @param {?} msg
                         * @return {?}
                         */
                        function (msg) {
                            return message_1.id
                                ? msg.id === message_1.id
                                : msg.messageId ===
                                    ((/** @type {?} */ (((/** @type {?} */ (message_1)))))).messageId;
                        }))) {
                            messages.push(message_1);
                        }
                    }
                }
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract/extractor.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A class that extracts parsed messages from file contents, by parsing the contents as JavaScript
     * and looking for occurrences of `$localize` in the source code.
     */
    var /**
     * A class that extracts parsed messages from file contents, by parsing the contents as JavaScript
     * and looking for occurrences of `$localize` in the source code.
     */
    Extractor = /** @class */ (function () {
        function Extractor(diagnostics) {
            this.diagnostics = diagnostics;
            this.messages = [];
        }
        /**
         * @param {?} sourceCode
         * @return {?}
         */
        Extractor.prototype.extractMessages = /**
         * @param {?} sourceCode
         * @return {?}
         */
        function (sourceCode) {
            if (sourceCode.includes('$localize')) {
                // Only bother to parse the file if it contains a reference to `$localize`.
                core$1.transformSync(sourceCode, {
                    plugins: [
                        makeEs2015ExtractPlugin(this.messages, this.diagnostics),
                        makeEs5ExtractPlugin(this.messages, this.diagnostics)
                    ],
                    code: false,
                    ast: false
                });
            }
        };
        return Extractor;
    }());
    if (false) {
        /** @type {?} */
        Extractor.prototype.messages;
        /**
         * @type {?}
         * @private
         */
        Extractor.prototype.diagnostics;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: cmds/extract.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var command = 'extract';
    /** @type {?} */
    var describe = 'Extract translations from your ivy application';
    /** @type {?} */
    var builder = {
        s: {
            alias: 'source',
            required: true,
            describe: 'A glob pattern indicating what files to search for translations, e.g. `./dist/**/*.js`. This can be absolute or relative to the current working directory.'
        },
        f: {
            alias: 'format',
            required: true,
            describe: 'The format of the translation files to generate.',
            choices: ['json', 'xlf', 'xmb', 'xlf2'],
            default: 'json'
        },
        o: {
            alias: 'outputPath',
            required: true,
            describe: 'A path to where the translation file will be written. This can be absolute or relative to the current working directory.'
        },
        l: {
            alias: ['locale', 'locales'],
            required: false,
            type: 'array',
            describe: 'The locale for the extracted file, "en" by default. If you use multiple locales (e.g. "en fr es"), a new file will be generated for each locale'
        }
    };
    /** @type {?} */
    var handler = (/**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        /** @type {?} */
        var diagnostics = new Diagnostics();
        extractTranslations({
            sourceGlob: (/** @type {?} */ (options['s'])),
            format: (/** @type {?} */ (options['f'])),
            outputPath: (/** @type {?} */ (options['o'])),
            locales: (/** @type {?} */ (options['l'])),
            diagnostics: diagnostics
        });
        diagnostics.logMessages();
        process.exit(diagnostics.hasErrors ? 1 : 0);
    });
    /**
     * @record
     */
    function ExtractTranslationsOptions() { }
    if (false) {
        /** @type {?} */
        ExtractTranslationsOptions.prototype.sourceGlob;
        /** @type {?} */
        ExtractTranslationsOptions.prototype.format;
        /** @type {?} */
        ExtractTranslationsOptions.prototype.outputPath;
        /** @type {?|undefined} */
        ExtractTranslationsOptions.prototype.locales;
        /** @type {?} */
        ExtractTranslationsOptions.prototype.diagnostics;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    function extractTranslations(_a) {
        var source = _a.sourceGlob, format = _a.format, output = _a.outputPath, _b = _a.locales, locales = _b === void 0 ? ['en'] : _b, diagnostics = _a.diagnostics;
        console.log("Extracting translations from \"" + source + "\"");
        /** @type {?} */
        var filesToProcess = glob.sync(path.resolve(source), {
            absolute: true,
            nodir: true
        });
        filesToProcess = FileUtils.dedup(filesToProcess, /\-es(5|2015)\./, '.');
        output = path.resolve(output);
        /** @type {?} */
        var generatedFiles = [];
        /** @type {?} */
        var isFile;
        try {
            /** @type {?} */
            var stat = fs.statSync(output);
            isFile = stat.isFile();
        }
        catch (e) {
            isFile = !!path.extname(output);
        }
        if (isFile) {
            if (locales.length > 1) {
                diagnostics.error("Multiple locales detected (\"" + locales.join(',') + "\") but output \"" + output + "\" is not a directory");
                return;
            }
            /** @type {?} */
            var res = makeTranslationsFile(filesToProcess, path.posix.normalize(output), source, format, locales[0], diagnostics);
            if (res) {
                generatedFiles.push(res);
            }
        }
        else {
            filesToProcess.forEach((/**
             * @param {?} file
             * @return {?}
             */
            function (file) {
                locales.forEach((/**
                 * @param {?} locale
                 * @return {?}
                 */
                function (locale) {
                    /** @type {?} */
                    var newFileName = path.posix.join(output, path.basename(file, '.js').replace(/-es(5|2015)/, '') +
                        '.' +
                        locale +
                        '.' +
                        getExtension(format));
                    /** @type {?} */
                    var res = makeTranslationsFile([file], newFileName, source, format, locale, diagnostics);
                    if (res) {
                        generatedFiles.push(res);
                    }
                }));
            }));
        }
        if (!generatedFiles.length) {
            diagnostics.error("No messages found. You should build the angular app without a language target for this command to work.");
            return;
        }
    }
    /**
     * @param {?} filesToProcess
     * @param {?} fileOutput
     * @param {?} source
     * @param {?} format
     * @param {?} locale
     * @param {?} diagnostics
     * @return {?}
     */
    function makeTranslationsFile(filesToProcess, fileOutput, source, format, locale, diagnostics) {
        /** @type {?} */
        var extractor = new Extractor(diagnostics);
        filesToProcess.forEach((/**
         * @param {?} file
         * @return {?}
         */
        function (file) {
            /** @type {?} */
            var contents = fs.readFileSync(file, 'utf8');
            extractor.extractMessages(contents);
        }));
        /** @type {?} */
        var serializer = getTranslationSerializer(format);
        if (extractor.messages.length > 0) {
            /** @type {?} */
            var translationFile = serializer.renderFile(extractor.messages, locale, false);
            FileUtils.writeFile(fileOutput, translationFile);
            console.log("  Generated file \"" + fileOutput + "\"");
            return fileOutput;
        }
        return null;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: main.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var configPath = findUp.sync(['.loclrc', '.locl.json']);
    /** @type {?} */
    var config = configPath
        ? JSON.parse(fs.readFileSync(configPath, { encoding: 'utf8' }))
        : {};
    /** @type {?} */
    var args = process.argv.slice(2);
    yargs.config(config)
        .commandDir('cmds')
        .demandCommand()
        .help()
        .version(false)
        .parse(args);

    exports.CliModule = CliModule;
    exports.builder = builder;
    exports.command = command;
    exports.describe = describe;
    exports.extractTranslations = extractTranslations;
    exports.handler = handler;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=locl-cli.umd.js.map
