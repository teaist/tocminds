{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@locl/cli/lib/cli.module.ts","ng://@locl/cli/cmds/common/diagnostics.ts","ng://@locl/cli/cmds/common/file_utils.ts","ng://@locl/cli/cmds/extract/translation_files/json_translation_serializer.ts","ng://@locl/cli/cmds/extract/translation_files/xml_file.ts","ng://@locl/cli/cmds/extract/translation_files/xliff1_translation_serializer.ts","ng://@locl/cli/cmds/extract/translation_files/xliff2_translation_serializer.ts","ng://@locl/cli/cmds/extract/translation_files/xmb_translation_serializer.ts","ng://@locl/cli/cmds/extract/translation_files/xtb_translation_serializer.ts","ng://@locl/cli/cmds/extract/source_file_utils.ts","ng://@locl/cli/cmds/extract/source_files/es2015_extract_plugin.ts","ng://@locl/cli/cmds/extract/extractor.ts","ng://@locl/cli/cmds/extract/source_files/es5_extract_plugin.ts","ng://@locl/cli/cmds/extract.ts","ng://@locl/cli/cmds/common/util.ts","ng://@locl/cli/main.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__values","o","m","Symbol","iterator","i","call","next","length","value","done","CliModule","NgModule","args","imports","declarations","exports","Diagnostics","this","messages","defineProperty","prototype","some","type","log","message","push","warn","error","formatDiagnostics","errors","filter","map","warnings","join","logMessages","shift","console","chalk.yellow","chalk.red","chalk.blue","FileUtils","readFile","absolutePath","fs.readFileSync","readFileBuffer","writeFile","contents","ensureDir","path.dirname","fs.writeFileSync","parents","isRoot","fs.existsSync","fs.mkdirSync","pop","remove","stat","fs.statSync","isFile","fs.unlinkSync","isDirectory","fs.readdirSync","forEach","child","absChild","path.resolve","fs.rmdirSync","dedup","files","pattern","replaceValue","filesSet","file","replace","indexes","index","indexOf","JsonTranslationSerializer","renderFile","locale","fileObj","translations","id","messageId","text","messageString","JSON","stringify","XmlFile","output","indent","elements","preservingWhitespace","toString","startTag","name","attributes","_a","_this","_b","_c","selfClosing","preserveWhitespace","keys","attrName","escapeXml","incIndent","undefined","endTag","expectedTag","Error","decIndent","str","startPreserveWhitespace","stopPreserveWhitespace","slice","_ESCAPED_CHARS","reduce","t","entry","Xliff1TranslationSerializer","isTarget","xml","version","xmlns","fileAttrs","datatype","generateMessageTag","description","renderNote","meaning","tagName","renderMessage","messageParts","placeholderNames","priority","from","Xliff2TranslationSerializer","srcLang","trgLang","placeholderName","startsWith","equivStart","equivEnd","equiv","category","XmbTranslationSerializer","desc","XtbTranslationSerializer","lang","isNamedIdentifier","expression","isIdentifier","node","isGlobalIdentifier","identifier","scope","hasBinding","unwrapMessagePartsFromLocalizeCall","cooked","get","BabelParseError","isExpression","raw","isLogicalExpression","operator","right","isAssignmentExpression","isCallExpression","cookedCall","callee","lazyLoadBinding","getBinding","lazyLoadFn","path","isFunctionDeclaration","returnedNode","fn","bodyStatements","bodyStatements_1","bodyStatements_1_1","statement","isReturnStatement","argument","isSequenceExpression","expressions","isArray","getReturnedExpression","identifierName","declaration","isVariableDeclarator","initializer","references","unwrapLazyLoadHelperCall","arg2","cookedStrings","unwrapStringLiteralArray","rawStrings","ɵmakeTemplateObject","unwrapSubstitutionsFromLocalizeCall","arguments","splice","every","element","t.isExpression","badExpression","find","array","t.isArrayExpression","t.isStringLiteral","_super","__","constructor","create","__extends","makeEs2015ExtractPlugin","diagnostics","localizeName","visitor","TaggedTemplateExpression","tag","quasi","quasis","q","eq","message_1","ɵparseMessage","msg","Extractor","extractMessages","sourceCode","includes","transformSync","plugins","CallExpression","callPath","calleePath","code","ast","extractTranslations","source","sourceGlob","format","outputPath","locales","filesToProcess","sync","resolve","absolute","nodir","generatedFiles","statSync","e","extname","res","makeTranslationsFile","posix","normalize","newFileName","basename","getExtension","fileOutput","extractor","readFileSync","serializer","getTranslationSerializer","translationFile","configPath","findUp.sync","config","parse","encoding","process","argv","yargs\r\n    .config","commandDir","demandCommand","help","s","alias","required","describe","f","choices","default","l","options","exit","hasErrors"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { NgModule } from '@angular/core';\n\n// not used, only there to make ng-packagr happy\n@NgModule({\n  imports: [],\n  declarations: [],\n  exports: []\n})\nexport class CliModule {}\n","import * as chalk from 'chalk';\n\n/**\n * This class is used to collect and then report warnings and errors that occur during the execution\n * of the tools.\n */\nexport class Diagnostics {\n  readonly messages = [];\n\n  get hasErrors() {\n    return this.messages.some(m => m.type === 'error');\n  }\n\n  log(message: string) {\n    this.messages.push({ type: '', message });\n  }\n\n  warn(message: string) {\n    this.messages.push({ type: 'warning', message });\n  }\n\n  error(message: string) {\n    this.messages.push({ type: 'error', message });\n  }\n\n  formatDiagnostics(message: string): string {\n    const errors = this.messages!.filter(d => d.type === 'error').map(\n      d => ' - ' + d.message\n    );\n    const warnings = this.messages!.filter(d => d.type === 'warning').map(\n      d => ' - ' + d.message\n    );\n    if (errors.length) {\n      message += '\\nERRORS:\\n' + errors.join('\\n');\n    }\n    if (warnings.length) {\n      message += '\\nWARNINGS:\\n' + warnings.join('\\n');\n    }\n    return message;\n  }\n\n  logMessages() {\n    while (this.messages.length) {\n      const m = this.messages.shift();\n      switch (m.type) {\n        case 'warning':\n          console.warn(chalk.yellow(`Warning: ${m.message}`));\n          break;\n        case 'error':\n          console.error(chalk.red(`Error: ${m.message}`));\n          break;\n        default:\n          console.log(chalk.blue(`${m.message}`));\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport class FileUtils {\n  static readFile(absolutePath: string): string {\n    return fs.readFileSync(absolutePath, 'utf8');\n  }\n\n  static readFileBuffer(absolutePath: string): Buffer {\n    return fs.readFileSync(absolutePath);\n  }\n\n  static writeFile(absolutePath: string, contents: string | Buffer) {\n    FileUtils.ensureDir(path.dirname(absolutePath));\n    fs.writeFileSync(absolutePath, contents);\n  }\n\n  static ensureDir(absolutePath: string): void {\n    const parents: string[] = [];\n    while (!FileUtils.isRoot(absolutePath) && !fs.existsSync(absolutePath)) {\n      parents.push(absolutePath);\n      absolutePath = path.dirname(absolutePath);\n    }\n    while (parents.length) {\n      fs.mkdirSync(parents.pop()!);\n    }\n  }\n\n  static remove(p: string): void {\n    const stat = fs.statSync(p);\n    if (stat.isFile()) {\n      fs.unlinkSync(p);\n    } else if (stat.isDirectory()) {\n      fs.readdirSync(p).forEach(child => {\n        const absChild = path.resolve(p, child);\n        FileUtils.remove(absChild);\n      });\n      fs.rmdirSync(p);\n    }\n  }\n\n  static isRoot(absolutePath: string): boolean {\n    return path.dirname(absolutePath) === absolutePath;\n  }\n\n  static dedup(files: string[], pattern: RegExp, replaceValue = ''): string[] {\n    const filesSet = files.map(file => file.replace(pattern, replaceValue));\n    const dedup = [];\n    const indexes = [];\n    filesSet.forEach((file: string, index: number) => {\n      if (dedup.indexOf(file) === -1) {\n        dedup.push(file);\n        indexes.push(index);\n      }\n    });\n    return indexes.map(index => files[index]);\n  }\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\nimport { TranslationSerializer } from './translation_serializer';\r\n\r\ninterface SimpleJsonTranslationFile {\r\n  locale: string;\r\n  translations: Record<string, string>;\r\n}\r\n\r\nexport class JsonTranslationSerializer implements TranslationSerializer {\r\n  renderFile(\r\n    messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n    locale: string\r\n  ): string {\r\n    const fileObj: SimpleJsonTranslationFile = {\r\n      locale,\r\n      translations: {}\r\n    };\r\n    messages.forEach(message => {\r\n      fileObj.translations[\r\n        (message as ɵParsedMessage).id ||\r\n          (message as ParsedMessageLegacy).messageId\r\n      ] =\r\n        (message as ɵParsedMessage).text ||\r\n        (message as ParsedMessageLegacy).messageString;\r\n    });\r\n    return JSON.stringify(fileObj, null, 2);\r\n  }\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ninterface Options {\n  selfClosing?: boolean;\n  preserveWhitespace?: boolean;\n}\n\nexport class XmlFile {\n  private output = '';\n  private indent = '';\n  private elements: string[] = [];\n  private preservingWhitespace = false;\n  toString() {\n    return this.output;\n  }\n\n  startTag(\n    name: string,\n    attributes: Record<string, string> = {},\n    { selfClosing = false, preserveWhitespace }: Options = {}\n  ): this {\n    if (!this.preservingWhitespace) {\n      this.output += this.indent;\n    }\n\n    this.output += `<${name}`;\n\n    Object.keys(attributes).forEach(attrName => {\n      if (attributes[attrName]) {\n        this.output += ` ${attrName}=\"${escapeXml(attributes[attrName])}\"`;\n      }\n    });\n\n    if (selfClosing) {\n      this.output += '/>';\n    } else {\n      this.output += '>';\n      this.elements.push(name);\n      this.incIndent();\n    }\n\n    if (preserveWhitespace !== undefined) {\n      this.preservingWhitespace = preserveWhitespace;\n    }\n    if (!this.preservingWhitespace) {\n      this.output += `\\n`;\n    }\n    return this;\n  }\n\n  endTag(name: string, { preserveWhitespace }: Options = {}): this {\n    const expectedTag = this.elements.pop();\n    if (expectedTag !== name) {\n      throw new Error(\n        `Unexpected closing tag: \"${name}\", expected: \"${expectedTag}\"`\n      );\n    }\n\n    this.decIndent();\n\n    if (!this.preservingWhitespace) {\n      this.output += this.indent;\n    }\n    this.output += `</${name}>`;\n\n    if (preserveWhitespace !== undefined) {\n      this.preservingWhitespace = preserveWhitespace;\n    }\n    if (!this.preservingWhitespace) {\n      this.output += `\\n`;\n    }\n    return this;\n  }\n\n  text(str: string): this {\n    this.output += escapeXml(str);\n    return this;\n  }\n\n  startPreserveWhitespace() {\n    this.preservingWhitespace = true;\n  }\n  stopPreserveWhitespace() {\n    this.preservingWhitespace = false;\n  }\n\n  private incIndent() {\n    this.indent = this.indent + '  ';\n  }\n  private decIndent() {\n    this.indent = this.indent.slice(0, -2);\n  }\n}\n\nconst _ESCAPED_CHARS: [RegExp, string][] = [\n  [/&/g, '&amp;'],\n  [/\"/g, '&quot;'],\n  [/'/g, '&apos;'],\n  [/</g, '&lt;'],\n  [/>/g, '&gt;']\n];\n\nfunction escapeXml(text: string): string {\n  return _ESCAPED_CHARS.reduce(\n    (t: string, entry: [RegExp, string]) => t.replace(entry[0], entry[1]),\n    text\n  );\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\nimport { TranslationSerializer } from './translation_serializer';\r\nimport { XmlFile } from './xml_file';\r\n\r\nexport class Xliff1TranslationSerializer implements TranslationSerializer {\r\n  renderFile(\r\n    messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n    locale: string,\r\n    isTarget = false\r\n  ): string {\r\n    const xml = new XmlFile();\r\n    xml.startTag('xliff', {\r\n      version: '1.2',\r\n      xmlns: 'urn:oasis:names:tc:xliff:document:1.2'\r\n    });\r\n    const fileAttrs = {\r\n      ['source-language']: isTarget ? undefined : locale,\r\n      ['target-language']: locale,\r\n      datatype: 'plaintext'\r\n    };\r\n    xml.startTag('file', fileAttrs);\r\n    xml.startTag('body');\r\n    messages.forEach(message => {\r\n      xml.startTag('trans-unit', {\r\n        id:\r\n          (message as ɵParsedMessage).id ||\r\n          (message as ParsedMessageLegacy).messageId,\r\n        datatype: 'html'\r\n      });\r\n      if (!isTarget) {\r\n        this.generateMessageTag(xml, 'source', message);\r\n      }\r\n      this.generateMessageTag(xml, 'target', message);\r\n      if (message.description) {\r\n        this.renderNote(xml, 'description', message.description);\r\n      }\r\n      if (message.meaning) {\r\n        this.renderNote(xml, 'meaning', message.meaning);\r\n      }\r\n      xml.endTag('trans-unit');\r\n    });\r\n    xml.endTag('body');\r\n    xml.endTag('file');\r\n    xml.endTag('xliff');\r\n    return xml.toString();\r\n  }\r\n\r\n  private generateMessageTag(\r\n    xml: XmlFile,\r\n    tagName: string,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ) {\r\n    xml.startTag(tagName, {}, { preserveWhitespace: true });\r\n    this.renderMessage(xml, message);\r\n    xml.endTag(tagName, { preserveWhitespace: false });\r\n  }\r\n\r\n  private renderMessage(\r\n    xml: XmlFile,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ): void {\r\n    xml.text(message.messageParts[0]);\r\n    for (let i = 1; i < message.messageParts.length; i++) {\r\n      xml.startTag(\r\n        'x',\r\n        { id: message.placeholderNames[i - 1] },\r\n        { selfClosing: true }\r\n      );\r\n      xml.text(message.messageParts[i]);\r\n    }\r\n  }\r\n\r\n  private renderNote(xml: XmlFile, name: string, value: string) {\r\n    xml.startTag(\r\n      'note',\r\n      { priority: '1', from: name },\r\n      { preserveWhitespace: true }\r\n    );\r\n    xml.text(value);\r\n    xml.endTag('note', { preserveWhitespace: false });\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\nimport { TranslationSerializer } from './translation_serializer';\r\nimport { XmlFile } from './xml_file';\r\n\r\nexport class Xliff2TranslationSerializer implements TranslationSerializer {\r\n  renderFile(\r\n    messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n    locale: string,\r\n    isTarget = false\r\n  ): string {\r\n    const xml = new XmlFile();\r\n    xml.startTag('xliff', {\r\n      version: '2.0',\r\n      xmlns: 'urn:oasis:names:tc:xliff:document:2.0',\r\n      srcLang: locale,\r\n      trgLang: locale\r\n    });\r\n    xml.startTag('file');\r\n    messages.forEach(message => {\r\n      xml.startTag('unit', {\r\n        id:\r\n          (message as ɵParsedMessage).id ||\r\n          (message as ParsedMessageLegacy).messageId\r\n      });\r\n      if (message.meaning || message.description) {\r\n        xml.startTag('notes');\r\n        if (message.description) {\r\n          this.renderNote(xml, 'description', message.description);\r\n        }\r\n        if (message.meaning) {\r\n          this.renderNote(xml, 'meaning', message.meaning);\r\n        }\r\n        xml.endTag('notes');\r\n      }\r\n      xml.startTag('segment');\r\n      if (!isTarget) {\r\n        this.generateMessageTag(xml, 'source', message);\r\n      }\r\n      this.generateMessageTag(xml, 'target', message);\r\n      xml.endTag('segment');\r\n      xml.endTag('unit');\r\n    });\r\n    xml.endTag('file');\r\n    xml.endTag('xliff');\r\n    return xml.toString();\r\n  }\r\n\r\n  private generateMessageTag(\r\n    xml: XmlFile,\r\n    tagName: string,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ) {\r\n    xml.startTag(tagName, {}, { preserveWhitespace: true });\r\n    this.renderMessage(xml, message);\r\n    xml.endTag(tagName, { preserveWhitespace: false });\r\n  }\r\n\r\n  private renderMessage(\r\n    xml: XmlFile,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ): void {\r\n    xml.text(message.messageParts[0]);\r\n    for (let i = 1; i < message.messageParts.length; i++) {\r\n      const placeholderName = message.placeholderNames[i - 1];\r\n      if (placeholderName.startsWith('START_')) {\r\n        xml.startTag('pc', {\r\n          id: `${i}`,\r\n          equivStart: placeholderName,\r\n          equivEnd: placeholderName.replace(/^START/, 'CLOSE')\r\n        });\r\n      } else if (placeholderName.startsWith('CLOSE_')) {\r\n        xml.endTag('pc');\r\n      } else {\r\n        xml.startTag(\r\n          'ph',\r\n          { id: `${i}`, equiv: placeholderName },\r\n          { selfClosing: true }\r\n        );\r\n      }\r\n      xml.text(message.messageParts[i]);\r\n    }\r\n  }\r\n\r\n  private renderNote(xml: XmlFile, name: string, value: string) {\r\n    xml.startTag('note', { category: name }, { preserveWhitespace: true });\r\n    xml.text(value);\r\n    xml.endTag('note', { preserveWhitespace: false });\r\n  }\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ɵParsedMessage } from '@angular/localize';\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\nimport { TranslationSerializer } from './translation_serializer';\nimport { XmlFile } from './xml_file';\n\nconst DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\nexport class XmbTranslationSerializer implements TranslationSerializer {\n  renderFile(messages: (ɵParsedMessage | ParsedMessageLegacy)[]): string {\n    const xml = new XmlFile();\n    xml.startTag('messagebundle');\n    messages.forEach(message => {\n      xml.startTag(\n        'msg',\n        {\n          id:\n            (message as ɵParsedMessage).id ||\n            (message as ParsedMessageLegacy).messageId,\n          desc: message.description,\n          meaning: message.meaning\n        },\n        { preserveWhitespace: true }\n      );\n      this.renderMessage(xml, message);\n      xml.endTag('msg', { preserveWhitespace: false });\n    });\n    xml.endTag('messagebundle');\n    return xml.toString();\n  }\n\n  private renderMessage(\n    xml: XmlFile,\n    message: ɵParsedMessage | ParsedMessageLegacy\n  ): void {\n    xml.text(message.messageParts[0]);\n    for (let i = 1; i < message.messageParts.length; i++) {\n      xml.startTag(\n        'ph',\n        { name: message.placeholderNames[i - 1] },\n        { selfClosing: true }\n      );\n      xml.text(message.messageParts[i]);\n    }\n  }\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\nimport { TranslationSerializer } from './translation_serializer';\r\nimport { XmlFile } from './xml_file';\r\n\r\nconst DOCTYPE = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE translationbundle [\r\n<!ELEMENT translationbundle (translation)*>\r\n<!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n\r\n<!ELEMENT translation (#PCDATA|ph)*>\r\n<!ATTLIST translation id CDATA #REQUIRED>\r\n<!ATTLIST translation desc CDATA #IMPLIED>\r\n<!ATTLIST translation meaning CDATA #IMPLIED>\r\n<!ATTLIST translation xml:space (default|preserve) \"default\">\r\n\r\n<!ELEMENT ph (#PCDATA|ex)*>\r\n<!ATTLIST ph name CDATA #REQUIRED>\r\n\r\n<!ELEMENT ex (#PCDATA)>\r\n]>\r\n`;\r\n\r\nexport class XtbTranslationSerializer implements TranslationSerializer {\r\n  renderFile(\r\n    messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n    locale: string\r\n  ): string {\r\n    const xml = new XmlFile();\r\n    xml.startTag('translationbundle', { lang: locale });\r\n    messages.forEach(message => {\r\n      xml.startTag(\r\n        'translation',\r\n        {\r\n          id:\r\n            (message as ɵParsedMessage).id ||\r\n            (message as ParsedMessageLegacy).messageId,\r\n          desc: message.description,\r\n          meaning: message.meaning\r\n        },\r\n        { preserveWhitespace: true }\r\n      );\r\n      this.renderMessage(xml, message);\r\n      xml.endTag('translation', { preserveWhitespace: false });\r\n    });\r\n    xml.endTag('translationbundle');\r\n    return DOCTYPE + xml.toString();\r\n  }\r\n\r\n  private renderMessage(\r\n    xml: XmlFile,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ): void {\r\n    xml.text(message.messageParts[0]);\r\n    for (let i = 1; i < message.messageParts.length; i++) {\r\n      xml.startTag(\r\n        'ph',\r\n        { name: message.placeholderNames[i - 1] },\r\n        { selfClosing: true }\r\n      );\r\n      xml.text(message.messageParts[i]);\r\n    }\r\n  }\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  ɵParsedTranslation,\n  ɵisMissingTranslationError,\n  ɵmakeTemplateObject,\n  ɵtranslate\n} from '@angular/localize';\nimport { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { ParsedTranslation } from '@angular/localize/src/utils';\nimport { Diagnostics } from '../common/diagnostics';\n\n/**\n * Is the given `expression` an identifier with the correct name\n * @param expression The expression to check.\n */\nexport function isNamedIdentifier(\n  expression: NodePath,\n  name: string\n): expression is NodePath {\n  return expression.isIdentifier() && expression.node.name === name;\n}\n\n/**\n * Is the given `identifier` declared globally.\n * @param identifier The identifier to check.\n */\nexport function isGlobalIdentifier(identifier: NodePath<t.Identifier>) {\n  return (\n    !identifier.scope || !identifier.scope.hasBinding(identifier.node.name)\n  );\n}\n\n/**\n * Build a translated expression to replace the call to `$localize`.\n * @param messageParts The static parts of the message.\n * @param substitutions The expressions to substitute into the message.\n */\nexport function buildLocalizeReplacement(\n  messageParts: TemplateStringsArray,\n  substitutions: readonly t.Expression[]\n): t.Expression {\n  let mappedString: t.Expression = t.stringLiteral(messageParts[0]);\n  for (let i = 1; i < messageParts.length; i++) {\n    mappedString = t.binaryExpression(\n      '+',\n      mappedString,\n      wrapInParensIfNecessary(substitutions[i - 1])\n    );\n    mappedString = t.binaryExpression(\n      '+',\n      mappedString,\n      t.stringLiteral(messageParts[i])\n    );\n  }\n  return mappedString;\n}\n\n/**\n * Extract the message parts from the given `call` (to `$localize`).\n *\n * The message parts will either by the first argument to the `call` or it will be wrapped in call\n * to a helper function like `__makeTemplateObject`.\n *\n * @param call The AST node of the call to process.\n */\nexport function unwrapMessagePartsFromLocalizeCall(\n  call: NodePath<t.CallExpression>\n): TemplateStringsArray {\n  let cooked = call.get('arguments')[0] as any;\n\n  if (cooked === undefined) {\n    throw new BabelParseError(\n      call.node,\n      '`$localize` called without any arguments.'\n    );\n  }\n  if (!cooked.isExpression()) {\n    throw new BabelParseError(\n      cooked.node,\n      'Unexpected argument to `$localize` (expected an array).'\n    );\n  }\n\n  // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.\n  let raw = cooked;\n\n  // Check for cached call of the form `x || x = __makeTemplateObject(...)`\n  if (\n    cooked.isLogicalExpression() &&\n    cooked.node.operator === '||' &&\n    cooked.get('left').isIdentifier()\n  ) {\n    const right = cooked.get('right');\n    if (right.isAssignmentExpression()) {\n      cooked = right.get('right');\n      if (!cooked.isExpression()) {\n        throw new BabelParseError(\n          cooked.node,\n          'Unexpected \"makeTemplateObject()\" function (expected an expression).'\n        );\n      }\n    }\n  }\n\n  // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.\n  if (cooked.isCallExpression()) {\n    let cookedCall = cooked;\n    if (cookedCall.get('arguments').length === 0) {\n      // No arguments so perhaps it is a `__templateObject()` call.\n      // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.\n      cookedCall = unwrapLazyLoadHelperCall(cookedCall);\n    }\n\n    cooked = cookedCall.get('arguments')[0];\n    if (!cooked.isExpression()) {\n      throw new BabelParseError(\n        cooked.node,\n        'Unexpected `cooked` argument to the \"makeTemplateObject()\" function (expected an expression).'\n      );\n    }\n    const arg2 = cookedCall.get('arguments')[1];\n    if (arg2 && !arg2.isExpression()) {\n      throw new BabelParseError(\n        arg2.node,\n        'Unexpected `raw` argument to the \"makeTemplateObject()\" function (expected an expression).'\n      );\n    }\n    // If there is no second argument then assume that raw and cooked are the same\n    raw = arg2 !== undefined ? arg2 : cooked;\n  }\n\n  const cookedStrings = unwrapStringLiteralArray(cooked.node);\n  const rawStrings = unwrapStringLiteralArray(raw.node);\n  return ɵmakeTemplateObject(cookedStrings, rawStrings);\n}\n\nexport function unwrapSubstitutionsFromLocalizeCall(\n  call: t.CallExpression\n): t.Expression[] {\n  const expressions = call.arguments.splice(1);\n  if (!isArrayOfExpressions(expressions)) {\n    const badExpression = expressions.find(\n      expression => !t.isExpression(expression)\n    )!;\n    throw new BabelParseError(\n      badExpression,\n      'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).'\n    );\n  }\n  return expressions;\n}\n\nexport function unwrapMessagePartsFromTemplateLiteral(\n  elements: t.TemplateElement[]\n): TemplateStringsArray {\n  const cooked = elements.map(q => {\n    if (q.value.cooked === undefined) {\n      throw new BabelParseError(\n        q,\n        `Unexpected undefined message part in \"${elements.map(\n          eq => eq.value.cooked\n        )}\"`\n      );\n    }\n    return q.value.cooked;\n  });\n  const raw = elements.map(q => q.value.raw);\n  return ɵmakeTemplateObject(cooked, raw);\n}\n\n/**\n * Wrap the given `expression` in parentheses if it is a binary expression.\n *\n * This ensures that this expression is evaluated correctly if it is embedded in another expression.\n *\n * @param expression The expression to potentially wrap.\n */\nexport function wrapInParensIfNecessary(\n  expression: t.Expression\n): t.Expression {\n  if (t.isBinaryExpression(expression)) {\n    return t.parenthesizedExpression(expression);\n  } else {\n    return expression;\n  }\n}\n\n/**\n * Extract the string values from an `array` of string literals.\n * @param array The array to unwrap.\n */\nexport function unwrapStringLiteralArray(array: t.Expression): string[] {\n  if (!isStringLiteralArray(array)) {\n    throw new BabelParseError(\n      array,\n      'Unexpected messageParts for `$localize` (expected an array of strings).'\n    );\n  }\n  return array.elements.map((str: t.StringLiteral) => str.value);\n}\n\n/**\n * This expression is believed to be a call to a \"lazy-load\" template object helper function.\n * This is expected to be of the form:\n *\n * ```ts\n *  function _templateObject() {\n *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);\n *    return _templateObject = function() { return e }, e\n *  }\n * ```\n *\n * We unwrap this to return the call to `_taggedTemplateLiteral()`.\n *\n * @param call the call expression to unwrap\n * @returns the  call expression\n */\nexport function unwrapLazyLoadHelperCall(\n  call: NodePath<t.CallExpression>\n): NodePath<t.CallExpression> {\n  const callee = call.get('callee') as any;\n  if (!callee.isIdentifier()) {\n    throw new BabelParseError(\n      callee.node,\n      'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).'\n    );\n  }\n  const lazyLoadBinding = call.scope.getBinding(callee.node.name);\n  if (!lazyLoadBinding) {\n    throw new BabelParseError(\n      callee.node,\n      'Missing declaration for lazy-load helper function'\n    );\n  }\n  const lazyLoadFn = lazyLoadBinding.path;\n  if (!lazyLoadFn.isFunctionDeclaration()) {\n    throw new BabelParseError(\n      (lazyLoadFn as any).node,\n      'Unexpected expression (expected a function declaration'\n    );\n  }\n  const returnedNode = getReturnedExpression(lazyLoadFn);\n\n  if (returnedNode.isCallExpression()) {\n    return returnedNode;\n  }\n\n  if (returnedNode.isIdentifier()) {\n    const identifierName = returnedNode.node.name;\n    const declaration = returnedNode.scope.getBinding(identifierName);\n    if (declaration === undefined) {\n      throw new BabelParseError(\n        returnedNode.node,\n        'Missing declaration for return value from helper.'\n      );\n    }\n    if (!declaration.path.isVariableDeclarator()) {\n      throw new BabelParseError(\n        (declaration as any).path.node,\n        'Unexpected helper return value declaration (expected a variable declaration).'\n      );\n    }\n    const initializer = declaration.path.get('init');\n    if (!initializer.isCallExpression()) {\n      throw new BabelParseError(\n        declaration.path.node,\n        'Unexpected return value from helper (expected a call expression).'\n      );\n    }\n\n    // Remove the lazy load helper if this is the only reference to it.\n    if (lazyLoadBinding.references === 1) {\n      lazyLoadFn.remove();\n    }\n\n    return initializer;\n  }\n  return call;\n}\n\nfunction getReturnedExpression(\n  fn: NodePath<t.FunctionDeclaration>\n): NodePath<t.Expression> {\n  const bodyStatements = (fn.get('body') as any).get('body');\n  for (const statement of bodyStatements) {\n    if (statement.isReturnStatement()) {\n      const argument = statement.get('argument');\n      if (argument.isSequenceExpression()) {\n        const expressions = argument.get('expressions');\n        return Array.isArray(expressions)\n          ? expressions[expressions.length - 1]\n          : expressions;\n      } else if (argument.isExpression()) {\n        return argument;\n      } else {\n        throw new BabelParseError(\n          statement.node,\n          'Invalid return argument in helper function (expected an expression).'\n        );\n      }\n    }\n  }\n  throw new BabelParseError(\n    fn.node,\n    'Missing return statement in helper function.'\n  );\n}\n\n/**\n * Is the given `node` an array of literal strings?\n *\n * @param node The node to test.\n */\nexport function isStringLiteralArray(\n  node: t.Node\n): node is t.Expression & { elements: t.StringLiteral[] } {\n  return (\n    t.isArrayExpression(node) &&\n    node.elements.every(element => t.isStringLiteral(element))\n  );\n}\n\n/**\n * Are all the given `nodes` expressions?\n * @param nodes The nodes to test.\n */\nexport function isArrayOfExpressions(nodes: t.Node[]): nodes is t.Expression[] {\n  return nodes.every(element => t.isExpression(element));\n}\n\n/** Options that affect how the `makeEsXXXTranslatePlugin()` functions work. */\nexport interface TranslatePluginOptions {\n  missingTranslation?: MissingTranslationStrategy;\n  localizeName?: string;\n}\n\n/**\n * How to handle missing translations.\n */\nexport type MissingTranslationStrategy = 'error' | 'warning' | 'ignore';\n\n/**\n * Translate the text of the given message, using the given translations.\n *\n * Logs as warning if the translation is not available\n */\nexport function translate(\n  diagnostics: Diagnostics,\n  translations: Record<string, ɵParsedTranslation>,\n  messageParts: TemplateStringsArray,\n  substitutions: readonly any[],\n  missingTranslation: MissingTranslationStrategy\n): [TemplateStringsArray, readonly any[]] {\n  try {\n    return ɵtranslate(translations, messageParts, substitutions);\n  } catch (e) {\n    if (ɵisMissingTranslationError(e)) {\n      if (missingTranslation === 'error') {\n        diagnostics.error(e.message);\n      } else if (missingTranslation === 'warning') {\n        diagnostics.warn(e.message);\n      }\n      // Return the parsed message because this will have the meta blocks stripped\n      return [\n        ɵmakeTemplateObject(\n          e.parsedMessage.messageParts,\n          e.parsedMessage.messageParts\n        ),\n        substitutions\n      ];\n    } else {\n      diagnostics.error(e.message);\n      return [messageParts, substitutions];\n    }\n  }\n}\n\nexport class BabelParseError extends Error {\n  private readonly type = 'BabelParseError';\n  constructor(public node: t.Node, message: string) {\n    super(message);\n  }\n}\n\nexport function isBabelParseError(e: any): e is BabelParseError {\n  return e.type === 'BabelParseError';\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage, ɵparseMessage } from '@angular/localize';\r\nimport { NodePath, PluginObj } from '@babel/core';\r\nimport { TaggedTemplateExpression } from '@babel/types';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\n\r\nimport {\r\n  isGlobalIdentifier,\r\n  isNamedIdentifier,\r\n  unwrapMessagePartsFromTemplateLiteral\r\n} from '../source_file_utils';\r\nimport { Diagnostics } from '../../common/diagnostics';\r\n\r\nexport function makeEs2015ExtractPlugin(\r\n  messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n  diagnostics: Diagnostics,\r\n  localizeName = '$localize'\r\n): PluginObj {\r\n  return {\r\n    visitor: {\r\n      TaggedTemplateExpression(path: NodePath<TaggedTemplateExpression>) {\r\n        const tag = path.get('tag');\r\n        if (isNamedIdentifier(tag, localizeName) && isGlobalIdentifier(tag)) {\r\n          const messageParts = unwrapMessagePartsFromTemplateLiteral(\r\n            path.node.quasi.quasis\r\n          );\r\n          const message: ɵParsedMessage | ParsedMessageLegacy = ɵparseMessage(\r\n            messageParts,\r\n            path.node.quasi.expressions\r\n          );\r\n          if (\r\n            !messages.find((msg: any) =>\r\n              message.id\r\n                ? msg.id === message.id\r\n                : msg.messageId ===\r\n                  ((<unknown>message) as ParsedMessageLegacy).messageId\r\n            )\r\n          ) {\r\n            messages.push(message);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { transformSync } from '@babel/core';\r\n\r\nimport { makeEs2015ExtractPlugin } from './source_files/es2015_extract_plugin';\r\nimport { makeEs5ExtractPlugin } from './source_files/es5_extract_plugin';\r\nimport { Diagnostics } from '../common/diagnostics';\r\n\r\n/**\r\n * A class that extracts parsed messages from file contents, by parsing the contents as JavaScript\r\n * and looking for occurrences of `$localize` in the source code.\r\n */\r\nexport class Extractor {\r\n  messages: ɵParsedMessage[] = [];\r\n\r\n  constructor(private diagnostics: Diagnostics) {}\r\n\r\n  extractMessages(sourceCode: string): void {\r\n    if (sourceCode.includes('$localize')) {\r\n      // Only bother to parse the file if it contains a reference to `$localize`.\r\n      transformSync(sourceCode, {\r\n        plugins: [\r\n          makeEs2015ExtractPlugin(this.messages, this.diagnostics),\r\n          makeEs5ExtractPlugin(this.messages, this.diagnostics)\r\n        ],\r\n        code: false,\r\n        ast: false\r\n      });\r\n    }\r\n  }\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ɵParsedMessage, ɵparseMessage } from '@angular/localize';\nimport { NodePath, PluginObj } from '@babel/core';\nimport { CallExpression } from '@babel/types';\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\n\nimport {\n  isGlobalIdentifier,\n  isNamedIdentifier,\n  unwrapMessagePartsFromLocalizeCall,\n  unwrapSubstitutionsFromLocalizeCall\n} from '../source_file_utils';\nimport { Diagnostics } from '../../common/diagnostics';\n\nexport function makeEs5ExtractPlugin(\n  messages: (ɵParsedMessage | ParsedMessageLegacy)[],\n  diagnostics: Diagnostics,\n  localizeName = '$localize'\n): PluginObj {\n  return {\n    visitor: {\n      CallExpression(callPath: NodePath<CallExpression>) {\n        const calleePath = callPath.get('callee');\n        if (\n          isNamedIdentifier(calleePath, localizeName) &&\n          isGlobalIdentifier(calleePath)\n        ) {\n          const messageParts = unwrapMessagePartsFromLocalizeCall(callPath);\n          const expressions = unwrapSubstitutionsFromLocalizeCall(\n            callPath.node\n          );\n          const message: ɵParsedMessage | ParsedMessageLegacy = ɵparseMessage(\n            messageParts,\n            expressions\n          );\n          if (\n            !messages.find((msg: any) =>\n              message.id\n                ? msg.id === message.id\n                : msg.messageId ===\n                  ((<unknown>message) as ParsedMessageLegacy).messageId\n            )\n          ) {\n            messages.push(message);\n          }\n        }\n      }\n    }\n  };\n}\n","import { readFileSync, statSync } from 'fs';\r\nimport { sync } from 'glob';\r\nimport { basename, extname, posix, resolve } from 'path';\r\nimport { Diagnostics } from './common/diagnostics';\r\nimport { FileUtils } from './common/file_utils';\r\nimport {\r\n  getExtension,\r\n  getTranslationSerializer,\r\n  TranslationFormat\r\n} from './common/util';\r\nimport { Extractor } from './extract/extractor';\r\n\r\nexport const command = 'extract';\r\nexport const describe = 'Extract translations from your ivy application';\r\nexport const builder = {\r\n  s: {\r\n    alias: 'source',\r\n    required: true,\r\n    describe:\r\n      'A glob pattern indicating what files to search for translations, e.g. `./dist/**/*.js`. This can be absolute or relative to the current working directory.'\r\n  },\r\n  f: {\r\n    alias: 'format',\r\n    required: true,\r\n    describe: 'The format of the translation files to generate.',\r\n    choices: ['json', 'xlf', 'xmb', 'xlf2'],\r\n    default: 'json'\r\n  },\r\n  o: {\r\n    alias: 'outputPath',\r\n    required: true,\r\n    describe:\r\n      'A path to where the translation file will be written. This can be absolute or relative to the current working directory.'\r\n  },\r\n  l: {\r\n    alias: ['locale', 'locales'],\r\n    required: false,\r\n    type: 'array',\r\n    describe:\r\n      'The locale for the extracted file, \"en\" by default. If you use multiple locales (e.g. \"en fr es\"), a new file will be generated for each locale'\r\n  }\r\n};\r\n\r\nexport const handler = function(options) {\r\n  const diagnostics = new Diagnostics();\r\n  extractTranslations({\r\n    sourceGlob: options['s'] as string,\r\n    format: options['f'] as TranslationFormat,\r\n    outputPath: options['o'] as string,\r\n    locales: options['l'] as string[],\r\n    diagnostics\r\n  });\r\n  diagnostics.logMessages();\r\n  process.exit(diagnostics.hasErrors ? 1 : 0);\r\n};\r\n\r\nexport interface ExtractTranslationsOptions {\r\n  sourceGlob: string;\r\n  format: TranslationFormat;\r\n  outputPath: string;\r\n  locales?: string[];\r\n  diagnostics: Diagnostics;\r\n}\r\n\r\nexport function extractTranslations({\r\n  sourceGlob: source,\r\n  format,\r\n  outputPath: output,\r\n  locales = ['en'],\r\n  diagnostics\r\n}: ExtractTranslationsOptions) {\r\n  console.log(`Extracting translations from \"${source}\"`);\r\n  let filesToProcess = sync(resolve(source), {\r\n    absolute: true,\r\n    nodir: true\r\n  });\r\n  filesToProcess = FileUtils.dedup(filesToProcess, /\\-es(5|2015)\\./, '.');\r\n  output = resolve(output);\r\n  const generatedFiles: string[] = [];\r\n  let isFile: boolean;\r\n  try {\r\n    const stat = statSync(output);\r\n    isFile = stat.isFile();\r\n  } catch (e) {\r\n    isFile = !!extname(output);\r\n  }\r\n  if (isFile) {\r\n    if (locales.length > 1) {\r\n      diagnostics.error(\r\n        `Multiple locales detected (\"${locales.join(\r\n          ','\r\n        )}\") but output \"${output}\" is not a directory`\r\n      );\r\n      return;\r\n    }\r\n    const res = makeTranslationsFile(\r\n      filesToProcess,\r\n      posix.normalize(output),\r\n      source,\r\n      format,\r\n      locales[0],\r\n      diagnostics\r\n    );\r\n    if (res) {\r\n      generatedFiles.push(res);\r\n    }\r\n  } else {\r\n    filesToProcess.forEach(file => {\r\n      locales.forEach(locale => {\r\n        const newFileName = posix.join(\r\n          output,\r\n          basename(file, '.js').replace(/-es(5|2015)/, '') +\r\n            '.' +\r\n            locale +\r\n            '.' +\r\n            getExtension(format)\r\n        );\r\n        const res = makeTranslationsFile(\r\n          [file],\r\n          newFileName,\r\n          source,\r\n          format,\r\n          locale,\r\n          diagnostics\r\n        );\r\n        if (res) {\r\n          generatedFiles.push(res);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  if (!generatedFiles.length) {\r\n    diagnostics.error(\r\n      `No messages found. You should build the angular app without a language target for this command to work.`\r\n    );\r\n    return;\r\n  }\r\n}\r\n\r\nfunction makeTranslationsFile(\r\n  filesToProcess: string[],\r\n  fileOutput: string,\r\n  source: string,\r\n  format: TranslationFormat,\r\n  locale: string,\r\n  diagnostics: Diagnostics\r\n): string | null {\r\n  const extractor = new Extractor(diagnostics);\r\n  filesToProcess.forEach(file => {\r\n    const contents = readFileSync(file, 'utf8');\r\n    extractor.extractMessages(contents);\r\n  });\r\n\r\n  const serializer = getTranslationSerializer(format);\r\n  if (extractor.messages.length > 0) {\r\n    const translationFile = serializer.renderFile(\r\n      extractor.messages,\r\n      locale,\r\n      false\r\n    );\r\n    FileUtils.writeFile(fileOutput, translationFile);\r\n    console.log(`  Generated file \"${fileOutput}\"`);\r\n    return fileOutput;\r\n  }\r\n  return null;\r\n}\r\n","import { JsonTranslationSerializer } from '../extract/translation_files/json_translation_serializer';\r\nimport { TranslationSerializer } from '../extract/translation_files/translation_serializer';\r\nimport { Xliff1TranslationSerializer } from '../extract/translation_files/xliff1_translation_serializer';\r\nimport { Xliff2TranslationSerializer } from '../extract/translation_files/xliff2_translation_serializer';\r\nimport { XmbTranslationSerializer } from '../extract/translation_files/xmb_translation_serializer';\r\nimport { ɵMessageId, ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedTranslation } from '../convert/translations';\r\nimport { XtbTranslationSerializer } from '../extract/translation_files/xtb_translation_serializer';\r\n\r\nexport type TranslationFormat =\r\n  | 'json'\r\n  | 'xmb'\r\n  | 'xliff1'\r\n  | 'xliff2'\r\n  | 'xlf'\r\n  | 'xlf2'\r\n  | 'xtb';\r\n\r\nexport function getTranslationSerializer(\r\n  format: TranslationFormat\r\n): TranslationSerializer {\r\n  switch (format) {\r\n    case 'json':\r\n      return new JsonTranslationSerializer();\r\n    case 'xliff1':\r\n    case 'xlf':\r\n      return new Xliff1TranslationSerializer();\r\n    case 'xliff2':\r\n    case 'xlf2':\r\n      return new Xliff2TranslationSerializer();\r\n    case 'xmb':\r\n      return new XmbTranslationSerializer();\r\n    case 'xtb':\r\n      return new XtbTranslationSerializer();\r\n  }\r\n}\r\n\r\nexport function getExtension(format: TranslationFormat): string {\r\n  switch (format) {\r\n    case 'json':\r\n    case 'xmb':\r\n    case 'xtb':\r\n      return format;\r\n    default:\r\n      return 'xlf';\r\n  }\r\n}\r\n\r\n/**\r\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\r\n * A block can indicate metadata about the message or specify a name of a placeholder for a\r\n * substitution expressions.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize`Hello, ${title}:title:!`;\r\n * $localize`:meaning|description@@id:source message text`;\r\n * ```\r\n */\r\nexport const BLOCK_MARKER = ':';\r\n\r\n/**\r\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\r\n *\r\n * @param cooked The cooked string (where escaped chars have been processed)\r\n * @param raw The raw string (where escape sequences are still in place)\r\n *\r\n * @returns the index of the end of block marker\r\n * @throws an error if the block is unterminated\r\n */\r\nexport function findEndOfBlock(cooked: string, raw: string): number {\r\n  /************************************************************************************************\r\n   * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.\r\n   * (See that file for more explanation of why.)\r\n   ************************************************************************************************/\r\n  for (\r\n    let cookedIndex = 1, rawIndex = 1;\r\n    cookedIndex < cooked.length;\r\n    cookedIndex++, rawIndex++\r\n  ) {\r\n    if (raw[rawIndex] === '\\\\') {\r\n      rawIndex++;\r\n    } else if (cooked[cookedIndex] === BLOCK_MARKER) {\r\n      return cookedIndex;\r\n    }\r\n  }\r\n  throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\r\n}\r\n\r\n/**\r\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\r\n * rest of the text of the message part.\r\n *\r\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\r\n * start and end of the block.\r\n *\r\n * If the block is in the first message part then it will be metadata about the whole message:\r\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\r\n * substitution: placeholder name.\r\n *\r\n * Since blocks are optional, it is possible that the content of a message block actually starts\r\n * with a block marker. In this case the marker must be escaped `\\:`.\r\n *\r\n * @param cooked The cooked version of the message part to parse.\r\n * @param raw The raw version of the message part to parse.\r\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\r\n * exists.\r\n * @throws an error if the `block` is unterminated\r\n */\r\nexport function splitBlock(\r\n  cooked: string,\r\n  raw: string\r\n): { text: string; block?: string } {\r\n  if (raw.charAt(0) !== BLOCK_MARKER) {\r\n    return { text: cooked };\r\n  } else {\r\n    const endOfBlock = findEndOfBlock(cooked, raw);\r\n    return {\r\n      block: cooked.substring(1, endOfBlock),\r\n      text: cooked.substring(endOfBlock + 1)\r\n    };\r\n  }\r\n}\r\n\r\nfunction computePlaceholderName(index: number) {\r\n  return index === 1 ? 'PH' : `PH_${index - 1}`;\r\n}\r\n\r\nexport function translationToMessage(\r\n  id: string,\r\n  translation: ParsedTranslation\r\n): ɵParsedMessage {\r\n  const messageParts = translation.messageParts;\r\n  const legacyIds = [];\r\n  const cleanedMessageParts: string[] = [messageParts[0]];\r\n  const substitutions: { [placeholderName: string]: any } = {};\r\n  const placeholderNames: string[] = [];\r\n  let text = messageParts[0];\r\n\r\n  for (let i = 1; i < messageParts.length; i++) {\r\n    const {\r\n      text: messagePart,\r\n      block: placeholderName = translation.placeholderNames[i - 1] ||\r\n        computePlaceholderName(i)\r\n    } = splitBlock(messageParts[i], messageParts.raw[i]);\r\n    text += `{$${placeholderName}}${messagePart}`;\r\n    if (translation.placeholderNames.length) {\r\n      substitutions[placeholderName] = translation.placeholderNames[i - 1];\r\n    }\r\n    placeholderNames.push(placeholderName);\r\n    cleanedMessageParts.push(messagePart);\r\n  }\r\n\r\n  return {\r\n    id,\r\n    legacyIds,\r\n    substitutions,\r\n    text,\r\n    meaning: translation.meaning || '',\r\n    description: translation.description || '',\r\n    messageParts: cleanedMessageParts,\r\n    placeholderNames\r\n  };\r\n}\r\n\r\nexport interface ParsedMessageLegacy {\r\n  /**\r\n   * The key used to look up the appropriate translation target.\r\n   */\r\n  messageId: ɵMessageId;\r\n  /**\r\n   * Legacy message ids, if provided.\r\n   *\r\n   * In legacy message formats the message id can only be computed directly from the original\r\n   * template source.\r\n   *\r\n   * Since this information is not available in `$localize` calls, the legacy message ids may be\r\n   * attached by the compiler to the `$localize` metablock so it can be used if needed at the point\r\n   * of translation if the translations are encoded using the legacy message id.\r\n   */\r\n  legacyIds: ɵMessageId[];\r\n  /**\r\n   * A mapping of placeholder names to substitution values.\r\n   */\r\n  substitutions: Record<string, any>;\r\n  /**\r\n   * A human readable rendering of the message\r\n   */\r\n  messageString: string;\r\n  /**\r\n   * The meaning of the `message`, used to distinguish identical `messageString`s.\r\n   */\r\n  meaning: string;\r\n  /**\r\n   * The description of the `message`, used to aid translation.\r\n   */\r\n  description: string;\r\n  /**\r\n   * The static parts of the message.\r\n   */\r\n  messageParts: string[];\r\n  /**\r\n   * The names of the placeholders that will be replaced with substitutions.\r\n   */\r\n  placeholderNames: string[];\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as yargs from 'yargs';\nimport * as findUp from 'find-up';\nimport * as fs from 'fs';\nconst configPath = findUp.sync(['.loclrc', '.locl.json']);\nconst config = configPath\n  ? JSON.parse(fs.readFileSync(configPath, { encoding: 'utf8' }))\n  : {};\n\nconst args = process.argv.slice(2);\nyargs\n  .config(config)\n  .commandDir('cmds')\n  .demandCommand()\n  .help()\n  .version(false)\n  .parse(args);\n"]}