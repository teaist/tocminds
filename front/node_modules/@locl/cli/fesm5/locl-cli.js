import { NgModule } from '@angular/core';
import { readFileSync, writeFileSync, existsSync, mkdirSync, statSync, unlinkSync, readdirSync, rmdirSync } from 'fs';
import { sync } from 'glob';
import { dirname, resolve, extname, posix, basename } from 'path';
import { blue, red, yellow } from 'chalk';
import { transformSync } from '@babel/core';
import { ɵmakeTemplateObject, ɵtranslate, ɵisMissingTranslationError, ɵparseMessage } from '@angular/localize';
import { __values, __extends } from 'tslib';
import { stringLiteral, binaryExpression, isExpression, isBinaryExpression, parenthesizedExpression, isArrayExpression, isStringLiteral } from '@babel/types';
import { config as config$1 } from 'yargs';
import { sync as sync$1 } from 'find-up';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cli.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// not used, only there to make ng-packagr happy
var CliModule = /** @class */ (function () {
    function CliModule() {
    }
    CliModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [],
                    exports: []
                },] }
    ];
    return CliModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/common/diagnostics.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This class is used to collect and then report warnings and errors that occur during the execution
 * of the tools.
 */
var /**
 * This class is used to collect and then report warnings and errors that occur during the execution
 * of the tools.
 */
Diagnostics = /** @class */ (function () {
    function Diagnostics() {
        this.messages = [];
    }
    Object.defineProperty(Diagnostics.prototype, "hasErrors", {
        get: /**
         * @return {?}
         */
        function () {
            return this.messages.some((/**
             * @param {?} m
             * @return {?}
             */
            function (m) { return m.type === 'error'; }));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} message
     * @return {?}
     */
    Diagnostics.prototype.log = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        this.messages.push({ type: '', message: message });
    };
    /**
     * @param {?} message
     * @return {?}
     */
    Diagnostics.prototype.warn = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        this.messages.push({ type: 'warning', message: message });
    };
    /**
     * @param {?} message
     * @return {?}
     */
    Diagnostics.prototype.error = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        this.messages.push({ type: 'error', message: message });
    };
    /**
     * @param {?} message
     * @return {?}
     */
    Diagnostics.prototype.formatDiagnostics = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        /** @type {?} */
        var errors = (/** @type {?} */ (this.messages)).filter((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.type === 'error'; })).map((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return ' - ' + d.message; }));
        /** @type {?} */
        var warnings = (/** @type {?} */ (this.messages)).filter((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.type === 'warning'; })).map((/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return ' - ' + d.message; }));
        if (errors.length) {
            message += '\nERRORS:\n' + errors.join('\n');
        }
        if (warnings.length) {
            message += '\nWARNINGS:\n' + warnings.join('\n');
        }
        return message;
    };
    /**
     * @return {?}
     */
    Diagnostics.prototype.logMessages = /**
     * @return {?}
     */
    function () {
        while (this.messages.length) {
            /** @type {?} */
            var m = this.messages.shift();
            switch (m.type) {
                case 'warning':
                    console.warn(yellow("Warning: " + m.message));
                    break;
                case 'error':
                    console.error(red("Error: " + m.message));
                    break;
                default:
                    console.log(blue("" + m.message));
            }
        }
    };
    return Diagnostics;
}());
if (false) {
    /** @type {?} */
    Diagnostics.prototype.messages;
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/common/file_utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FileUtils = /** @class */ (function () {
    function FileUtils() {
    }
    /**
     * @param {?} absolutePath
     * @return {?}
     */
    FileUtils.readFile = /**
     * @param {?} absolutePath
     * @return {?}
     */
    function (absolutePath) {
        return readFileSync(absolutePath, 'utf8');
    };
    /**
     * @param {?} absolutePath
     * @return {?}
     */
    FileUtils.readFileBuffer = /**
     * @param {?} absolutePath
     * @return {?}
     */
    function (absolutePath) {
        return readFileSync(absolutePath);
    };
    /**
     * @param {?} absolutePath
     * @param {?} contents
     * @return {?}
     */
    FileUtils.writeFile = /**
     * @param {?} absolutePath
     * @param {?} contents
     * @return {?}
     */
    function (absolutePath, contents) {
        FileUtils.ensureDir(dirname(absolutePath));
        writeFileSync(absolutePath, contents);
    };
    /**
     * @param {?} absolutePath
     * @return {?}
     */
    FileUtils.ensureDir = /**
     * @param {?} absolutePath
     * @return {?}
     */
    function (absolutePath) {
        /** @type {?} */
        var parents = [];
        while (!FileUtils.isRoot(absolutePath) && !existsSync(absolutePath)) {
            parents.push(absolutePath);
            absolutePath = dirname(absolutePath);
        }
        while (parents.length) {
            mkdirSync((/** @type {?} */ (parents.pop())));
        }
    };
    /**
     * @param {?} p
     * @return {?}
     */
    FileUtils.remove = /**
     * @param {?} p
     * @return {?}
     */
    function (p) {
        /** @type {?} */
        var stat = statSync(p);
        if (stat.isFile()) {
            unlinkSync(p);
        }
        else if (stat.isDirectory()) {
            readdirSync(p).forEach((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                /** @type {?} */
                var absChild = resolve(p, child);
                FileUtils.remove(absChild);
            }));
            rmdirSync(p);
        }
    };
    /**
     * @param {?} absolutePath
     * @return {?}
     */
    FileUtils.isRoot = /**
     * @param {?} absolutePath
     * @return {?}
     */
    function (absolutePath) {
        return dirname(absolutePath) === absolutePath;
    };
    /**
     * @param {?} files
     * @param {?} pattern
     * @param {?=} replaceValue
     * @return {?}
     */
    FileUtils.dedup = /**
     * @param {?} files
     * @param {?} pattern
     * @param {?=} replaceValue
     * @return {?}
     */
    function (files, pattern, replaceValue) {
        if (replaceValue === void 0) { replaceValue = ''; }
        /** @type {?} */
        var filesSet = files.map((/**
         * @param {?} file
         * @return {?}
         */
        function (file) { return file.replace(pattern, replaceValue); }));
        /** @type {?} */
        var dedup = [];
        /** @type {?} */
        var indexes = [];
        filesSet.forEach((/**
         * @param {?} file
         * @param {?} index
         * @return {?}
         */
        function (file, index) {
            if (dedup.indexOf(file) === -1) {
                dedup.push(file);
                indexes.push(index);
            }
        }));
        return indexes.map((/**
         * @param {?} index
         * @return {?}
         */
        function (index) { return files[index]; }));
    };
    return FileUtils;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/json_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function SimpleJsonTranslationFile() { }
if (false) {
    /** @type {?} */
    SimpleJsonTranslationFile.prototype.locale;
    /** @type {?} */
    SimpleJsonTranslationFile.prototype.translations;
}
var JsonTranslationSerializer = /** @class */ (function () {
    function JsonTranslationSerializer() {
    }
    /**
     * @param {?} messages
     * @param {?} locale
     * @return {?}
     */
    JsonTranslationSerializer.prototype.renderFile = /**
     * @param {?} messages
     * @param {?} locale
     * @return {?}
     */
    function (messages, locale) {
        /** @type {?} */
        var fileObj = {
            locale: locale,
            translations: {}
        };
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            fileObj.translations[((/** @type {?} */ (message))).id ||
                ((/** @type {?} */ (message))).messageId] =
                ((/** @type {?} */ (message))).text ||
                    ((/** @type {?} */ (message))).messageString;
        }));
        return JSON.stringify(fileObj, null, 2);
    };
    return JsonTranslationSerializer;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xml_file.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @record
 */
function Options() { }
if (false) {
    /** @type {?|undefined} */
    Options.prototype.selfClosing;
    /** @type {?|undefined} */
    Options.prototype.preserveWhitespace;
}
var XmlFile = /** @class */ (function () {
    function XmlFile() {
        this.output = '';
        this.indent = '';
        this.elements = [];
        this.preservingWhitespace = false;
    }
    /**
     * @return {?}
     */
    XmlFile.prototype.toString = /**
     * @return {?}
     */
    function () {
        return this.output;
    };
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @param {?=} attributes
     * @param {?=} __2
     * @return {THIS}
     */
    XmlFile.prototype.startTag = /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @param {?=} attributes
     * @param {?=} __2
     * @return {THIS}
     */
    function (name, attributes, _a) {
        var _this = this;
        if (attributes === void 0) { attributes = {}; }
        var _b = _a === void 0 ? {} : _a, _c = _b.selfClosing, selfClosing = _c === void 0 ? false : _c, preserveWhitespace = _b.preserveWhitespace;
        if (!(/** @type {?} */ (this)).preservingWhitespace) {
            (/** @type {?} */ (this)).output += (/** @type {?} */ (this)).indent;
        }
        (/** @type {?} */ (this)).output += "<" + name;
        Object.keys(attributes).forEach((/**
         * @param {?} attrName
         * @return {?}
         */
        function (attrName) {
            if (attributes[attrName]) {
                (/** @type {?} */ (_this)).output += " " + attrName + "=\"" + escapeXml(attributes[attrName]) + "\"";
            }
        }));
        if (selfClosing) {
            (/** @type {?} */ (this)).output += '/>';
        }
        else {
            (/** @type {?} */ (this)).output += '>';
            (/** @type {?} */ (this)).elements.push(name);
            (/** @type {?} */ (this)).incIndent();
        }
        if (preserveWhitespace !== undefined) {
            (/** @type {?} */ (this)).preservingWhitespace = preserveWhitespace;
        }
        if (!(/** @type {?} */ (this)).preservingWhitespace) {
            (/** @type {?} */ (this)).output += "\n";
        }
        return (/** @type {?} */ (this));
    };
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @param {?=} __1
     * @return {THIS}
     */
    XmlFile.prototype.endTag = /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @param {?=} __1
     * @return {THIS}
     */
    function (name, _a) {
        var preserveWhitespace = (_a === void 0 ? {} : _a).preserveWhitespace;
        /** @type {?} */
        var expectedTag = (/** @type {?} */ (this)).elements.pop();
        if (expectedTag !== name) {
            throw new Error("Unexpected closing tag: \"" + name + "\", expected: \"" + expectedTag + "\"");
        }
        (/** @type {?} */ (this)).decIndent();
        if (!(/** @type {?} */ (this)).preservingWhitespace) {
            (/** @type {?} */ (this)).output += (/** @type {?} */ (this)).indent;
        }
        (/** @type {?} */ (this)).output += "</" + name + ">";
        if (preserveWhitespace !== undefined) {
            (/** @type {?} */ (this)).preservingWhitespace = preserveWhitespace;
        }
        if (!(/** @type {?} */ (this)).preservingWhitespace) {
            (/** @type {?} */ (this)).output += "\n";
        }
        return (/** @type {?} */ (this));
    };
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} str
     * @return {THIS}
     */
    XmlFile.prototype.text = /**
     * @template THIS
     * @this {THIS}
     * @param {?} str
     * @return {THIS}
     */
    function (str) {
        (/** @type {?} */ (this)).output += escapeXml(str);
        return (/** @type {?} */ (this));
    };
    /**
     * @return {?}
     */
    XmlFile.prototype.startPreserveWhitespace = /**
     * @return {?}
     */
    function () {
        this.preservingWhitespace = true;
    };
    /**
     * @return {?}
     */
    XmlFile.prototype.stopPreserveWhitespace = /**
     * @return {?}
     */
    function () {
        this.preservingWhitespace = false;
    };
    /**
     * @private
     * @return {?}
     */
    XmlFile.prototype.incIndent = /**
     * @private
     * @return {?}
     */
    function () {
        this.indent = this.indent + '  ';
    };
    /**
     * @private
     * @return {?}
     */
    XmlFile.prototype.decIndent = /**
     * @private
     * @return {?}
     */
    function () {
        this.indent = this.indent.slice(0, -2);
    };
    return XmlFile;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    XmlFile.prototype.output;
    /**
     * @type {?}
     * @private
     */
    XmlFile.prototype.indent;
    /**
     * @type {?}
     * @private
     */
    XmlFile.prototype.elements;
    /**
     * @type {?}
     * @private
     */
    XmlFile.prototype.preservingWhitespace;
}
/** @type {?} */
var _ESCAPED_CHARS = [
    [/&/g, '&amp;'],
    [/"/g, '&quot;'],
    [/'/g, '&apos;'],
    [/</g, '&lt;'],
    [/>/g, '&gt;']
];
/**
 * @param {?} text
 * @return {?}
 */
function escapeXml(text) {
    return _ESCAPED_CHARS.reduce((/**
     * @param {?} t
     * @param {?} entry
     * @return {?}
     */
    function (t, entry) { return t.replace(entry[0], entry[1]); }), text);
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xliff1_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Xliff1TranslationSerializer = /** @class */ (function () {
    function Xliff1TranslationSerializer() {
    }
    /**
     * @param {?} messages
     * @param {?} locale
     * @param {?=} isTarget
     * @return {?}
     */
    Xliff1TranslationSerializer.prototype.renderFile = /**
     * @param {?} messages
     * @param {?} locale
     * @param {?=} isTarget
     * @return {?}
     */
    function (messages, locale, isTarget) {
        var _a;
        var _this = this;
        if (isTarget === void 0) { isTarget = false; }
        /** @type {?} */
        var xml = new XmlFile();
        xml.startTag('xliff', {
            version: '1.2',
            xmlns: 'urn:oasis:names:tc:xliff:document:1.2'
        });
        /** @type {?} */
        var fileAttrs = (_a = {},
            _a['source-language'] = isTarget ? undefined : locale,
            _a['target-language'] = locale,
            _a.datatype = 'plaintext',
            _a);
        xml.startTag('file', fileAttrs);
        xml.startTag('body');
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            xml.startTag('trans-unit', {
                id: ((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId,
                datatype: 'html'
            });
            if (!isTarget) {
                _this.generateMessageTag(xml, 'source', message);
            }
            _this.generateMessageTag(xml, 'target', message);
            if (message.description) {
                _this.renderNote(xml, 'description', message.description);
            }
            if (message.meaning) {
                _this.renderNote(xml, 'meaning', message.meaning);
            }
            xml.endTag('trans-unit');
        }));
        xml.endTag('body');
        xml.endTag('file');
        xml.endTag('xliff');
        return xml.toString();
    };
    /**
     * @private
     * @param {?} xml
     * @param {?} tagName
     * @param {?} message
     * @return {?}
     */
    Xliff1TranslationSerializer.prototype.generateMessageTag = /**
     * @private
     * @param {?} xml
     * @param {?} tagName
     * @param {?} message
     * @return {?}
     */
    function (xml, tagName, message) {
        xml.startTag(tagName, {}, { preserveWhitespace: true });
        this.renderMessage(xml, message);
        xml.endTag(tagName, { preserveWhitespace: false });
    };
    /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    Xliff1TranslationSerializer.prototype.renderMessage = /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    function (xml, message) {
        xml.text(message.messageParts[0]);
        for (var i = 1; i < message.messageParts.length; i++) {
            xml.startTag('x', { id: message.placeholderNames[i - 1] }, { selfClosing: true });
            xml.text(message.messageParts[i]);
        }
    };
    /**
     * @private
     * @param {?} xml
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    Xliff1TranslationSerializer.prototype.renderNote = /**
     * @private
     * @param {?} xml
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (xml, name, value) {
        xml.startTag('note', { priority: '1', from: name }, { preserveWhitespace: true });
        xml.text(value);
        xml.endTag('note', { preserveWhitespace: false });
    };
    return Xliff1TranslationSerializer;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xliff2_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Xliff2TranslationSerializer = /** @class */ (function () {
    function Xliff2TranslationSerializer() {
    }
    /**
     * @param {?} messages
     * @param {?} locale
     * @param {?=} isTarget
     * @return {?}
     */
    Xliff2TranslationSerializer.prototype.renderFile = /**
     * @param {?} messages
     * @param {?} locale
     * @param {?=} isTarget
     * @return {?}
     */
    function (messages, locale, isTarget) {
        var _this = this;
        if (isTarget === void 0) { isTarget = false; }
        /** @type {?} */
        var xml = new XmlFile();
        xml.startTag('xliff', {
            version: '2.0',
            xmlns: 'urn:oasis:names:tc:xliff:document:2.0',
            srcLang: locale,
            trgLang: locale
        });
        xml.startTag('file');
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            xml.startTag('unit', {
                id: ((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId
            });
            if (message.meaning || message.description) {
                xml.startTag('notes');
                if (message.description) {
                    _this.renderNote(xml, 'description', message.description);
                }
                if (message.meaning) {
                    _this.renderNote(xml, 'meaning', message.meaning);
                }
                xml.endTag('notes');
            }
            xml.startTag('segment');
            if (!isTarget) {
                _this.generateMessageTag(xml, 'source', message);
            }
            _this.generateMessageTag(xml, 'target', message);
            xml.endTag('segment');
            xml.endTag('unit');
        }));
        xml.endTag('file');
        xml.endTag('xliff');
        return xml.toString();
    };
    /**
     * @private
     * @param {?} xml
     * @param {?} tagName
     * @param {?} message
     * @return {?}
     */
    Xliff2TranslationSerializer.prototype.generateMessageTag = /**
     * @private
     * @param {?} xml
     * @param {?} tagName
     * @param {?} message
     * @return {?}
     */
    function (xml, tagName, message) {
        xml.startTag(tagName, {}, { preserveWhitespace: true });
        this.renderMessage(xml, message);
        xml.endTag(tagName, { preserveWhitespace: false });
    };
    /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    Xliff2TranslationSerializer.prototype.renderMessage = /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    function (xml, message) {
        xml.text(message.messageParts[0]);
        for (var i = 1; i < message.messageParts.length; i++) {
            /** @type {?} */
            var placeholderName = message.placeholderNames[i - 1];
            if (placeholderName.startsWith('START_')) {
                xml.startTag('pc', {
                    id: "" + i,
                    equivStart: placeholderName,
                    equivEnd: placeholderName.replace(/^START/, 'CLOSE')
                });
            }
            else if (placeholderName.startsWith('CLOSE_')) {
                xml.endTag('pc');
            }
            else {
                xml.startTag('ph', { id: "" + i, equiv: placeholderName }, { selfClosing: true });
            }
            xml.text(message.messageParts[i]);
        }
    };
    /**
     * @private
     * @param {?} xml
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    Xliff2TranslationSerializer.prototype.renderNote = /**
     * @private
     * @param {?} xml
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (xml, name, value) {
        xml.startTag('note', { category: name }, { preserveWhitespace: true });
        xml.text(value);
        xml.endTag('note', { preserveWhitespace: false });
    };
    return Xliff2TranslationSerializer;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xmb_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";
var XmbTranslationSerializer = /** @class */ (function () {
    function XmbTranslationSerializer() {
    }
    /**
     * @param {?} messages
     * @return {?}
     */
    XmbTranslationSerializer.prototype.renderFile = /**
     * @param {?} messages
     * @return {?}
     */
    function (messages) {
        var _this = this;
        /** @type {?} */
        var xml = new XmlFile();
        xml.startTag('messagebundle');
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            xml.startTag('msg', {
                id: ((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId,
                desc: message.description,
                meaning: message.meaning
            }, { preserveWhitespace: true });
            _this.renderMessage(xml, message);
            xml.endTag('msg', { preserveWhitespace: false });
        }));
        xml.endTag('messagebundle');
        return xml.toString();
    };
    /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    XmbTranslationSerializer.prototype.renderMessage = /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    function (xml, message) {
        xml.text(message.messageParts[0]);
        for (var i = 1; i < message.messageParts.length; i++) {
            xml.startTag('ph', { name: message.placeholderNames[i - 1] }, { selfClosing: true });
            xml.text(message.messageParts[i]);
        }
    };
    return XmbTranslationSerializer;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xtb_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DOCTYPE$1 = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE translationbundle [\n<!ELEMENT translationbundle (translation)*>\n<!ATTLIST translationbundle lang CDATA #REQUIRED>\n\n<!ELEMENT translation (#PCDATA|ph)*>\n<!ATTLIST translation id CDATA #REQUIRED>\n<!ATTLIST translation desc CDATA #IMPLIED>\n<!ATTLIST translation meaning CDATA #IMPLIED>\n<!ATTLIST translation xml:space (default|preserve) \"default\">\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>\n]>\n";
var XtbTranslationSerializer = /** @class */ (function () {
    function XtbTranslationSerializer() {
    }
    /**
     * @param {?} messages
     * @param {?} locale
     * @return {?}
     */
    XtbTranslationSerializer.prototype.renderFile = /**
     * @param {?} messages
     * @param {?} locale
     * @return {?}
     */
    function (messages, locale) {
        var _this = this;
        /** @type {?} */
        var xml = new XmlFile();
        xml.startTag('translationbundle', { lang: locale });
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            xml.startTag('translation', {
                id: ((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId,
                desc: message.description,
                meaning: message.meaning
            }, { preserveWhitespace: true });
            _this.renderMessage(xml, message);
            xml.endTag('translation', { preserveWhitespace: false });
        }));
        xml.endTag('translationbundle');
        return DOCTYPE$1 + xml.toString();
    };
    /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    XtbTranslationSerializer.prototype.renderMessage = /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    function (xml, message) {
        xml.text(message.messageParts[0]);
        for (var i = 1; i < message.messageParts.length; i++) {
            xml.startTag('ph', { name: message.placeholderNames[i - 1] }, { selfClosing: true });
            xml.text(message.messageParts[i]);
        }
    };
    return XtbTranslationSerializer;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/common/util.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} format
 * @return {?}
 */
function getTranslationSerializer(format) {
    switch (format) {
        case 'json':
            return new JsonTranslationSerializer();
        case 'xliff1':
        case 'xlf':
            return new Xliff1TranslationSerializer();
        case 'xliff2':
        case 'xlf2':
            return new Xliff2TranslationSerializer();
        case 'xmb':
            return new XmbTranslationSerializer();
        case 'xtb':
            return new XtbTranslationSerializer();
    }
}
/**
 * @param {?} format
 * @return {?}
 */
function getExtension(format) {
    switch (format) {
        case 'json':
        case 'xmb':
        case 'xtb':
            return format;
        default:
            return 'xlf';
    }
}
/**
 * The character used to mark the start and end of a "block" in a `$localize` tagged string.
 * A block can indicate metadata about the message or specify a name of a placeholder for a
 * substitution expressions.
 *
 * For example:
 *
 * ```ts
 * $localize`Hello, ${title}:title:!`;
 * $localize`:meaning|description\@\@id:source message text`;
 * ```
 * @type {?}
 */
var BLOCK_MARKER = ':';
/**
 * Find the end of a "marked block" indicated by the first non-escaped colon.
 *
 * @throws an error if the block is unterminated
 * @param {?} cooked The cooked string (where escaped chars have been processed)
 * @param {?} raw The raw string (where escape sequences are still in place)
 *
 * @return {?} the index of the end of block marker
 */
function findEndOfBlock(cooked, raw) {
    /************************************************************************************************
     * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.
     * (See that file for more explanation of why.)
     ************************************************************************************************/
    for (var cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {
        if (raw[rawIndex] === '\\') {
            rawIndex++;
        }
        else if (cooked[cookedIndex] === BLOCK_MARKER) {
            return cookedIndex;
        }
    }
    throw new Error("Unterminated $localize metadata block in \"" + raw + "\".");
}
/**
 * Split a message part (`cooked` + `raw`) into an optional delimited "block" off the front and the
 * rest of the text of the message part.
 *
 * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the
 * start and end of the block.
 *
 * If the block is in the first message part then it will be metadata about the whole message:
 * meaning, description, id.  Otherwise it will be metadata about the immediately preceding
 * substitution: placeholder name.
 *
 * Since blocks are optional, it is possible that the content of a message block actually starts
 * with a block marker. In this case the marker must be escaped `\:`.
 *
 * @throws an error if the `block` is unterminated
 * @param {?} cooked The cooked version of the message part to parse.
 * @param {?} raw The raw version of the message part to parse.
 * @return {?} An object containing the `text` of the message part and the text of the `block`, if it
 * exists.
 */
function splitBlock(cooked, raw) {
    if (raw.charAt(0) !== BLOCK_MARKER) {
        return { text: cooked };
    }
    else {
        /** @type {?} */
        var endOfBlock = findEndOfBlock(cooked, raw);
        return {
            block: cooked.substring(1, endOfBlock),
            text: cooked.substring(endOfBlock + 1)
        };
    }
}
/**
 * @param {?} index
 * @return {?}
 */
function computePlaceholderName(index) {
    return index === 1 ? 'PH' : "PH_" + (index - 1);
}
/**
 * @param {?} id
 * @param {?} translation
 * @return {?}
 */
function translationToMessage(id, translation) {
    /** @type {?} */
    var messageParts = translation.messageParts;
    /** @type {?} */
    var legacyIds = [];
    /** @type {?} */
    var cleanedMessageParts = [messageParts[0]];
    /** @type {?} */
    var substitutions = {};
    /** @type {?} */
    var placeholderNames = [];
    /** @type {?} */
    var text = messageParts[0];
    for (var i = 1; i < messageParts.length; i++) {
        var _a = splitBlock(messageParts[i], messageParts.raw[i]), messagePart = _a.text, _b = _a.block, placeholderName = _b === void 0 ? translation.placeholderNames[i - 1] ||
            computePlaceholderName(i) : _b;
        text += "{$" + placeholderName + "}" + messagePart;
        if (translation.placeholderNames.length) {
            substitutions[placeholderName] = translation.placeholderNames[i - 1];
        }
        placeholderNames.push(placeholderName);
        cleanedMessageParts.push(messagePart);
    }
    return {
        id: id,
        legacyIds: legacyIds,
        substitutions: substitutions,
        text: text,
        meaning: translation.meaning || '',
        description: translation.description || '',
        messageParts: cleanedMessageParts,
        placeholderNames: placeholderNames
    };
}
/**
 * @record
 */
function ParsedMessageLegacy() { }
if (false) {
    /**
     * The key used to look up the appropriate translation target.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageId;
    /**
     * Legacy message ids, if provided.
     *
     * In legacy message formats the message id can only be computed directly from the original
     * template source.
     *
     * Since this information is not available in `$localize` calls, the legacy message ids may be
     * attached by the compiler to the `$localize` metablock so it can be used if needed at the point
     * of translation if the translations are encoded using the legacy message id.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.legacyIds;
    /**
     * A mapping of placeholder names to substitution values.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.substitutions;
    /**
     * A human readable rendering of the message
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageString;
    /**
     * The meaning of the `message`, used to distinguish identical `messageString`s.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.meaning;
    /**
     * The description of the `message`, used to aid translation.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.description;
    /**
     * The static parts of the message.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageParts;
    /**
     * The names of the placeholders that will be replaced with substitutions.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.placeholderNames;
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/source_file_utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Is the given `expression` an identifier with the correct name
 * @param {?} expression The expression to check.
 * @param {?} name
 * @return {?}
 */
function isNamedIdentifier(expression, name) {
    return expression.isIdentifier() && expression.node.name === name;
}
/**
 * Is the given `identifier` declared globally.
 * @param {?} identifier The identifier to check.
 * @return {?}
 */
function isGlobalIdentifier(identifier) {
    return (!identifier.scope || !identifier.scope.hasBinding(identifier.node.name));
}
/**
 * Build a translated expression to replace the call to `$localize`.
 * @param {?} messageParts The static parts of the message.
 * @param {?} substitutions The expressions to substitute into the message.
 * @return {?}
 */
function buildLocalizeReplacement(messageParts, substitutions) {
    /** @type {?} */
    var mappedString = stringLiteral(messageParts[0]);
    for (var i = 1; i < messageParts.length; i++) {
        mappedString = binaryExpression('+', mappedString, wrapInParensIfNecessary(substitutions[i - 1]));
        mappedString = binaryExpression('+', mappedString, stringLiteral(messageParts[i]));
    }
    return mappedString;
}
/**
 * Extract the message parts from the given `call` (to `$localize`).
 *
 * The message parts will either by the first argument to the `call` or it will be wrapped in call
 * to a helper function like `__makeTemplateObject`.
 *
 * @param {?} call The AST node of the call to process.
 * @return {?}
 */
function unwrapMessagePartsFromLocalizeCall(call) {
    /** @type {?} */
    var cooked = (/** @type {?} */ (call.get('arguments')[0]));
    if (cooked === undefined) {
        throw new BabelParseError(call.node, '`$localize` called without any arguments.');
    }
    if (!cooked.isExpression()) {
        throw new BabelParseError(cooked.node, 'Unexpected argument to `$localize` (expected an array).');
    }
    // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.
    /** @type {?} */
    var raw = cooked;
    // Check for cached call of the form `x || x = __makeTemplateObject(...)`
    if (cooked.isLogicalExpression() &&
        cooked.node.operator === '||' &&
        cooked.get('left').isIdentifier()) {
        /** @type {?} */
        var right = cooked.get('right');
        if (right.isAssignmentExpression()) {
            cooked = right.get('right');
            if (!cooked.isExpression()) {
                throw new BabelParseError(cooked.node, 'Unexpected "makeTemplateObject()" function (expected an expression).');
            }
        }
    }
    // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.
    if (cooked.isCallExpression()) {
        /** @type {?} */
        var cookedCall = cooked;
        if (cookedCall.get('arguments').length === 0) {
            // No arguments so perhaps it is a `__templateObject()` call.
            // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.
            cookedCall = unwrapLazyLoadHelperCall(cookedCall);
        }
        cooked = cookedCall.get('arguments')[0];
        if (!cooked.isExpression()) {
            throw new BabelParseError(cooked.node, 'Unexpected `cooked` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        /** @type {?} */
        var arg2 = cookedCall.get('arguments')[1];
        if (arg2 && !arg2.isExpression()) {
            throw new BabelParseError(arg2.node, 'Unexpected `raw` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        // If there is no second argument then assume that raw and cooked are the same
        raw = arg2 !== undefined ? arg2 : cooked;
    }
    /** @type {?} */
    var cookedStrings = unwrapStringLiteralArray(cooked.node);
    /** @type {?} */
    var rawStrings = unwrapStringLiteralArray(raw.node);
    return ɵmakeTemplateObject(cookedStrings, rawStrings);
}
/**
 * @param {?} call
 * @return {?}
 */
function unwrapSubstitutionsFromLocalizeCall(call) {
    /** @type {?} */
    var expressions = call.arguments.splice(1);
    if (!isArrayOfExpressions(expressions)) {
        /** @type {?} */
        var badExpression = (/** @type {?} */ (expressions.find((/**
         * @param {?} expression
         * @return {?}
         */
        function (expression) { return !isExpression(expression); }))));
        throw new BabelParseError(badExpression, 'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).');
    }
    return expressions;
}
/**
 * @param {?} elements
 * @return {?}
 */
function unwrapMessagePartsFromTemplateLiteral(elements) {
    /** @type {?} */
    var cooked = elements.map((/**
     * @param {?} q
     * @return {?}
     */
    function (q) {
        if (q.value.cooked === undefined) {
            throw new BabelParseError(q, "Unexpected undefined message part in \"" + elements.map((/**
             * @param {?} eq
             * @return {?}
             */
            function (eq) { return eq.value.cooked; })) + "\"");
        }
        return q.value.cooked;
    }));
    /** @type {?} */
    var raw = elements.map((/**
     * @param {?} q
     * @return {?}
     */
    function (q) { return q.value.raw; }));
    return ɵmakeTemplateObject(cooked, raw);
}
/**
 * Wrap the given `expression` in parentheses if it is a binary expression.
 *
 * This ensures that this expression is evaluated correctly if it is embedded in another expression.
 *
 * @param {?} expression The expression to potentially wrap.
 * @return {?}
 */
function wrapInParensIfNecessary(expression) {
    if (isBinaryExpression(expression)) {
        return parenthesizedExpression(expression);
    }
    else {
        return expression;
    }
}
/**
 * Extract the string values from an `array` of string literals.
 * @param {?} array The array to unwrap.
 * @return {?}
 */
function unwrapStringLiteralArray(array) {
    if (!isStringLiteralArray(array)) {
        throw new BabelParseError(array, 'Unexpected messageParts for `$localize` (expected an array of strings).');
    }
    return array.elements.map((/**
     * @param {?} str
     * @return {?}
     */
    function (str) { return str.value; }));
}
/**
 * This expression is believed to be a call to a "lazy-load" template object helper function.
 * This is expected to be of the form:
 *
 * ```ts
 *  function _templateObject() {
 *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);
 *    return _templateObject = function() { return e }, e
 *  }
 * ```
 *
 * We unwrap this to return the call to `_taggedTemplateLiteral()`.
 *
 * @param {?} call the call expression to unwrap
 * @return {?} the  call expression
 */
function unwrapLazyLoadHelperCall(call) {
    /** @type {?} */
    var callee = (/** @type {?} */ (call.get('callee')));
    if (!callee.isIdentifier()) {
        throw new BabelParseError(callee.node, 'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).');
    }
    /** @type {?} */
    var lazyLoadBinding = call.scope.getBinding(callee.node.name);
    if (!lazyLoadBinding) {
        throw new BabelParseError(callee.node, 'Missing declaration for lazy-load helper function');
    }
    /** @type {?} */
    var lazyLoadFn = lazyLoadBinding.path;
    if (!lazyLoadFn.isFunctionDeclaration()) {
        throw new BabelParseError(((/** @type {?} */ (lazyLoadFn))).node, 'Unexpected expression (expected a function declaration');
    }
    /** @type {?} */
    var returnedNode = getReturnedExpression(lazyLoadFn);
    if (returnedNode.isCallExpression()) {
        return returnedNode;
    }
    if (returnedNode.isIdentifier()) {
        /** @type {?} */
        var identifierName = returnedNode.node.name;
        /** @type {?} */
        var declaration = returnedNode.scope.getBinding(identifierName);
        if (declaration === undefined) {
            throw new BabelParseError(returnedNode.node, 'Missing declaration for return value from helper.');
        }
        if (!declaration.path.isVariableDeclarator()) {
            throw new BabelParseError(((/** @type {?} */ (declaration))).path.node, 'Unexpected helper return value declaration (expected a variable declaration).');
        }
        /** @type {?} */
        var initializer = declaration.path.get('init');
        if (!initializer.isCallExpression()) {
            throw new BabelParseError(declaration.path.node, 'Unexpected return value from helper (expected a call expression).');
        }
        // Remove the lazy load helper if this is the only reference to it.
        if (lazyLoadBinding.references === 1) {
            lazyLoadFn.remove();
        }
        return initializer;
    }
    return call;
}
/**
 * @param {?} fn
 * @return {?}
 */
function getReturnedExpression(fn) {
    var e_1, _a;
    /** @type {?} */
    var bodyStatements = ((/** @type {?} */ (fn.get('body')))).get('body');
    try {
        for (var bodyStatements_1 = __values(bodyStatements), bodyStatements_1_1 = bodyStatements_1.next(); !bodyStatements_1_1.done; bodyStatements_1_1 = bodyStatements_1.next()) {
            var statement = bodyStatements_1_1.value;
            if (statement.isReturnStatement()) {
                /** @type {?} */
                var argument = statement.get('argument');
                if (argument.isSequenceExpression()) {
                    /** @type {?} */
                    var expressions = argument.get('expressions');
                    return Array.isArray(expressions)
                        ? expressions[expressions.length - 1]
                        : expressions;
                }
                else if (argument.isExpression()) {
                    return argument;
                }
                else {
                    throw new BabelParseError(statement.node, 'Invalid return argument in helper function (expected an expression).');
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (bodyStatements_1_1 && !bodyStatements_1_1.done && (_a = bodyStatements_1.return)) _a.call(bodyStatements_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    throw new BabelParseError(fn.node, 'Missing return statement in helper function.');
}
/**
 * Is the given `node` an array of literal strings?
 *
 * @param {?} node The node to test.
 * @return {?}
 */
function isStringLiteralArray(node) {
    return (isArrayExpression(node) &&
        node.elements.every((/**
         * @param {?} element
         * @return {?}
         */
        function (element) { return isStringLiteral(element); })));
}
/**
 * Are all the given `nodes` expressions?
 * @param {?} nodes The nodes to test.
 * @return {?}
 */
function isArrayOfExpressions(nodes) {
    return nodes.every((/**
     * @param {?} element
     * @return {?}
     */
    function (element) { return isExpression(element); }));
}
/**
 * Options that affect how the `makeEsXXXTranslatePlugin()` functions work.
 * @record
 */
function TranslatePluginOptions() { }
if (false) {
    /** @type {?|undefined} */
    TranslatePluginOptions.prototype.missingTranslation;
    /** @type {?|undefined} */
    TranslatePluginOptions.prototype.localizeName;
}
/**
 * Translate the text of the given message, using the given translations.
 *
 * Logs as warning if the translation is not available
 * @param {?} diagnostics
 * @param {?} translations
 * @param {?} messageParts
 * @param {?} substitutions
 * @param {?} missingTranslation
 * @return {?}
 */
function translate(diagnostics, translations, messageParts, substitutions, missingTranslation) {
    try {
        return ɵtranslate(translations, messageParts, substitutions);
    }
    catch (e) {
        if (ɵisMissingTranslationError(e)) {
            if (missingTranslation === 'error') {
                diagnostics.error(e.message);
            }
            else if (missingTranslation === 'warning') {
                diagnostics.warn(e.message);
            }
            // Return the parsed message because this will have the meta blocks stripped
            return [
                ɵmakeTemplateObject(e.parsedMessage.messageParts, e.parsedMessage.messageParts),
                substitutions
            ];
        }
        else {
            diagnostics.error(e.message);
            return [messageParts, substitutions];
        }
    }
}
var BabelParseError = /** @class */ (function (_super) {
    __extends(BabelParseError, _super);
    function BabelParseError(node, message) {
        var _this = _super.call(this, message) || this;
        _this.node = node;
        _this.type = 'BabelParseError';
        return _this;
    }
    return BabelParseError;
}(Error));
if (false) {
    /**
     * @type {?}
     * @private
     */
    BabelParseError.prototype.type;
    /** @type {?} */
    BabelParseError.prototype.node;
}
/**
 * @param {?} e
 * @return {?}
 */
function isBabelParseError(e) {
    return e.type === 'BabelParseError';
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/source_files/es2015_extract_plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} messages
 * @param {?} diagnostics
 * @param {?=} localizeName
 * @return {?}
 */
function makeEs2015ExtractPlugin(messages, diagnostics, localizeName) {
    if (localizeName === void 0) { localizeName = '$localize'; }
    return {
        visitor: {
            TaggedTemplateExpression: /**
             * @param {?} path
             * @return {?}
             */
            function (path) {
                /** @type {?} */
                var tag = path.get('tag');
                if (isNamedIdentifier(tag, localizeName) && isGlobalIdentifier(tag)) {
                    /** @type {?} */
                    var messageParts = unwrapMessagePartsFromTemplateLiteral(path.node.quasi.quasis);
                    /** @type {?} */
                    var message_1 = ɵparseMessage(messageParts, path.node.quasi.expressions);
                    if (!messages.find((/**
                     * @param {?} msg
                     * @return {?}
                     */
                    function (msg) {
                        return message_1.id
                            ? msg.id === message_1.id
                            : msg.messageId ===
                                ((/** @type {?} */ (((/** @type {?} */ (message_1)))))).messageId;
                    }))) {
                        messages.push(message_1);
                    }
                }
            }
        }
    };
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/source_files/es5_extract_plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} messages
 * @param {?} diagnostics
 * @param {?=} localizeName
 * @return {?}
 */
function makeEs5ExtractPlugin(messages, diagnostics, localizeName) {
    if (localizeName === void 0) { localizeName = '$localize'; }
    return {
        visitor: {
            CallExpression: /**
             * @param {?} callPath
             * @return {?}
             */
            function (callPath) {
                /** @type {?} */
                var calleePath = callPath.get('callee');
                if (isNamedIdentifier(calleePath, localizeName) &&
                    isGlobalIdentifier(calleePath)) {
                    /** @type {?} */
                    var messageParts = unwrapMessagePartsFromLocalizeCall(callPath);
                    /** @type {?} */
                    var expressions = unwrapSubstitutionsFromLocalizeCall(callPath.node);
                    /** @type {?} */
                    var message_1 = ɵparseMessage(messageParts, expressions);
                    if (!messages.find((/**
                     * @param {?} msg
                     * @return {?}
                     */
                    function (msg) {
                        return message_1.id
                            ? msg.id === message_1.id
                            : msg.messageId ===
                                ((/** @type {?} */ (((/** @type {?} */ (message_1)))))).messageId;
                    }))) {
                        messages.push(message_1);
                    }
                }
            }
        }
    };
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/extractor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A class that extracts parsed messages from file contents, by parsing the contents as JavaScript
 * and looking for occurrences of `$localize` in the source code.
 */
var /**
 * A class that extracts parsed messages from file contents, by parsing the contents as JavaScript
 * and looking for occurrences of `$localize` in the source code.
 */
Extractor = /** @class */ (function () {
    function Extractor(diagnostics) {
        this.diagnostics = diagnostics;
        this.messages = [];
    }
    /**
     * @param {?} sourceCode
     * @return {?}
     */
    Extractor.prototype.extractMessages = /**
     * @param {?} sourceCode
     * @return {?}
     */
    function (sourceCode) {
        if (sourceCode.includes('$localize')) {
            // Only bother to parse the file if it contains a reference to `$localize`.
            transformSync(sourceCode, {
                plugins: [
                    makeEs2015ExtractPlugin(this.messages, this.diagnostics),
                    makeEs5ExtractPlugin(this.messages, this.diagnostics)
                ],
                code: false,
                ast: false
            });
        }
    };
    return Extractor;
}());
if (false) {
    /** @type {?} */
    Extractor.prototype.messages;
    /**
     * @type {?}
     * @private
     */
    Extractor.prototype.diagnostics;
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var command = 'extract';
/** @type {?} */
var describe = 'Extract translations from your ivy application';
/** @type {?} */
var builder = {
    s: {
        alias: 'source',
        required: true,
        describe: 'A glob pattern indicating what files to search for translations, e.g. `./dist/**/*.js`. This can be absolute or relative to the current working directory.'
    },
    f: {
        alias: 'format',
        required: true,
        describe: 'The format of the translation files to generate.',
        choices: ['json', 'xlf', 'xmb', 'xlf2'],
        default: 'json'
    },
    o: {
        alias: 'outputPath',
        required: true,
        describe: 'A path to where the translation file will be written. This can be absolute or relative to the current working directory.'
    },
    l: {
        alias: ['locale', 'locales'],
        required: false,
        type: 'array',
        describe: 'The locale for the extracted file, "en" by default. If you use multiple locales (e.g. "en fr es"), a new file will be generated for each locale'
    }
};
/** @type {?} */
var handler = (/**
 * @param {?} options
 * @return {?}
 */
function (options) {
    /** @type {?} */
    var diagnostics = new Diagnostics();
    extractTranslations({
        sourceGlob: (/** @type {?} */ (options['s'])),
        format: (/** @type {?} */ (options['f'])),
        outputPath: (/** @type {?} */ (options['o'])),
        locales: (/** @type {?} */ (options['l'])),
        diagnostics: diagnostics
    });
    diagnostics.logMessages();
    process.exit(diagnostics.hasErrors ? 1 : 0);
});
/**
 * @record
 */
function ExtractTranslationsOptions() { }
if (false) {
    /** @type {?} */
    ExtractTranslationsOptions.prototype.sourceGlob;
    /** @type {?} */
    ExtractTranslationsOptions.prototype.format;
    /** @type {?} */
    ExtractTranslationsOptions.prototype.outputPath;
    /** @type {?|undefined} */
    ExtractTranslationsOptions.prototype.locales;
    /** @type {?} */
    ExtractTranslationsOptions.prototype.diagnostics;
}
/**
 * @param {?} __0
 * @return {?}
 */
function extractTranslations(_a) {
    var source = _a.sourceGlob, format = _a.format, output = _a.outputPath, _b = _a.locales, locales = _b === void 0 ? ['en'] : _b, diagnostics = _a.diagnostics;
    console.log("Extracting translations from \"" + source + "\"");
    /** @type {?} */
    var filesToProcess = sync(resolve(source), {
        absolute: true,
        nodir: true
    });
    filesToProcess = FileUtils.dedup(filesToProcess, /\-es(5|2015)\./, '.');
    output = resolve(output);
    /** @type {?} */
    var generatedFiles = [];
    /** @type {?} */
    var isFile;
    try {
        /** @type {?} */
        var stat = statSync(output);
        isFile = stat.isFile();
    }
    catch (e) {
        isFile = !!extname(output);
    }
    if (isFile) {
        if (locales.length > 1) {
            diagnostics.error("Multiple locales detected (\"" + locales.join(',') + "\") but output \"" + output + "\" is not a directory");
            return;
        }
        /** @type {?} */
        var res = makeTranslationsFile(filesToProcess, posix.normalize(output), source, format, locales[0], diagnostics);
        if (res) {
            generatedFiles.push(res);
        }
    }
    else {
        filesToProcess.forEach((/**
         * @param {?} file
         * @return {?}
         */
        function (file) {
            locales.forEach((/**
             * @param {?} locale
             * @return {?}
             */
            function (locale) {
                /** @type {?} */
                var newFileName = posix.join(output, basename(file, '.js').replace(/-es(5|2015)/, '') +
                    '.' +
                    locale +
                    '.' +
                    getExtension(format));
                /** @type {?} */
                var res = makeTranslationsFile([file], newFileName, source, format, locale, diagnostics);
                if (res) {
                    generatedFiles.push(res);
                }
            }));
        }));
    }
    if (!generatedFiles.length) {
        diagnostics.error("No messages found. You should build the angular app without a language target for this command to work.");
        return;
    }
}
/**
 * @param {?} filesToProcess
 * @param {?} fileOutput
 * @param {?} source
 * @param {?} format
 * @param {?} locale
 * @param {?} diagnostics
 * @return {?}
 */
function makeTranslationsFile(filesToProcess, fileOutput, source, format, locale, diagnostics) {
    /** @type {?} */
    var extractor = new Extractor(diagnostics);
    filesToProcess.forEach((/**
     * @param {?} file
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var contents = readFileSync(file, 'utf8');
        extractor.extractMessages(contents);
    }));
    /** @type {?} */
    var serializer = getTranslationSerializer(format);
    if (extractor.messages.length > 0) {
        /** @type {?} */
        var translationFile = serializer.renderFile(extractor.messages, locale, false);
        FileUtils.writeFile(fileOutput, translationFile);
        console.log("  Generated file \"" + fileOutput + "\"");
        return fileOutput;
    }
    return null;
}

/**
 * @fileoverview added by tsickle
 * Generated from: main.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var configPath = sync$1(['.loclrc', '.locl.json']);
/** @type {?} */
var config = configPath
    ? JSON.parse(readFileSync(configPath, { encoding: 'utf8' }))
    : {};
/** @type {?} */
var args = process.argv.slice(2);
config$1(config)
    .commandDir('cmds')
    .demandCommand()
    .help()
    .version(false)
    .parse(args);

/**
 * @fileoverview added by tsickle
 * Generated from: index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: locl-cli.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CliModule, builder, command, describe, extractTranslations, handler };
//# sourceMappingURL=locl-cli.js.map
