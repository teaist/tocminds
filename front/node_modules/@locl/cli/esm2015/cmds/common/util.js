/**
 * @fileoverview added by tsickle
 * Generated from: cmds/common/util.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { JsonTranslationSerializer } from '../extract/translation_files/json_translation_serializer';
import { Xliff1TranslationSerializer } from '../extract/translation_files/xliff1_translation_serializer';
import { Xliff2TranslationSerializer } from '../extract/translation_files/xliff2_translation_serializer';
import { XmbTranslationSerializer } from '../extract/translation_files/xmb_translation_serializer';
import { XtbTranslationSerializer } from '../extract/translation_files/xtb_translation_serializer';
/**
 * @param {?} format
 * @return {?}
 */
export function getTranslationSerializer(format) {
    switch (format) {
        case 'json':
            return new JsonTranslationSerializer();
        case 'xliff1':
        case 'xlf':
            return new Xliff1TranslationSerializer();
        case 'xliff2':
        case 'xlf2':
            return new Xliff2TranslationSerializer();
        case 'xmb':
            return new XmbTranslationSerializer();
        case 'xtb':
            return new XtbTranslationSerializer();
    }
}
/**
 * @param {?} format
 * @return {?}
 */
export function getExtension(format) {
    switch (format) {
        case 'json':
        case 'xmb':
        case 'xtb':
            return format;
        default:
            return 'xlf';
    }
}
/**
 * The character used to mark the start and end of a "block" in a `$localize` tagged string.
 * A block can indicate metadata about the message or specify a name of a placeholder for a
 * substitution expressions.
 *
 * For example:
 *
 * ```ts
 * $localize`Hello, ${title}:title:!`;
 * $localize`:meaning|description\@\@id:source message text`;
 * ```
 * @type {?}
 */
export const BLOCK_MARKER = ':';
/**
 * Find the end of a "marked block" indicated by the first non-escaped colon.
 *
 * @throws an error if the block is unterminated
 * @param {?} cooked The cooked string (where escaped chars have been processed)
 * @param {?} raw The raw string (where escape sequences are still in place)
 *
 * @return {?} the index of the end of block marker
 */
export function findEndOfBlock(cooked, raw) {
    /************************************************************************************************
     * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.
     * (See that file for more explanation of why.)
     ************************************************************************************************/
    for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {
        if (raw[rawIndex] === '\\') {
            rawIndex++;
        }
        else if (cooked[cookedIndex] === BLOCK_MARKER) {
            return cookedIndex;
        }
    }
    throw new Error(`Unterminated $localize metadata block in "${raw}".`);
}
/**
 * Split a message part (`cooked` + `raw`) into an optional delimited "block" off the front and the
 * rest of the text of the message part.
 *
 * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the
 * start and end of the block.
 *
 * If the block is in the first message part then it will be metadata about the whole message:
 * meaning, description, id.  Otherwise it will be metadata about the immediately preceding
 * substitution: placeholder name.
 *
 * Since blocks are optional, it is possible that the content of a message block actually starts
 * with a block marker. In this case the marker must be escaped `\:`.
 *
 * @throws an error if the `block` is unterminated
 * @param {?} cooked The cooked version of the message part to parse.
 * @param {?} raw The raw version of the message part to parse.
 * @return {?} An object containing the `text` of the message part and the text of the `block`, if it
 * exists.
 */
export function splitBlock(cooked, raw) {
    if (raw.charAt(0) !== BLOCK_MARKER) {
        return { text: cooked };
    }
    else {
        /** @type {?} */
        const endOfBlock = findEndOfBlock(cooked, raw);
        return {
            block: cooked.substring(1, endOfBlock),
            text: cooked.substring(endOfBlock + 1)
        };
    }
}
/**
 * @param {?} index
 * @return {?}
 */
function computePlaceholderName(index) {
    return index === 1 ? 'PH' : `PH_${index - 1}`;
}
/**
 * @param {?} id
 * @param {?} translation
 * @return {?}
 */
export function translationToMessage(id, translation) {
    /** @type {?} */
    const messageParts = translation.messageParts;
    /** @type {?} */
    const legacyIds = [];
    /** @type {?} */
    const cleanedMessageParts = [messageParts[0]];
    /** @type {?} */
    const substitutions = {};
    /** @type {?} */
    const placeholderNames = [];
    /** @type {?} */
    let text = messageParts[0];
    for (let i = 1; i < messageParts.length; i++) {
        const { text: messagePart, block: placeholderName = translation.placeholderNames[i - 1] ||
            computePlaceholderName(i) } = splitBlock(messageParts[i], messageParts.raw[i]);
        text += `{$${placeholderName}}${messagePart}`;
        if (translation.placeholderNames.length) {
            substitutions[placeholderName] = translation.placeholderNames[i - 1];
        }
        placeholderNames.push(placeholderName);
        cleanedMessageParts.push(messagePart);
    }
    return {
        id,
        legacyIds,
        substitutions,
        text,
        meaning: translation.meaning || '',
        description: translation.description || '',
        messageParts: cleanedMessageParts,
        placeholderNames
    };
}
/**
 * @record
 */
export function ParsedMessageLegacy() { }
if (false) {
    /**
     * The key used to look up the appropriate translation target.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageId;
    /**
     * Legacy message ids, if provided.
     *
     * In legacy message formats the message id can only be computed directly from the original
     * template source.
     *
     * Since this information is not available in `$localize` calls, the legacy message ids may be
     * attached by the compiler to the `$localize` metablock so it can be used if needed at the point
     * of translation if the translations are encoded using the legacy message id.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.legacyIds;
    /**
     * A mapping of placeholder names to substitution values.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.substitutions;
    /**
     * A human readable rendering of the message
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageString;
    /**
     * The meaning of the `message`, used to distinguish identical `messageString`s.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.meaning;
    /**
     * The description of the `message`, used to aid translation.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.description;
    /**
     * The static parts of the message.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageParts;
    /**
     * The names of the placeholders that will be replaced with substitutions.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.placeholderNames;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bsb2NsL2NsaS8iLCJzb3VyY2VzIjpbImNtZHMvY29tbW9uL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSwwREFBMEQsQ0FBQztBQUVyRyxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSw0REFBNEQsQ0FBQztBQUN6RyxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSw0REFBNEQsQ0FBQztBQUN6RyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx5REFBeUQsQ0FBQztBQUduRyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx5REFBeUQsQ0FBQzs7Ozs7QUFXbkcsTUFBTSxVQUFVLHdCQUF3QixDQUN0QyxNQUF5QjtJQUV6QixRQUFRLE1BQU0sRUFBRTtRQUNkLEtBQUssTUFBTTtZQUNULE9BQU8sSUFBSSx5QkFBeUIsRUFBRSxDQUFDO1FBQ3pDLEtBQUssUUFBUSxDQUFDO1FBQ2QsS0FBSyxLQUFLO1lBQ1IsT0FBTyxJQUFJLDJCQUEyQixFQUFFLENBQUM7UUFDM0MsS0FBSyxRQUFRLENBQUM7UUFDZCxLQUFLLE1BQU07WUFDVCxPQUFPLElBQUksMkJBQTJCLEVBQUUsQ0FBQztRQUMzQyxLQUFLLEtBQUs7WUFDUixPQUFPLElBQUksd0JBQXdCLEVBQUUsQ0FBQztRQUN4QyxLQUFLLEtBQUs7WUFDUixPQUFPLElBQUksd0JBQXdCLEVBQUUsQ0FBQztLQUN6QztBQUNILENBQUM7Ozs7O0FBRUQsTUFBTSxVQUFVLFlBQVksQ0FBQyxNQUF5QjtJQUNwRCxRQUFRLE1BQU0sRUFBRTtRQUNkLEtBQUssTUFBTSxDQUFDO1FBQ1osS0FBSyxLQUFLLENBQUM7UUFDWCxLQUFLLEtBQUs7WUFDUixPQUFPLE1BQU0sQ0FBQztRQUNoQjtZQUNFLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUFjRCxNQUFNLE9B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QVcsQ0FBQyxXQUFXLElBQUksRUFBRTtRQUMxQyxZQUFZLEVBQUUsbUJBQW1CO1FBQ2pDLGdCQUFnQjtLQUNqQixDQUFDO0FBQ0osQ0FBQzs7OztBQUVELHlDQXdDQzs7Ozs7O0lBcENDLHdDQUFzQjs7Ozs7Ozs7Ozs7O0lBV3RCLHdDQUF3Qjs7Ozs7SUFJeEIsNENBQW1DOzs7OztJQUluQyw0Q0FBc0I7Ozs7O0lBSXRCLHNDQUFnQjs7Ozs7SUFJaEIsMENBQW9COzs7OztJQUlwQiwyQ0FBdUI7Ozs7O0lBSXZCLCtDQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEpzb25UcmFuc2xhdGlvblNlcmlhbGl6ZXIgfSBmcm9tICcuLi9leHRyYWN0L3RyYW5zbGF0aW9uX2ZpbGVzL2pzb25fdHJhbnNsYXRpb25fc2VyaWFsaXplcic7XHJcbmltcG9ydCB7IFRyYW5zbGF0aW9uU2VyaWFsaXplciB9IGZyb20gJy4uL2V4dHJhY3QvdHJhbnNsYXRpb25fZmlsZXMvdHJhbnNsYXRpb25fc2VyaWFsaXplcic7XHJcbmltcG9ydCB7IFhsaWZmMVRyYW5zbGF0aW9uU2VyaWFsaXplciB9IGZyb20gJy4uL2V4dHJhY3QvdHJhbnNsYXRpb25fZmlsZXMveGxpZmYxX3RyYW5zbGF0aW9uX3NlcmlhbGl6ZXInO1xyXG5pbXBvcnQgeyBYbGlmZjJUcmFuc2xhdGlvblNlcmlhbGl6ZXIgfSBmcm9tICcuLi9leHRyYWN0L3RyYW5zbGF0aW9uX2ZpbGVzL3hsaWZmMl90cmFuc2xhdGlvbl9zZXJpYWxpemVyJztcclxuaW1wb3J0IHsgWG1iVHJhbnNsYXRpb25TZXJpYWxpemVyIH0gZnJvbSAnLi4vZXh0cmFjdC90cmFuc2xhdGlvbl9maWxlcy94bWJfdHJhbnNsYXRpb25fc2VyaWFsaXplcic7XHJcbmltcG9ydCB7IMm1TWVzc2FnZUlkLCDJtVBhcnNlZE1lc3NhZ2UgfSBmcm9tICdAYW5ndWxhci9sb2NhbGl6ZSc7XHJcbmltcG9ydCB7IFBhcnNlZFRyYW5zbGF0aW9uIH0gZnJvbSAnLi4vY29udmVydC90cmFuc2xhdGlvbnMnO1xyXG5pbXBvcnQgeyBYdGJUcmFuc2xhdGlvblNlcmlhbGl6ZXIgfSBmcm9tICcuLi9leHRyYWN0L3RyYW5zbGF0aW9uX2ZpbGVzL3h0Yl90cmFuc2xhdGlvbl9zZXJpYWxpemVyJztcclxuXHJcbmV4cG9ydCB0eXBlIFRyYW5zbGF0aW9uRm9ybWF0ID1cclxuICB8ICdqc29uJ1xyXG4gIHwgJ3htYidcclxuICB8ICd4bGlmZjEnXHJcbiAgfCAneGxpZmYyJ1xyXG4gIHwgJ3hsZidcclxuICB8ICd4bGYyJ1xyXG4gIHwgJ3h0Yic7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb25TZXJpYWxpemVyKFxyXG4gIGZvcm1hdDogVHJhbnNsYXRpb25Gb3JtYXRcclxuKTogVHJhbnNsYXRpb25TZXJpYWxpemVyIHtcclxuICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgY2FzZSAnanNvbic6XHJcbiAgICAgIHJldHVybiBuZXcgSnNvblRyYW5zbGF0aW9uU2VyaWFsaXplcigpO1xyXG4gICAgY2FzZSAneGxpZmYxJzpcclxuICAgIGNhc2UgJ3hsZic6XHJcbiAgICAgIHJldHVybiBuZXcgWGxpZmYxVHJhbnNsYXRpb25TZXJpYWxpemVyKCk7XHJcbiAgICBjYXNlICd4bGlmZjInOlxyXG4gICAgY2FzZSAneGxmMic6XHJcbiAgICAgIHJldHVybiBuZXcgWGxpZmYyVHJhbnNsYXRpb25TZXJpYWxpemVyKCk7XHJcbiAgICBjYXNlICd4bWInOlxyXG4gICAgICByZXR1cm4gbmV3IFhtYlRyYW5zbGF0aW9uU2VyaWFsaXplcigpO1xyXG4gICAgY2FzZSAneHRiJzpcclxuICAgICAgcmV0dXJuIG5ldyBYdGJUcmFuc2xhdGlvblNlcmlhbGl6ZXIoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbnNpb24oZm9ybWF0OiBUcmFuc2xhdGlvbkZvcm1hdCk6IHN0cmluZyB7XHJcbiAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgIGNhc2UgJ2pzb24nOlxyXG4gICAgY2FzZSAneG1iJzpcclxuICAgIGNhc2UgJ3h0Yic6XHJcbiAgICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gJ3hsZic7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGNoYXJhY3RlciB1c2VkIHRvIG1hcmsgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYSBcImJsb2NrXCIgaW4gYSBgJGxvY2FsaXplYCB0YWdnZWQgc3RyaW5nLlxyXG4gKiBBIGJsb2NrIGNhbiBpbmRpY2F0ZSBtZXRhZGF0YSBhYm91dCB0aGUgbWVzc2FnZSBvciBzcGVjaWZ5IGEgbmFtZSBvZiBhIHBsYWNlaG9sZGVyIGZvciBhXHJcbiAqIHN1YnN0aXR1dGlvbiBleHByZXNzaW9ucy5cclxuICpcclxuICogRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqICRsb2NhbGl6ZWBIZWxsbywgJHt0aXRsZX06dGl0bGU6IWA7XHJcbiAqICRsb2NhbGl6ZWA6bWVhbmluZ3xkZXNjcmlwdGlvbkBAaWQ6c291cmNlIG1lc3NhZ2UgdGV4dGA7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEJMT0NLX01BUktFUiA9ICc6JztcclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBlbmQgb2YgYSBcIm1hcmtlZCBibG9ja1wiIGluZGljYXRlZCBieSB0aGUgZmlyc3Qgbm9uLWVzY2FwZWQgY29sb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBjb29rZWQgVGhlIGNvb2tlZCBzdHJpbmcgKHdoZXJlIGVzY2FwZWQgY2hhcnMgaGF2ZSBiZWVuIHByb2Nlc3NlZClcclxuICogQHBhcmFtIHJhdyBUaGUgcmF3IHN0cmluZyAod2hlcmUgZXNjYXBlIHNlcXVlbmNlcyBhcmUgc3RpbGwgaW4gcGxhY2UpXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZW5kIG9mIGJsb2NrIG1hcmtlclxyXG4gKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBibG9jayBpcyB1bnRlcm1pbmF0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRW5kT2ZCbG9jayhjb29rZWQ6IHN0cmluZywgcmF3OiBzdHJpbmcpOiBudW1iZXIge1xyXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHJlcGVhdGVkIGluIGBzcmMvbG9jYWxpemUvc3JjL2xvY2FsaXplLnRzYCBhbmQgdGhlIHR3byBzaG91bGQgYmUga2VwdCBpbiBzeW5jLlxyXG4gICAqIChTZWUgdGhhdCBmaWxlIGZvciBtb3JlIGV4cGxhbmF0aW9uIG9mIHdoeS4pXHJcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICBmb3IgKFxyXG4gICAgbGV0IGNvb2tlZEluZGV4ID0gMSwgcmF3SW5kZXggPSAxO1xyXG4gICAgY29va2VkSW5kZXggPCBjb29rZWQubGVuZ3RoO1xyXG4gICAgY29va2VkSW5kZXgrKywgcmF3SW5kZXgrK1xyXG4gICkge1xyXG4gICAgaWYgKHJhd1tyYXdJbmRleF0gPT09ICdcXFxcJykge1xyXG4gICAgICByYXdJbmRleCsrO1xyXG4gICAgfSBlbHNlIGlmIChjb29rZWRbY29va2VkSW5kZXhdID09PSBCTE9DS19NQVJLRVIpIHtcclxuICAgICAgcmV0dXJuIGNvb2tlZEluZGV4O1xyXG4gICAgfVxyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoYFVudGVybWluYXRlZCAkbG9jYWxpemUgbWV0YWRhdGEgYmxvY2sgaW4gXCIke3Jhd31cIi5gKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwbGl0IGEgbWVzc2FnZSBwYXJ0IChgY29va2VkYCArIGByYXdgKSBpbnRvIGFuIG9wdGlvbmFsIGRlbGltaXRlZCBcImJsb2NrXCIgb2ZmIHRoZSBmcm9udCBhbmQgdGhlXHJcbiAqIHJlc3Qgb2YgdGhlIHRleHQgb2YgdGhlIG1lc3NhZ2UgcGFydC5cclxuICpcclxuICogQmxvY2tzIGFwcGVhciBhdCB0aGUgc3RhcnQgb2YgbWVzc2FnZSBwYXJ0cy4gVGhleSBhcmUgZGVsaW1pdGVkIGJ5IGEgY29sb24gYDpgIGNoYXJhY3RlciBhdCB0aGVcclxuICogc3RhcnQgYW5kIGVuZCBvZiB0aGUgYmxvY2suXHJcbiAqXHJcbiAqIElmIHRoZSBibG9jayBpcyBpbiB0aGUgZmlyc3QgbWVzc2FnZSBwYXJ0IHRoZW4gaXQgd2lsbCBiZSBtZXRhZGF0YSBhYm91dCB0aGUgd2hvbGUgbWVzc2FnZTpcclxuICogbWVhbmluZywgZGVzY3JpcHRpb24sIGlkLiAgT3RoZXJ3aXNlIGl0IHdpbGwgYmUgbWV0YWRhdGEgYWJvdXQgdGhlIGltbWVkaWF0ZWx5IHByZWNlZGluZ1xyXG4gKiBzdWJzdGl0dXRpb246IHBsYWNlaG9sZGVyIG5hbWUuXHJcbiAqXHJcbiAqIFNpbmNlIGJsb2NrcyBhcmUgb3B0aW9uYWwsIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIGNvbnRlbnQgb2YgYSBtZXNzYWdlIGJsb2NrIGFjdHVhbGx5IHN0YXJ0c1xyXG4gKiB3aXRoIGEgYmxvY2sgbWFya2VyLiBJbiB0aGlzIGNhc2UgdGhlIG1hcmtlciBtdXN0IGJlIGVzY2FwZWQgYFxcOmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb29rZWQgVGhlIGNvb2tlZCB2ZXJzaW9uIG9mIHRoZSBtZXNzYWdlIHBhcnQgdG8gcGFyc2UuXHJcbiAqIEBwYXJhbSByYXcgVGhlIHJhdyB2ZXJzaW9uIG9mIHRoZSBtZXNzYWdlIHBhcnQgdG8gcGFyc2UuXHJcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgdGV4dGAgb2YgdGhlIG1lc3NhZ2UgcGFydCBhbmQgdGhlIHRleHQgb2YgdGhlIGBibG9ja2AsIGlmIGl0XHJcbiAqIGV4aXN0cy5cclxuICogQHRocm93cyBhbiBlcnJvciBpZiB0aGUgYGJsb2NrYCBpcyB1bnRlcm1pbmF0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEJsb2NrKFxyXG4gIGNvb2tlZDogc3RyaW5nLFxyXG4gIHJhdzogc3RyaW5nXHJcbik6IHsgdGV4dDogc3RyaW5nOyBibG9jaz86IHN0cmluZyB9IHtcclxuICBpZiAocmF3LmNoYXJBdCgwKSAhPT0gQkxPQ0tfTUFSS0VSKSB7XHJcbiAgICByZXR1cm4geyB0ZXh0OiBjb29rZWQgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgZW5kT2ZCbG9jayA9IGZpbmRFbmRPZkJsb2NrKGNvb2tlZCwgcmF3KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJsb2NrOiBjb29rZWQuc3Vic3RyaW5nKDEsIGVuZE9mQmxvY2spLFxyXG4gICAgICB0ZXh0OiBjb29rZWQuc3Vic3RyaW5nKGVuZE9mQmxvY2sgKyAxKVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVQbGFjZWhvbGRlck5hbWUoaW5kZXg6IG51bWJlcikge1xyXG4gIHJldHVybiBpbmRleCA9PT0gMSA/ICdQSCcgOiBgUEhfJHtpbmRleCAtIDF9YDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0aW9uVG9NZXNzYWdlKFxyXG4gIGlkOiBzdHJpbmcsXHJcbiAgdHJhbnNsYXRpb246IFBhcnNlZFRyYW5zbGF0aW9uXHJcbik6IMm1UGFyc2VkTWVzc2FnZSB7XHJcbiAgY29uc3QgbWVzc2FnZVBhcnRzID0gdHJhbnNsYXRpb24ubWVzc2FnZVBhcnRzO1xyXG4gIGNvbnN0IGxlZ2FjeUlkcyA9IFtdO1xyXG4gIGNvbnN0IGNsZWFuZWRNZXNzYWdlUGFydHM6IHN0cmluZ1tdID0gW21lc3NhZ2VQYXJ0c1swXV07XHJcbiAgY29uc3Qgc3Vic3RpdHV0aW9uczogeyBbcGxhY2Vob2xkZXJOYW1lOiBzdHJpbmddOiBhbnkgfSA9IHt9O1xyXG4gIGNvbnN0IHBsYWNlaG9sZGVyTmFtZXM6IHN0cmluZ1tdID0gW107XHJcbiAgbGV0IHRleHQgPSBtZXNzYWdlUGFydHNbMF07XHJcblxyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWVzc2FnZVBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHRleHQ6IG1lc3NhZ2VQYXJ0LFxyXG4gICAgICBibG9jazogcGxhY2Vob2xkZXJOYW1lID0gdHJhbnNsYXRpb24ucGxhY2Vob2xkZXJOYW1lc1tpIC0gMV0gfHxcclxuICAgICAgICBjb21wdXRlUGxhY2Vob2xkZXJOYW1lKGkpXHJcbiAgICB9ID0gc3BsaXRCbG9jayhtZXNzYWdlUGFydHNbaV0sIG1lc3NhZ2VQYXJ0cy5yYXdbaV0pO1xyXG4gICAgdGV4dCArPSBgeyQke3BsYWNlaG9sZGVyTmFtZX19JHttZXNzYWdlUGFydH1gO1xyXG4gICAgaWYgKHRyYW5zbGF0aW9uLnBsYWNlaG9sZGVyTmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgIHN1YnN0aXR1dGlvbnNbcGxhY2Vob2xkZXJOYW1lXSA9IHRyYW5zbGF0aW9uLnBsYWNlaG9sZGVyTmFtZXNbaSAtIDFdO1xyXG4gICAgfVxyXG4gICAgcGxhY2Vob2xkZXJOYW1lcy5wdXNoKHBsYWNlaG9sZGVyTmFtZSk7XHJcbiAgICBjbGVhbmVkTWVzc2FnZVBhcnRzLnB1c2gobWVzc2FnZVBhcnQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkLFxyXG4gICAgbGVnYWN5SWRzLFxyXG4gICAgc3Vic3RpdHV0aW9ucyxcclxuICAgIHRleHQsXHJcbiAgICBtZWFuaW5nOiB0cmFuc2xhdGlvbi5tZWFuaW5nIHx8ICcnLFxyXG4gICAgZGVzY3JpcHRpb246IHRyYW5zbGF0aW9uLmRlc2NyaXB0aW9uIHx8ICcnLFxyXG4gICAgbWVzc2FnZVBhcnRzOiBjbGVhbmVkTWVzc2FnZVBhcnRzLFxyXG4gICAgcGxhY2Vob2xkZXJOYW1lc1xyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkTWVzc2FnZUxlZ2FjeSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIGtleSB1c2VkIHRvIGxvb2sgdXAgdGhlIGFwcHJvcHJpYXRlIHRyYW5zbGF0aW9uIHRhcmdldC5cclxuICAgKi9cclxuICBtZXNzYWdlSWQ6IMm1TWVzc2FnZUlkO1xyXG4gIC8qKlxyXG4gICAqIExlZ2FjeSBtZXNzYWdlIGlkcywgaWYgcHJvdmlkZWQuXHJcbiAgICpcclxuICAgKiBJbiBsZWdhY3kgbWVzc2FnZSBmb3JtYXRzIHRoZSBtZXNzYWdlIGlkIGNhbiBvbmx5IGJlIGNvbXB1dGVkIGRpcmVjdGx5IGZyb20gdGhlIG9yaWdpbmFsXHJcbiAgICogdGVtcGxhdGUgc291cmNlLlxyXG4gICAqXHJcbiAgICogU2luY2UgdGhpcyBpbmZvcm1hdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIGAkbG9jYWxpemVgIGNhbGxzLCB0aGUgbGVnYWN5IG1lc3NhZ2UgaWRzIG1heSBiZVxyXG4gICAqIGF0dGFjaGVkIGJ5IHRoZSBjb21waWxlciB0byB0aGUgYCRsb2NhbGl6ZWAgbWV0YWJsb2NrIHNvIGl0IGNhbiBiZSB1c2VkIGlmIG5lZWRlZCBhdCB0aGUgcG9pbnRcclxuICAgKiBvZiB0cmFuc2xhdGlvbiBpZiB0aGUgdHJhbnNsYXRpb25zIGFyZSBlbmNvZGVkIHVzaW5nIHRoZSBsZWdhY3kgbWVzc2FnZSBpZC5cclxuICAgKi9cclxuICBsZWdhY3lJZHM6IMm1TWVzc2FnZUlkW107XHJcbiAgLyoqXHJcbiAgICogQSBtYXBwaW5nIG9mIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHN1YnN0aXR1dGlvbiB2YWx1ZXMuXHJcbiAgICovXHJcbiAgc3Vic3RpdHV0aW9uczogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICAvKipcclxuICAgKiBBIGh1bWFuIHJlYWRhYmxlIHJlbmRlcmluZyBvZiB0aGUgbWVzc2FnZVxyXG4gICAqL1xyXG4gIG1lc3NhZ2VTdHJpbmc6IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgbWVhbmluZyBvZiB0aGUgYG1lc3NhZ2VgLCB1c2VkIHRvIGRpc3Rpbmd1aXNoIGlkZW50aWNhbCBgbWVzc2FnZVN0cmluZ2BzLlxyXG4gICAqL1xyXG4gIG1lYW5pbmc6IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGBtZXNzYWdlYCwgdXNlZCB0byBhaWQgdHJhbnNsYXRpb24uXHJcbiAgICovXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAvKipcclxuICAgKiBUaGUgc3RhdGljIHBhcnRzIG9mIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIG1lc3NhZ2VQYXJ0czogc3RyaW5nW107XHJcbiAgLyoqXHJcbiAgICogVGhlIG5hbWVzIG9mIHRoZSBwbGFjZWhvbGRlcnMgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggc3Vic3RpdHV0aW9ucy5cclxuICAgKi9cclxuICBwbGFjZWhvbGRlck5hbWVzOiBzdHJpbmdbXTtcclxufVxyXG4iXX0=