/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/source_file_utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵisMissingTranslationError, ɵmakeTemplateObject, ɵtranslate } from '@angular/localize';
import * as t from '@babel/types';
/**
 * Is the given `expression` an identifier with the correct name
 * @param {?} expression The expression to check.
 * @param {?} name
 * @return {?}
 */
export function isNamedIdentifier(expression, name) {
    return expression.isIdentifier() && expression.node.name === name;
}
/**
 * Is the given `identifier` declared globally.
 * @param {?} identifier The identifier to check.
 * @return {?}
 */
export function isGlobalIdentifier(identifier) {
    return (!identifier.scope || !identifier.scope.hasBinding(identifier.node.name));
}
/**
 * Build a translated expression to replace the call to `$localize`.
 * @param {?} messageParts The static parts of the message.
 * @param {?} substitutions The expressions to substitute into the message.
 * @return {?}
 */
export function buildLocalizeReplacement(messageParts, substitutions) {
    /** @type {?} */
    let mappedString = t.stringLiteral(messageParts[0]);
    for (let i = 1; i < messageParts.length; i++) {
        mappedString = t.binaryExpression('+', mappedString, wrapInParensIfNecessary(substitutions[i - 1]));
        mappedString = t.binaryExpression('+', mappedString, t.stringLiteral(messageParts[i]));
    }
    return mappedString;
}
/**
 * Extract the message parts from the given `call` (to `$localize`).
 *
 * The message parts will either by the first argument to the `call` or it will be wrapped in call
 * to a helper function like `__makeTemplateObject`.
 *
 * @param {?} call The AST node of the call to process.
 * @return {?}
 */
export function unwrapMessagePartsFromLocalizeCall(call) {
    /** @type {?} */
    let cooked = (/** @type {?} */ (call.get('arguments')[0]));
    if (cooked === undefined) {
        throw new BabelParseError(call.node, '`$localize` called without any arguments.');
    }
    if (!cooked.isExpression()) {
        throw new BabelParseError(cooked.node, 'Unexpected argument to `$localize` (expected an array).');
    }
    // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.
    /** @type {?} */
    let raw = cooked;
    // Check for cached call of the form `x || x = __makeTemplateObject(...)`
    if (cooked.isLogicalExpression() &&
        cooked.node.operator === '||' &&
        cooked.get('left').isIdentifier()) {
        /** @type {?} */
        const right = cooked.get('right');
        if (right.isAssignmentExpression()) {
            cooked = right.get('right');
            if (!cooked.isExpression()) {
                throw new BabelParseError(cooked.node, 'Unexpected "makeTemplateObject()" function (expected an expression).');
            }
        }
    }
    // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.
    if (cooked.isCallExpression()) {
        /** @type {?} */
        let cookedCall = cooked;
        if (cookedCall.get('arguments').length === 0) {
            // No arguments so perhaps it is a `__templateObject()` call.
            // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.
            cookedCall = unwrapLazyLoadHelperCall(cookedCall);
        }
        cooked = cookedCall.get('arguments')[0];
        if (!cooked.isExpression()) {
            throw new BabelParseError(cooked.node, 'Unexpected `cooked` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        /** @type {?} */
        const arg2 = cookedCall.get('arguments')[1];
        if (arg2 && !arg2.isExpression()) {
            throw new BabelParseError(arg2.node, 'Unexpected `raw` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        // If there is no second argument then assume that raw and cooked are the same
        raw = arg2 !== undefined ? arg2 : cooked;
    }
    /** @type {?} */
    const cookedStrings = unwrapStringLiteralArray(cooked.node);
    /** @type {?} */
    const rawStrings = unwrapStringLiteralArray(raw.node);
    return ɵmakeTemplateObject(cookedStrings, rawStrings);
}
/**
 * @param {?} call
 * @return {?}
 */
export function unwrapSubstitutionsFromLocalizeCall(call) {
    /** @type {?} */
    const expressions = call.arguments.splice(1);
    if (!isArrayOfExpressions(expressions)) {
        /** @type {?} */
        const badExpression = (/** @type {?} */ (expressions.find((/**
         * @param {?} expression
         * @return {?}
         */
        expression => !t.isExpression(expression)))));
        throw new BabelParseError(badExpression, 'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).');
    }
    return expressions;
}
/**
 * @param {?} elements
 * @return {?}
 */
export function unwrapMessagePartsFromTemplateLiteral(elements) {
    /** @type {?} */
    const cooked = elements.map((/**
     * @param {?} q
     * @return {?}
     */
    q => {
        if (q.value.cooked === undefined) {
            throw new BabelParseError(q, `Unexpected undefined message part in "${elements.map((/**
             * @param {?} eq
             * @return {?}
             */
            eq => eq.value.cooked))}"`);
        }
        return q.value.cooked;
    }));
    /** @type {?} */
    const raw = elements.map((/**
     * @param {?} q
     * @return {?}
     */
    q => q.value.raw));
    return ɵmakeTemplateObject(cooked, raw);
}
/**
 * Wrap the given `expression` in parentheses if it is a binary expression.
 *
 * This ensures that this expression is evaluated correctly if it is embedded in another expression.
 *
 * @param {?} expression The expression to potentially wrap.
 * @return {?}
 */
export function wrapInParensIfNecessary(expression) {
    if (t.isBinaryExpression(expression)) {
        return t.parenthesizedExpression(expression);
    }
    else {
        return expression;
    }
}
/**
 * Extract the string values from an `array` of string literals.
 * @param {?} array The array to unwrap.
 * @return {?}
 */
export function unwrapStringLiteralArray(array) {
    if (!isStringLiteralArray(array)) {
        throw new BabelParseError(array, 'Unexpected messageParts for `$localize` (expected an array of strings).');
    }
    return array.elements.map((/**
     * @param {?} str
     * @return {?}
     */
    (str) => str.value));
}
/**
 * This expression is believed to be a call to a "lazy-load" template object helper function.
 * This is expected to be of the form:
 *
 * ```ts
 *  function _templateObject() {
 *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);
 *    return _templateObject = function() { return e }, e
 *  }
 * ```
 *
 * We unwrap this to return the call to `_taggedTemplateLiteral()`.
 *
 * @param {?} call the call expression to unwrap
 * @return {?} the  call expression
 */
export function unwrapLazyLoadHelperCall(call) {
    /** @type {?} */
    const callee = (/** @type {?} */ (call.get('callee')));
    if (!callee.isIdentifier()) {
        throw new BabelParseError(callee.node, 'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).');
    }
    /** @type {?} */
    const lazyLoadBinding = call.scope.getBinding(callee.node.name);
    if (!lazyLoadBinding) {
        throw new BabelParseError(callee.node, 'Missing declaration for lazy-load helper function');
    }
    /** @type {?} */
    const lazyLoadFn = lazyLoadBinding.path;
    if (!lazyLoadFn.isFunctionDeclaration()) {
        throw new BabelParseError(((/** @type {?} */ (lazyLoadFn))).node, 'Unexpected expression (expected a function declaration');
    }
    /** @type {?} */
    const returnedNode = getReturnedExpression(lazyLoadFn);
    if (returnedNode.isCallExpression()) {
        return returnedNode;
    }
    if (returnedNode.isIdentifier()) {
        /** @type {?} */
        const identifierName = returnedNode.node.name;
        /** @type {?} */
        const declaration = returnedNode.scope.getBinding(identifierName);
        if (declaration === undefined) {
            throw new BabelParseError(returnedNode.node, 'Missing declaration for return value from helper.');
        }
        if (!declaration.path.isVariableDeclarator()) {
            throw new BabelParseError(((/** @type {?} */ (declaration))).path.node, 'Unexpected helper return value declaration (expected a variable declaration).');
        }
        /** @type {?} */
        const initializer = declaration.path.get('init');
        if (!initializer.isCallExpression()) {
            throw new BabelParseError(declaration.path.node, 'Unexpected return value from helper (expected a call expression).');
        }
        // Remove the lazy load helper if this is the only reference to it.
        if (lazyLoadBinding.references === 1) {
            lazyLoadFn.remove();
        }
        return initializer;
    }
    return call;
}
/**
 * @param {?} fn
 * @return {?}
 */
function getReturnedExpression(fn) {
    /** @type {?} */
    const bodyStatements = ((/** @type {?} */ (fn.get('body')))).get('body');
    for (const statement of bodyStatements) {
        if (statement.isReturnStatement()) {
            /** @type {?} */
            const argument = statement.get('argument');
            if (argument.isSequenceExpression()) {
                /** @type {?} */
                const expressions = argument.get('expressions');
                return Array.isArray(expressions)
                    ? expressions[expressions.length - 1]
                    : expressions;
            }
            else if (argument.isExpression()) {
                return argument;
            }
            else {
                throw new BabelParseError(statement.node, 'Invalid return argument in helper function (expected an expression).');
            }
        }
    }
    throw new BabelParseError(fn.node, 'Missing return statement in helper function.');
}
/**
 * Is the given `node` an array of literal strings?
 *
 * @param {?} node The node to test.
 * @return {?}
 */
export function isStringLiteralArray(node) {
    return (t.isArrayExpression(node) &&
        node.elements.every((/**
         * @param {?} element
         * @return {?}
         */
        element => t.isStringLiteral(element))));
}
/**
 * Are all the given `nodes` expressions?
 * @param {?} nodes The nodes to test.
 * @return {?}
 */
export function isArrayOfExpressions(nodes) {
    return nodes.every((/**
     * @param {?} element
     * @return {?}
     */
    element => t.isExpression(element)));
}
/**
 * Options that affect how the `makeEsXXXTranslatePlugin()` functions work.
 * @record
 */
export function TranslatePluginOptions() { }
if (false) {
    /** @type {?|undefined} */
    TranslatePluginOptions.prototype.missingTranslation;
    /** @type {?|undefined} */
    TranslatePluginOptions.prototype.localizeName;
}
/**
 * Translate the text of the given message, using the given translations.
 *
 * Logs as warning if the translation is not available
 * @param {?} diagnostics
 * @param {?} translations
 * @param {?} messageParts
 * @param {?} substitutions
 * @param {?} missingTranslation
 * @return {?}
 */
export function translate(diagnostics, translations, messageParts, substitutions, missingTranslation) {
    try {
        return ɵtranslate(translations, messageParts, substitutions);
    }
    catch (e) {
        if (ɵisMissingTranslationError(e)) {
            if (missingTranslation === 'error') {
                diagnostics.error(e.message);
            }
            else if (missingTranslation === 'warning') {
                diagnostics.warn(e.message);
            }
            // Return the parsed message because this will have the meta blocks stripped
            return [
                ɵmakeTemplateObject(e.parsedMessage.messageParts, e.parsedMessage.messageParts),
                substitutions
            ];
        }
        else {
            diagnostics.error(e.message);
            return [messageParts, substitutions];
        }
    }
}
export class BabelParseError extends Error {
    /**
     * @param {?} node
     * @param {?} message
     */
    constructor(node, message) {
        super(message);
        this.node = node;
        this.type = 'BabelParseError';
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    BabelParseError.prototype.type;
    /** @type {?} */
    BabelParseError.prototype.node;
}
/**
 * @param {?} e
 * @return {?}
 */
export function isBabelParseError(e) {
    return e.type === 'BabelParseError';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic291cmNlX2ZpbGVfdXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbG9jbC9jbGkvIiwic291cmNlcyI6WyJjbWRzL2V4dHJhY3Qvc291cmNlX2ZpbGVfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBT0EsT0FBTyxFQUVMLDBCQUEwQixFQUMxQixtQkFBbUIsRUFDbkIsVUFBVSxFQUNYLE1BQU0sbUJBQW1CLENBQUM7QUFFM0IsT0FBTyxLQUFLLENBQUMsTUFBTSxjQUFjLENBQUM7Ozs7Ozs7QUFRbEMsTUFBTSxVQUFVLGlCQUFpQixDQUMvQixVQUFvQixFQUNwQixJQUFZO0lBRVosT0FBTyxVQUFVLENBQUMsWUFBWSxFQUFFLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDO0FBQ3BFLENBQUM7Ozs7OztBQU1ELE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxVQUFrQztJQUNuRSxPQUFPLENBQ0wsQ0FBQyxVQUFVLENBQUMsS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDeEUsQ0FBQztBQUNKLENBQUM7Ozs7Ozs7QUFPRCxNQUFNLFVBQVUsd0JBQXdCLENBQ3RDLFlBQWtDLEVBQ2xDLGFBQXNDOztRQUVsQyxZQUFZLEdBQWlCLENBQUMsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzVDLFlBQVksR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQy9CLEdBQUcsRUFDSCxZQUFZLEVBQ1osdUJBQXVCLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUM5QyxDQUFDO1FBQ0YsWUFBWSxHQUFHLENBQUMsQ0FB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QU8sQ0FBQyxDQUFDLElBQUksS0FBSyxpQkFBaUIsQ0FBQztBQUN0QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHtcbiAgybVQYXJzZWRUcmFuc2xhdGlvbixcbiAgybVpc01pc3NpbmdUcmFuc2xhdGlvbkVycm9yLFxuICDJtW1ha2VUZW1wbGF0ZU9iamVjdCxcbiAgybV0cmFuc2xhdGVcbn0gZnJvbSAnQGFuZ3VsYXIvbG9jYWxpemUnO1xuaW1wb3J0IHsgTm9kZVBhdGggfSBmcm9tICdAYmFiZWwvdHJhdmVyc2UnO1xuaW1wb3J0ICogYXMgdCBmcm9tICdAYmFiZWwvdHlwZXMnO1xuaW1wb3J0IHsgUGFyc2VkVHJhbnNsYXRpb24gfSBmcm9tICdAYW5ndWxhci9sb2NhbGl6ZS9zcmMvdXRpbHMnO1xuaW1wb3J0IHsgRGlhZ25vc3RpY3MgfSBmcm9tICcuLi9jb21tb24vZGlhZ25vc3RpY3MnO1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBgZXhwcmVzc2lvbmAgYW4gaWRlbnRpZmllciB3aXRoIHRoZSBjb3JyZWN0IG5hbWVcbiAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIGNoZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lZElkZW50aWZpZXIoXG4gIGV4cHJlc3Npb246IE5vZGVQYXRoLFxuICBuYW1lOiBzdHJpbmdcbik6IGV4cHJlc3Npb24gaXMgTm9kZVBhdGgge1xuICByZXR1cm4gZXhwcmVzc2lvbi5pc0lkZW50aWZpZXIoKSAmJiBleHByZXNzaW9uLm5vZGUubmFtZSA9PT0gbmFtZTtcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gYGlkZW50aWZpZXJgIGRlY2xhcmVkIGdsb2JhbGx5LlxuICogQHBhcmFtIGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0dsb2JhbElkZW50aWZpZXIoaWRlbnRpZmllcjogTm9kZVBhdGg8dC5JZGVudGlmaWVyPikge1xuICByZXR1cm4gKFxuICAgICFpZGVudGlmaWVyLnNjb3BlIHx8ICFpZGVudGlmaWVyLnNjb3BlLmhhc0JpbmRpbmcoaWRlbnRpZmllci5ub2RlLm5hbWUpXG4gICk7XG59XG5cbi8qKlxuICogQnVpbGQgYSB0cmFuc2xhdGVkIGV4cHJlc3Npb24gdG8gcmVwbGFjZSB0aGUgY2FsbCB0byBgJGxvY2FsaXplYC5cbiAqIEBwYXJhbSBtZXNzYWdlUGFydHMgVGhlIHN0YXRpYyBwYXJ0cyBvZiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSBzdWJzdGl0dXRpb25zIFRoZSBleHByZXNzaW9ucyB0byBzdWJzdGl0dXRlIGludG8gdGhlIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExvY2FsaXplUmVwbGFjZW1lbnQoXG4gIG1lc3NhZ2VQYXJ0czogVGVtcGxhdGVTdHJpbmdzQXJyYXksXG4gIHN1YnN0aXR1dGlvbnM6IHJlYWRvbmx5IHQuRXhwcmVzc2lvbltdXG4pOiB0LkV4cHJlc3Npb24ge1xuICBsZXQgbWFwcGVkU3RyaW5nOiB0LkV4cHJlc3Npb24gPSB0LnN0cmluZ0xpdGVyYWwobWVzc2FnZVBhcnRzWzBdKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBtZXNzYWdlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBwZWRTdHJpbmcgPSB0LmJpbmFyeUV4cHJlc3Npb24oXG4gICAgICAnKycsXG4gICAgICBtYXBwZWRTdHJpbmcsXG4gICAgICB3cmFwSW5QYXJlbnNJZk5lY2Vzc2FyeShzdWJzdGl0dXRpb25zW2kgLSAxXSlcbiAgICApO1xuICAgIG1hcHBlZFN0cmluZyA9IHQuYmluYXJ5RXhwcmVzc2lvbihcbiAgICAgICcrJyxcbiAgICAgIG1hcHBlZFN0cmluZyxcbiAgICAgIHQuc3RyaW5nTGl0ZXJhbChtZXNzYWdlUGFydHNbaV0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWFwcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIG1lc3NhZ2UgcGFydHMgZnJvbSB0aGUgZ2l2ZW4gYGNhbGxgICh0byBgJGxvY2FsaXplYCkuXG4gKlxuICogVGhlIG1lc3NhZ2UgcGFydHMgd2lsbCBlaXRoZXIgYnkgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBgY2FsbGAgb3IgaXQgd2lsbCBiZSB3cmFwcGVkIGluIGNhbGxcbiAqIHRvIGEgaGVscGVyIGZ1bmN0aW9uIGxpa2UgYF9fbWFrZVRlbXBsYXRlT2JqZWN0YC5cbiAqXG4gKiBAcGFyYW0gY2FsbCBUaGUgQVNUIG5vZGUgb2YgdGhlIGNhbGwgdG8gcHJvY2Vzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE1lc3NhZ2VQYXJ0c0Zyb21Mb2NhbGl6ZUNhbGwoXG4gIGNhbGw6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+XG4pOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSB7XG4gIGxldCBjb29rZWQgPSBjYWxsLmdldCgnYXJndW1lbnRzJylbMF0gYXMgYW55O1xuXG4gIGlmIChjb29rZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICBjYWxsLm5vZGUsXG4gICAgICAnYCRsb2NhbGl6ZWAgY2FsbGVkIHdpdGhvdXQgYW55IGFyZ3VtZW50cy4nXG4gICAgKTtcbiAgfVxuICBpZiAoIWNvb2tlZC5pc0V4cHJlc3Npb24oKSkge1xuICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICBjb29rZWQubm9kZSxcbiAgICAgICdVbmV4cGVjdGVkIGFyZ3VtZW50IHRvIGAkbG9jYWxpemVgIChleHBlY3RlZCBhbiBhcnJheSkuJ1xuICAgICk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBubyBjYWxsIHRvIGBfX21ha2VUZW1wbGF0ZU9iamVjdCguLi4pYCwgdGhlbiBgcmF3YCBtdXN0IGJlIHRoZSBzYW1lIGFzIGBjb29rZWRgLlxuICBsZXQgcmF3ID0gY29va2VkO1xuXG4gIC8vIENoZWNrIGZvciBjYWNoZWQgY2FsbCBvZiB0aGUgZm9ybSBgeCB8fCB4ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoLi4uKWBcbiAgaWYgKFxuICAgIGNvb2tlZC5pc0xvZ2ljYWxFeHByZXNzaW9uKCkgJiZcbiAgICBjb29rZWQubm9kZS5vcGVyYXRvciA9PT0gJ3x8JyAmJlxuICAgIGNvb2tlZC5nZXQoJ2xlZnQnKS5pc0lkZW50aWZpZXIoKVxuICApIHtcbiAgICBjb25zdCByaWdodCA9IGNvb2tlZC5nZXQoJ3JpZ2h0Jyk7XG4gICAgaWYgKHJpZ2h0LmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSkge1xuICAgICAgY29va2VkID0gcmlnaHQuZ2V0KCdyaWdodCcpO1xuICAgICAgaWYgKCFjb29rZWQuaXNFeHByZXNzaW9uKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJhYmVsUGFyc2VFcnJvcihcbiAgICAgICAgICBjb29rZWQubm9kZSxcbiAgICAgICAgICAnVW5leHBlY3RlZCBcIm1ha2VUZW1wbGF0ZU9iamVjdCgpXCIgZnVuY3Rpb24gKGV4cGVjdGVkIGFuIGV4cHJlc3Npb24pLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmb3IgYF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KWAgb3IgYF9fdGVtcGxhdGVPYmplY3QoKWAgY2FsbHMuXG4gIGlmIChjb29rZWQuaXNDYWxsRXhwcmVzc2lvbigpKSB7XG4gICAgbGV0IGNvb2tlZENhbGwgPSBjb29rZWQ7XG4gICAgaWYgKGNvb2tlZENhbGwuZ2V0KCdhcmd1bWVudHMnKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIGFyZ3VtZW50cyBzbyBwZXJoYXBzIGl0IGlzIGEgYF9fdGVtcGxhdGVPYmplY3QoKWAgY2FsbC5cbiAgICAgIC8vIFVud3JhcCB0aGlzIHRvIGdldCB0aGUgYF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoY29va2VkLCByYXcpYCBjYWxsLlxuICAgICAgY29va2VkQ2FsbCA9IHVud3JhcExhenlMb2FkSGVscGVyQ2FsbChjb29rZWRDYWxsKTtcbiAgICB9XG5cbiAgICBjb29rZWQgPSBjb29rZWRDYWxsLmdldCgnYXJndW1lbnRzJylbMF07XG4gICAgaWYgKCFjb29rZWQuaXNFeHByZXNzaW9uKCkpIHtcbiAgICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICAgIGNvb2tlZC5ub2RlLFxuICAgICAgICAnVW5leHBlY3RlZCBgY29va2VkYCBhcmd1bWVudCB0byB0aGUgXCJtYWtlVGVtcGxhdGVPYmplY3QoKVwiIGZ1bmN0aW9uIChleHBlY3RlZCBhbiBleHByZXNzaW9uKS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhcmcyID0gY29va2VkQ2FsbC5nZXQoJ2FyZ3VtZW50cycpWzFdO1xuICAgIGlmIChhcmcyICYmICFhcmcyLmlzRXhwcmVzc2lvbigpKSB7XG4gICAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgICBhcmcyLm5vZGUsXG4gICAgICAgICdVbmV4cGVjdGVkIGByYXdgIGFyZ3VtZW50IHRvIHRoZSBcIm1ha2VUZW1wbGF0ZU9iamVjdCgpXCIgZnVuY3Rpb24gKGV4cGVjdGVkIGFuIGV4cHJlc3Npb24pLidcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHNlY29uZCBhcmd1bWVudCB0aGVuIGFzc3VtZSB0aGF0IHJhdyBhbmQgY29va2VkIGFyZSB0aGUgc2FtZVxuICAgIHJhdyA9IGFyZzIgIT09IHVuZGVmaW5lZCA/IGFyZzIgOiBjb29rZWQ7XG4gIH1cblxuICBjb25zdCBjb29rZWRTdHJpbmdzID0gdW53cmFwU3RyaW5nTGl0ZXJhbEFycmF5KGNvb2tlZC5ub2RlKTtcbiAgY29uc3QgcmF3U3RyaW5ncyA9IHVud3JhcFN0cmluZ0xpdGVyYWxBcnJheShyYXcubm9kZSk7XG4gIHJldHVybiDJtW1ha2VUZW1wbGF0ZU9iamVjdChjb29rZWRTdHJpbmdzLCByYXdTdHJpbmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFN1YnN0aXR1dGlvbnNGcm9tTG9jYWxpemVDYWxsKFxuICBjYWxsOiB0LkNhbGxFeHByZXNzaW9uXG4pOiB0LkV4cHJlc3Npb25bXSB7XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gY2FsbC5hcmd1bWVudHMuc3BsaWNlKDEpO1xuICBpZiAoIWlzQXJyYXlPZkV4cHJlc3Npb25zKGV4cHJlc3Npb25zKSkge1xuICAgIGNvbnN0IGJhZEV4cHJlc3Npb24gPSBleHByZXNzaW9ucy5maW5kKFxuICAgICAgZXhwcmVzc2lvbiA9PiAhdC5pc0V4cHJlc3Npb24oZXhwcmVzc2lvbilcbiAgICApITtcbiAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgYmFkRXhwcmVzc2lvbixcbiAgICAgICdJbnZhbGlkIHN1YnN0aXR1dGlvbnMgZm9yIGAkbG9jYWxpemVgIChleHBlY3RlZCBhbGwgc3Vic3RpdHV0aW9uIGFyZ3VtZW50cyB0byBiZSBleHByZXNzaW9ucykuJ1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIGV4cHJlc3Npb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwTWVzc2FnZVBhcnRzRnJvbVRlbXBsYXRlTGl0ZXJhbChcbiAgZWxlbWVudHM6IHQuVGVtcGxhdGVFbGVtZW50W11cbik6IFRlbXBsYXRlU3RyaW5nc0FycmF5IHtcbiAgY29uc3QgY29va2VkID0gZWxlbWVudHMubWFwKHEgPT4ge1xuICAgIGlmIChxLnZhbHVlLmNvb2tlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgICBxLFxuICAgICAgICBgVW5leHBlY3RlZCB1bmRlZmluZWQgbWVzc2FnZSBwYXJ0IGluIFwiJHtlbGVtZW50cy5tYXAoXG4gICAgICAgICAgZXEgPT4gZXEudmFsdWUuY29va2VkXG4gICAgICAgICl9XCJgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcS52YWx1ZS5jb29rZWQ7XG4gIH0pO1xuICBjb25zdCByYXcgPSBlbGVtZW50cy5tYXAocSA9PiBxLnZhbHVlLnJhdyk7XG4gIHJldHVybiDJtW1ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdyk7XG59XG5cbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGluIHBhcmVudGhlc2VzIGlmIGl0IGlzIGEgYmluYXJ5IGV4cHJlc3Npb24uXG4gKlxuICogVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBleHByZXNzaW9uIGlzIGV2YWx1YXRlZCBjb3JyZWN0bHkgaWYgaXQgaXMgZW1iZWRkZWQgaW4gYW5vdGhlciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBvdGVudGlhbGx5IHdyYXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwSW5QYXJlbnNJZk5lY2Vzc2FyeShcbiAgZXhwcmVzc2lvbjogdC5FeHByZXNzaW9uXG4pOiB0LkV4cHJlc3Npb24ge1xuICBpZiAodC5pc0JpbmFyeUV4cHJlc3Npb24oZXhwcmVzc2lvbikpIHtcbiAgICByZXR1cm4gdC5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHN0cmluZyB2YWx1ZXMgZnJvbSBhbiBgYXJyYXlgIG9mIHN0cmluZyBsaXRlcmFscy5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gdW53cmFwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwU3RyaW5nTGl0ZXJhbEFycmF5KGFycmF5OiB0LkV4cHJlc3Npb24pOiBzdHJpbmdbXSB7XG4gIGlmICghaXNTdHJpbmdMaXRlcmFsQXJyYXkoYXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEJhYmVsUGFyc2VFcnJvcihcbiAgICAgIGFycmF5LFxuICAgICAgJ1VuZXhwZWN0ZWQgbWVzc2FnZVBhcnRzIGZvciBgJGxvY2FsaXplYCAoZXhwZWN0ZWQgYW4gYXJyYXkgb2Ygc3RyaW5ncykuJ1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LmVsZW1lbnRzLm1hcCgoc3RyOiB0LlN0cmluZ0xpdGVyYWwpID0+IHN0ci52YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBleHByZXNzaW9uIGlzIGJlbGlldmVkIHRvIGJlIGEgY2FsbCB0byBhIFwibGF6eS1sb2FkXCIgdGVtcGxhdGUgb2JqZWN0IGhlbHBlciBmdW5jdGlvbi5cbiAqIFRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdGhlIGZvcm06XG4gKlxuICogYGBgdHNcbiAqICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gKiAgICB2YXIgZSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoWydjb29rZWQgc3RyaW5nJywgJ3JhdyBzdHJpbmcnXSk7XG4gKiAgICByZXR1cm4gX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBlIH0sIGVcbiAqICB9XG4gKiBgYGBcbiAqXG4gKiBXZSB1bndyYXAgdGhpcyB0byByZXR1cm4gdGhlIGNhbGwgdG8gYF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoKWAuXG4gKlxuICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgZXhwcmVzc2lvbiB0byB1bndyYXBcbiAqIEByZXR1cm5zIHRoZSAgY2FsbCBleHByZXNzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBMYXp5TG9hZEhlbHBlckNhbGwoXG4gIGNhbGw6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+XG4pOiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPiB7XG4gIGNvbnN0IGNhbGxlZSA9IGNhbGwuZ2V0KCdjYWxsZWUnKSBhcyBhbnk7XG4gIGlmICghY2FsbGVlLmlzSWRlbnRpZmllcigpKSB7XG4gICAgdGhyb3cgbmV3IEJhYmVsUGFyc2VFcnJvcihcbiAgICAgIGNhbGxlZS5ub2RlLFxuICAgICAgJ1VuZXhwZWN0ZWQgbGF6eS1sb2FkIGhlbHBlciBjYWxsIChleHBlY3RlZCBhIGNhbGwgb2YgdGhlIGZvcm0gYF90ZW1wbGF0ZU9iamVjdCgpYCkuJ1xuICAgICk7XG4gIH1cbiAgY29uc3QgbGF6eUxvYWRCaW5kaW5nID0gY2FsbC5zY29wZS5nZXRCaW5kaW5nKGNhbGxlZS5ub2RlLm5hbWUpO1xuICBpZiAoIWxhenlMb2FkQmluZGluZykge1xuICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICBjYWxsZWUubm9kZSxcbiAgICAgICdNaXNzaW5nIGRlY2xhcmF0aW9uIGZvciBsYXp5LWxvYWQgaGVscGVyIGZ1bmN0aW9uJ1xuICAgICk7XG4gIH1cbiAgY29uc3QgbGF6eUxvYWRGbiA9IGxhenlMb2FkQmluZGluZy5wYXRoO1xuICBpZiAoIWxhenlMb2FkRm4uaXNGdW5jdGlvbkRlY2xhcmF0aW9uKCkpIHtcbiAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgKGxhenlMb2FkRm4gYXMgYW55KS5ub2RlLFxuICAgICAgJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbiAoZXhwZWN0ZWQgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbidcbiAgICApO1xuICB9XG4gIGNvbnN0IHJldHVybmVkTm9kZSA9IGdldFJldHVybmVkRXhwcmVzc2lvbihsYXp5TG9hZEZuKTtcblxuICBpZiAocmV0dXJuZWROb2RlLmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiByZXR1cm5lZE5vZGU7XG4gIH1cblxuICBpZiAocmV0dXJuZWROb2RlLmlzSWRlbnRpZmllcigpKSB7XG4gICAgY29uc3QgaWRlbnRpZmllck5hbWUgPSByZXR1cm5lZE5vZGUubm9kZS5uYW1lO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gcmV0dXJuZWROb2RlLnNjb3BlLmdldEJpbmRpbmcoaWRlbnRpZmllck5hbWUpO1xuICAgIGlmIChkZWNsYXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgICAgICByZXR1cm5lZE5vZGUubm9kZSxcbiAgICAgICAgJ01pc3NpbmcgZGVjbGFyYXRpb24gZm9yIHJldHVybiB2YWx1ZSBmcm9tIGhlbHBlci4nXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWRlY2xhcmF0aW9uLnBhdGguaXNWYXJpYWJsZURlY2xhcmF0b3IoKSkge1xuICAgICAgdGhyb3cgbmV3IEJhYmVsUGFyc2VFcnJvcihcbiAgICAgICAgKGRlY2xhcmF0aW9uIGFzIGFueSkucGF0aC5ub2RlLFxuICAgICAgICAnVW5leHBlY3RlZCBoZWxwZXIgcmV0dXJuIHZhbHVlIGRlY2xhcmF0aW9uIChleHBlY3RlZCBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uKS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsaXplciA9IGRlY2xhcmF0aW9uLnBhdGguZ2V0KCdpbml0Jyk7XG4gICAgaWYgKCFpbml0aWFsaXplci5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICAgIGRlY2xhcmF0aW9uLnBhdGgubm9kZSxcbiAgICAgICAgJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gaGVscGVyIChleHBlY3RlZCBhIGNhbGwgZXhwcmVzc2lvbikuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIGxhenkgbG9hZCBoZWxwZXIgaWYgdGhpcyBpcyB0aGUgb25seSByZWZlcmVuY2UgdG8gaXQuXG4gICAgaWYgKGxhenlMb2FkQmluZGluZy5yZWZlcmVuY2VzID09PSAxKSB7XG4gICAgICBsYXp5TG9hZEZuLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsaXplcjtcbiAgfVxuICByZXR1cm4gY2FsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UmV0dXJuZWRFeHByZXNzaW9uKFxuICBmbjogTm9kZVBhdGg8dC5GdW5jdGlvbkRlY2xhcmF0aW9uPlxuKTogTm9kZVBhdGg8dC5FeHByZXNzaW9uPiB7XG4gIGNvbnN0IGJvZHlTdGF0ZW1lbnRzID0gKGZuLmdldCgnYm9keScpIGFzIGFueSkuZ2V0KCdib2R5Jyk7XG4gIGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIGJvZHlTdGF0ZW1lbnRzKSB7XG4gICAgaWYgKHN0YXRlbWVudC5pc1JldHVyblN0YXRlbWVudCgpKSB7XG4gICAgICBjb25zdCBhcmd1bWVudCA9IHN0YXRlbWVudC5nZXQoJ2FyZ3VtZW50Jyk7XG4gICAgICBpZiAoYXJndW1lbnQuaXNTZXF1ZW5jZUV4cHJlc3Npb24oKSkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IGFyZ3VtZW50LmdldCgnZXhwcmVzc2lvbnMnKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbnMpXG4gICAgICAgICAgPyBleHByZXNzaW9uc1tleHByZXNzaW9ucy5sZW5ndGggLSAxXVxuICAgICAgICAgIDogZXhwcmVzc2lvbnM7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50LmlzRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCYWJlbFBhcnNlRXJyb3IoXG4gICAgICAgICAgc3RhdGVtZW50Lm5vZGUsXG4gICAgICAgICAgJ0ludmFsaWQgcmV0dXJuIGFyZ3VtZW50IGluIGhlbHBlciBmdW5jdGlvbiAoZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbikuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgQmFiZWxQYXJzZUVycm9yKFxuICAgIGZuLm5vZGUsXG4gICAgJ01pc3NpbmcgcmV0dXJuIHN0YXRlbWVudCBpbiBoZWxwZXIgZnVuY3Rpb24uJ1xuICApO1xufVxuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBgbm9kZWAgYW4gYXJyYXkgb2YgbGl0ZXJhbCBzdHJpbmdzP1xuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHRlc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWxBcnJheShcbiAgbm9kZTogdC5Ob2RlXG4pOiBub2RlIGlzIHQuRXhwcmVzc2lvbiAmIHsgZWxlbWVudHM6IHQuU3RyaW5nTGl0ZXJhbFtdIH0ge1xuICByZXR1cm4gKFxuICAgIHQuaXNBcnJheUV4cHJlc3Npb24obm9kZSkgJiZcbiAgICBub2RlLmVsZW1lbnRzLmV2ZXJ5KGVsZW1lbnQgPT4gdC5pc1N0cmluZ0xpdGVyYWwoZWxlbWVudCkpXG4gICk7XG59XG5cbi8qKlxuICogQXJlIGFsbCB0aGUgZ2l2ZW4gYG5vZGVzYCBleHByZXNzaW9ucz9cbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZXMgdG8gdGVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlPZkV4cHJlc3Npb25zKG5vZGVzOiB0Lk5vZGVbXSk6IG5vZGVzIGlzIHQuRXhwcmVzc2lvbltdIHtcbiAgcmV0dXJuIG5vZGVzLmV2ZXJ5KGVsZW1lbnQgPT4gdC5pc0V4cHJlc3Npb24oZWxlbWVudCkpO1xufVxuXG4vKiogT3B0aW9ucyB0aGF0IGFmZmVjdCBob3cgdGhlIGBtYWtlRXNYWFhUcmFuc2xhdGVQbHVnaW4oKWAgZnVuY3Rpb25zIHdvcmsuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0ZVBsdWdpbk9wdGlvbnMge1xuICBtaXNzaW5nVHJhbnNsYXRpb24/OiBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneTtcbiAgbG9jYWxpemVOYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEhvdyB0byBoYW5kbGUgbWlzc2luZyB0cmFuc2xhdGlvbnMuXG4gKi9cbmV4cG9ydCB0eXBlIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gJ2Vycm9yJyB8ICd3YXJuaW5nJyB8ICdpZ25vcmUnO1xuXG4vKipcbiAqIFRyYW5zbGF0ZSB0aGUgdGV4dCBvZiB0aGUgZ2l2ZW4gbWVzc2FnZSwgdXNpbmcgdGhlIGdpdmVuIHRyYW5zbGF0aW9ucy5cbiAqXG4gKiBMb2dzIGFzIHdhcm5pbmcgaWYgdGhlIHRyYW5zbGF0aW9uIGlzIG5vdCBhdmFpbGFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShcbiAgZGlhZ25vc3RpY3M6IERpYWdub3N0aWNzLFxuICB0cmFuc2xhdGlvbnM6IFJlY29yZDxzdHJpbmcsIMm1UGFyc2VkVHJhbnNsYXRpb24+LFxuICBtZXNzYWdlUGFydHM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LFxuICBzdWJzdGl0dXRpb25zOiByZWFkb25seSBhbnlbXSxcbiAgbWlzc2luZ1RyYW5zbGF0aW9uOiBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVxuKTogW1RlbXBsYXRlU3RyaW5nc0FycmF5LCByZWFkb25seSBhbnlbXV0ge1xuICB0cnkge1xuICAgIHJldHVybiDJtXRyYW5zbGF0ZSh0cmFuc2xhdGlvbnMsIG1lc3NhZ2VQYXJ0cywgc3Vic3RpdHV0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoybVpc01pc3NpbmdUcmFuc2xhdGlvbkVycm9yKGUpKSB7XG4gICAgICBpZiAobWlzc2luZ1RyYW5zbGF0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgIGRpYWdub3N0aWNzLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKG1pc3NpbmdUcmFuc2xhdGlvbiA9PT0gJ3dhcm5pbmcnKSB7XG4gICAgICAgIGRpYWdub3N0aWNzLndhcm4oZS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIC8vIFJldHVybiB0aGUgcGFyc2VkIG1lc3NhZ2UgYmVjYXVzZSB0aGlzIHdpbGwgaGF2ZSB0aGUgbWV0YSBibG9ja3Mgc3RyaXBwZWRcbiAgICAgIHJldHVybiBbXG4gICAgICAgIMm1bWFrZVRlbXBsYXRlT2JqZWN0KFxuICAgICAgICAgIGUucGFyc2VkTWVzc2FnZS5tZXNzYWdlUGFydHMsXG4gICAgICAgICAgZS5wYXJzZWRNZXNzYWdlLm1lc3NhZ2VQYXJ0c1xuICAgICAgICApLFxuICAgICAgICBzdWJzdGl0dXRpb25zXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWFnbm9zdGljcy5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIFttZXNzYWdlUGFydHMsIHN1YnN0aXR1dGlvbnNdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFiZWxQYXJzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IHR5cGUgPSAnQmFiZWxQYXJzZUVycm9yJztcbiAgY29uc3RydWN0b3IocHVibGljIG5vZGU6IHQuTm9kZSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFiZWxQYXJzZUVycm9yKGU6IGFueSk6IGUgaXMgQmFiZWxQYXJzZUVycm9yIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ0JhYmVsUGFyc2VFcnJvcic7XG59XG4iXX0=