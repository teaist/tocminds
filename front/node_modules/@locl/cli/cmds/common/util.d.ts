import { TranslationSerializer } from '../extract/translation_files/translation_serializer';
import { ɵMessageId, ɵParsedMessage } from '@angular/localize';
import { ParsedTranslation } from '../convert/translations';
export declare type TranslationFormat = 'json' | 'xmb' | 'xliff1' | 'xliff2' | 'xlf' | 'xlf2' | 'xtb';
export declare function getTranslationSerializer(format: TranslationFormat): TranslationSerializer;
export declare function getExtension(format: TranslationFormat): string;
/**
 * The character used to mark the start and end of a "block" in a `$localize` tagged string.
 * A block can indicate metadata about the message or specify a name of a placeholder for a
 * substitution expressions.
 *
 * For example:
 *
 * ```ts
 * $localize`Hello, ${title}:title:!`;
 * $localize`:meaning|description@@id:source message text`;
 * ```
 */
export declare const BLOCK_MARKER = ":";
/**
 * Find the end of a "marked block" indicated by the first non-escaped colon.
 *
 * @param cooked The cooked string (where escaped chars have been processed)
 * @param raw The raw string (where escape sequences are still in place)
 *
 * @returns the index of the end of block marker
 * @throws an error if the block is unterminated
 */
export declare function findEndOfBlock(cooked: string, raw: string): number;
/**
 * Split a message part (`cooked` + `raw`) into an optional delimited "block" off the front and the
 * rest of the text of the message part.
 *
 * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the
 * start and end of the block.
 *
 * If the block is in the first message part then it will be metadata about the whole message:
 * meaning, description, id.  Otherwise it will be metadata about the immediately preceding
 * substitution: placeholder name.
 *
 * Since blocks are optional, it is possible that the content of a message block actually starts
 * with a block marker. In this case the marker must be escaped `\:`.
 *
 * @param cooked The cooked version of the message part to parse.
 * @param raw The raw version of the message part to parse.
 * @returns An object containing the `text` of the message part and the text of the `block`, if it
 * exists.
 * @throws an error if the `block` is unterminated
 */
export declare function splitBlock(cooked: string, raw: string): {
    text: string;
    block?: string;
};
export declare function translationToMessage(id: string, translation: ParsedTranslation): ɵParsedMessage;
export interface ParsedMessageLegacy {
    /**
     * The key used to look up the appropriate translation target.
     */
    messageId: ɵMessageId;
    /**
     * Legacy message ids, if provided.
     *
     * In legacy message formats the message id can only be computed directly from the original
     * template source.
     *
     * Since this information is not available in `$localize` calls, the legacy message ids may be
     * attached by the compiler to the `$localize` metablock so it can be used if needed at the point
     * of translation if the translations are encoded using the legacy message id.
     */
    legacyIds: ɵMessageId[];
    /**
     * A mapping of placeholder names to substitution values.
     */
    substitutions: Record<string, any>;
    /**
     * A human readable rendering of the message
     */
    messageString: string;
    /**
     * The meaning of the `message`, used to distinguish identical `messageString`s.
     */
    meaning: string;
    /**
     * The description of the `message`, used to aid translation.
     */
    description: string;
    /**
     * The static parts of the message.
     */
    messageParts: string[];
    /**
     * The names of the placeholders that will be replaced with substitutions.
     */
    placeholderNames: string[];
}
