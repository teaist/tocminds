"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_translation_serializer_1 = require("../extract/translation_files/json_translation_serializer");
const xliff1_translation_serializer_1 = require("../extract/translation_files/xliff1_translation_serializer");
const xliff2_translation_serializer_1 = require("../extract/translation_files/xliff2_translation_serializer");
const xmb_translation_serializer_1 = require("../extract/translation_files/xmb_translation_serializer");
const xtb_translation_serializer_1 = require("../extract/translation_files/xtb_translation_serializer");
function getTranslationSerializer(format) {
    switch (format) {
        case 'json':
            return new json_translation_serializer_1.JsonTranslationSerializer();
        case 'xliff1':
        case 'xlf':
            return new xliff1_translation_serializer_1.Xliff1TranslationSerializer();
        case 'xliff2':
        case 'xlf2':
            return new xliff2_translation_serializer_1.Xliff2TranslationSerializer();
        case 'xmb':
            return new xmb_translation_serializer_1.XmbTranslationSerializer();
        case 'xtb':
            return new xtb_translation_serializer_1.XtbTranslationSerializer();
    }
}
exports.getTranslationSerializer = getTranslationSerializer;
function getExtension(format) {
    switch (format) {
        case 'json':
        case 'xmb':
        case 'xtb':
            return format;
        default:
            return 'xlf';
    }
}
exports.getExtension = getExtension;
/**
 * The character used to mark the start and end of a "block" in a `$localize` tagged string.
 * A block can indicate metadata about the message or specify a name of a placeholder for a
 * substitution expressions.
 *
 * For example:
 *
 * ```ts
 * $localize`Hello, ${title}:title:!`;
 * $localize`:meaning|description@@id:source message text`;
 * ```
 */
exports.BLOCK_MARKER = ':';
/**
 * Find the end of a "marked block" indicated by the first non-escaped colon.
 *
 * @param cooked The cooked string (where escaped chars have been processed)
 * @param raw The raw string (where escape sequences are still in place)
 *
 * @returns the index of the end of block marker
 * @throws an error if the block is unterminated
 */
function findEndOfBlock(cooked, raw) {
    /************************************************************************************************
     * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.
     * (See that file for more explanation of why.)
     ************************************************************************************************/
    for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {
        if (raw[rawIndex] === '\\') {
            rawIndex++;
        }
        else if (cooked[cookedIndex] === exports.BLOCK_MARKER) {
            return cookedIndex;
        }
    }
    throw new Error(`Unterminated $localize metadata block in "${raw}".`);
}
exports.findEndOfBlock = findEndOfBlock;
/**
 * Split a message part (`cooked` + `raw`) into an optional delimited "block" off the front and the
 * rest of the text of the message part.
 *
 * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the
 * start and end of the block.
 *
 * If the block is in the first message part then it will be metadata about the whole message:
 * meaning, description, id.  Otherwise it will be metadata about the immediately preceding
 * substitution: placeholder name.
 *
 * Since blocks are optional, it is possible that the content of a message block actually starts
 * with a block marker. In this case the marker must be escaped `\:`.
 *
 * @param cooked The cooked version of the message part to parse.
 * @param raw The raw version of the message part to parse.
 * @returns An object containing the `text` of the message part and the text of the `block`, if it
 * exists.
 * @throws an error if the `block` is unterminated
 */
function splitBlock(cooked, raw) {
    if (raw.charAt(0) !== exports.BLOCK_MARKER) {
        return { text: cooked };
    }
    else {
        const endOfBlock = findEndOfBlock(cooked, raw);
        return {
            block: cooked.substring(1, endOfBlock),
            text: cooked.substring(endOfBlock + 1)
        };
    }
}
exports.splitBlock = splitBlock;
function computePlaceholderName(index) {
    return index === 1 ? 'PH' : `PH_${index - 1}`;
}
function translationToMessage(id, translation) {
    const messageParts = translation.messageParts;
    const legacyIds = [];
    const cleanedMessageParts = [messageParts[0]];
    const substitutions = {};
    const placeholderNames = [];
    let text = messageParts[0];
    for (let i = 1; i < messageParts.length; i++) {
        const { text: messagePart, block: placeholderName = translation.placeholderNames[i - 1] ||
            computePlaceholderName(i) } = splitBlock(messageParts[i], messageParts.raw[i]);
        text += `{$${placeholderName}}${messagePart}`;
        if (translation.placeholderNames.length) {
            substitutions[placeholderName] = translation.placeholderNames[i - 1];
        }
        placeholderNames.push(placeholderName);
        cleanedMessageParts.push(messagePart);
    }
    return {
        id,
        legacyIds,
        substitutions,
        text,
        meaning: translation.meaning || '',
        description: translation.description || '',
        messageParts: cleanedMessageParts,
        placeholderNames
    };
}
exports.translationToMessage = translationToMessage;
//# sourceMappingURL=util.js.map