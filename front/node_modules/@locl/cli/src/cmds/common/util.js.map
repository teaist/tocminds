{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../../libs/cli/src/cmds/common/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { JsonTranslationSerializer } from '../extract/translation_files/json_translation_serializer';\r\nimport { TranslationSerializer } from '../extract/translation_files/translation_serializer';\r\nimport { Xliff1TranslationSerializer } from '../extract/translation_files/xliff1_translation_serializer';\r\nimport { Xliff2TranslationSerializer } from '../extract/translation_files/xliff2_translation_serializer';\r\nimport { XmbTranslationSerializer } from '../extract/translation_files/xmb_translation_serializer';\r\nimport { ɵMessageId, ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedTranslation } from '../convert/translations';\r\nimport { XtbTranslationSerializer } from '../extract/translation_files/xtb_translation_serializer';\r\n\r\nexport type TranslationFormat =\r\n  | 'json'\r\n  | 'xmb'\r\n  | 'xliff1'\r\n  | 'xliff2'\r\n  | 'xlf'\r\n  | 'xlf2'\r\n  | 'xtb';\r\n\r\nexport function getTranslationSerializer(\r\n  format: TranslationFormat\r\n): TranslationSerializer {\r\n  switch (format) {\r\n    case 'json':\r\n      return new JsonTranslationSerializer();\r\n    case 'xliff1':\r\n    case 'xlf':\r\n      return new Xliff1TranslationSerializer();\r\n    case 'xliff2':\r\n    case 'xlf2':\r\n      return new Xliff2TranslationSerializer();\r\n    case 'xmb':\r\n      return new XmbTranslationSerializer();\r\n    case 'xtb':\r\n      return new XtbTranslationSerializer();\r\n  }\r\n}\r\n\r\nexport function getExtension(format: TranslationFormat): string {\r\n  switch (format) {\r\n    case 'json':\r\n    case 'xmb':\r\n    case 'xtb':\r\n      return format;\r\n    default:\r\n      return 'xlf';\r\n  }\r\n}\r\n\r\n/**\r\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\r\n * A block can indicate metadata about the message or specify a name of a placeholder for a\r\n * substitution expressions.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize`Hello, ${title}:title:!`;\r\n * $localize`:meaning|description@@id:source message text`;\r\n * ```\r\n */\r\nexport const BLOCK_MARKER = ':';\r\n\r\n/**\r\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\r\n *\r\n * @param cooked The cooked string (where escaped chars have been processed)\r\n * @param raw The raw string (where escape sequences are still in place)\r\n *\r\n * @returns the index of the end of block marker\r\n * @throws an error if the block is unterminated\r\n */\r\nexport function findEndOfBlock(cooked: string, raw: string): number {\r\n  /************************************************************************************************\r\n   * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.\r\n   * (See that file for more explanation of why.)\r\n   ************************************************************************************************/\r\n  for (\r\n    let cookedIndex = 1, rawIndex = 1;\r\n    cookedIndex < cooked.length;\r\n    cookedIndex++, rawIndex++\r\n  ) {\r\n    if (raw[rawIndex] === '\\\\') {\r\n      rawIndex++;\r\n    } else if (cooked[cookedIndex] === BLOCK_MARKER) {\r\n      return cookedIndex;\r\n    }\r\n  }\r\n  throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\r\n}\r\n\r\n/**\r\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\r\n * rest of the text of the message part.\r\n *\r\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\r\n * start and end of the block.\r\n *\r\n * If the block is in the first message part then it will be metadata about the whole message:\r\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\r\n * substitution: placeholder name.\r\n *\r\n * Since blocks are optional, it is possible that the content of a message block actually starts\r\n * with a block marker. In this case the marker must be escaped `\\:`.\r\n *\r\n * @param cooked The cooked version of the message part to parse.\r\n * @param raw The raw version of the message part to parse.\r\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\r\n * exists.\r\n * @throws an error if the `block` is unterminated\r\n */\r\nexport function splitBlock(\r\n  cooked: string,\r\n  raw: string\r\n): { text: string; block?: string } {\r\n  if (raw.charAt(0) !== BLOCK_MARKER) {\r\n    return { text: cooked };\r\n  } else {\r\n    const endOfBlock = findEndOfBlock(cooked, raw);\r\n    return {\r\n      block: cooked.substring(1, endOfBlock),\r\n      text: cooked.substring(endOfBlock + 1)\r\n    };\r\n  }\r\n}\r\n\r\nfunction computePlaceholderName(index: number) {\r\n  return index === 1 ? 'PH' : `PH_${index - 1}`;\r\n}\r\n\r\nexport function translationToMessage(\r\n  id: string,\r\n  translation: ParsedTranslation\r\n): ɵParsedMessage {\r\n  const messageParts = translation.messageParts;\r\n  const legacyIds = [];\r\n  const cleanedMessageParts: string[] = [messageParts[0]];\r\n  const substitutions: { [placeholderName: string]: any } = {};\r\n  const placeholderNames: string[] = [];\r\n  let text = messageParts[0];\r\n\r\n  for (let i = 1; i < messageParts.length; i++) {\r\n    const {\r\n      text: messagePart,\r\n      block: placeholderName = translation.placeholderNames[i - 1] ||\r\n        computePlaceholderName(i)\r\n    } = splitBlock(messageParts[i], messageParts.raw[i]);\r\n    text += `{$${placeholderName}}${messagePart}`;\r\n    if (translation.placeholderNames.length) {\r\n      substitutions[placeholderName] = translation.placeholderNames[i - 1];\r\n    }\r\n    placeholderNames.push(placeholderName);\r\n    cleanedMessageParts.push(messagePart);\r\n  }\r\n\r\n  return {\r\n    id,\r\n    legacyIds,\r\n    substitutions,\r\n    text,\r\n    meaning: translation.meaning || '',\r\n    description: translation.description || '',\r\n    messageParts: cleanedMessageParts,\r\n    placeholderNames\r\n  };\r\n}\r\n\r\nexport interface ParsedMessageLegacy {\r\n  /**\r\n   * The key used to look up the appropriate translation target.\r\n   */\r\n  messageId: ɵMessageId;\r\n  /**\r\n   * Legacy message ids, if provided.\r\n   *\r\n   * In legacy message formats the message id can only be computed directly from the original\r\n   * template source.\r\n   *\r\n   * Since this information is not available in `$localize` calls, the legacy message ids may be\r\n   * attached by the compiler to the `$localize` metablock so it can be used if needed at the point\r\n   * of translation if the translations are encoded using the legacy message id.\r\n   */\r\n  legacyIds: ɵMessageId[];\r\n  /**\r\n   * A mapping of placeholder names to substitution values.\r\n   */\r\n  substitutions: Record<string, any>;\r\n  /**\r\n   * A human readable rendering of the message\r\n   */\r\n  messageString: string;\r\n  /**\r\n   * The meaning of the `message`, used to distinguish identical `messageString`s.\r\n   */\r\n  meaning: string;\r\n  /**\r\n   * The description of the `message`, used to aid translation.\r\n   */\r\n  description: string;\r\n  /**\r\n   * The static parts of the message.\r\n   */\r\n  messageParts: string[];\r\n  /**\r\n   * The names of the placeholders that will be replaced with substitutions.\r\n   */\r\n  placeholderNames: string[];\r\n}\r\n"]}