"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const fs = require("fs");
const path = require("path");
class FileUtils {
    static readFile(absolutePath) {
        return fs.readFileSync(absolutePath, 'utf8');
    }
    static readFileBuffer(absolutePath) {
        return fs.readFileSync(absolutePath);
    }
    static writeFile(absolutePath, contents) {
        FileUtils.ensureDir(path.dirname(absolutePath));
        fs.writeFileSync(absolutePath, contents);
    }
    static ensureDir(absolutePath) {
        const parents = [];
        while (!FileUtils.isRoot(absolutePath) && !fs.existsSync(absolutePath)) {
            parents.push(absolutePath);
            absolutePath = path.dirname(absolutePath);
        }
        while (parents.length) {
            fs.mkdirSync(parents.pop());
        }
    }
    static remove(p) {
        const stat = fs.statSync(p);
        if (stat.isFile()) {
            fs.unlinkSync(p);
        }
        else if (stat.isDirectory()) {
            fs.readdirSync(p).forEach(child => {
                const absChild = path.resolve(p, child);
                FileUtils.remove(absChild);
            });
            fs.rmdirSync(p);
        }
    }
    static isRoot(absolutePath) {
        return path.dirname(absolutePath) === absolutePath;
    }
    static dedup(files, pattern, replaceValue = '') {
        const filesSet = files.map(file => file.replace(pattern, replaceValue));
        const dedup = [];
        const indexes = [];
        filesSet.forEach((file, index) => {
            if (dedup.indexOf(file) === -1) {
                dedup.push(file);
                indexes.push(index);
            }
        });
        return indexes.map(index => files[index]);
    }
}
exports.FileUtils = FileUtils;
//# sourceMappingURL=file_utils.js.map