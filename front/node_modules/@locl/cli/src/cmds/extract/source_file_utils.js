"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const localize_1 = require("@angular/localize");
const t = require("@babel/types");
/**
 * Is the given `expression` an identifier with the correct name
 * @param expression The expression to check.
 */
function isNamedIdentifier(expression, name) {
    return expression.isIdentifier() && expression.node.name === name;
}
exports.isNamedIdentifier = isNamedIdentifier;
/**
 * Is the given `identifier` declared globally.
 * @param identifier The identifier to check.
 */
function isGlobalIdentifier(identifier) {
    return (!identifier.scope || !identifier.scope.hasBinding(identifier.node.name));
}
exports.isGlobalIdentifier = isGlobalIdentifier;
/**
 * Build a translated expression to replace the call to `$localize`.
 * @param messageParts The static parts of the message.
 * @param substitutions The expressions to substitute into the message.
 */
function buildLocalizeReplacement(messageParts, substitutions) {
    let mappedString = t.stringLiteral(messageParts[0]);
    for (let i = 1; i < messageParts.length; i++) {
        mappedString = t.binaryExpression('+', mappedString, wrapInParensIfNecessary(substitutions[i - 1]));
        mappedString = t.binaryExpression('+', mappedString, t.stringLiteral(messageParts[i]));
    }
    return mappedString;
}
exports.buildLocalizeReplacement = buildLocalizeReplacement;
/**
 * Extract the message parts from the given `call` (to `$localize`).
 *
 * The message parts will either by the first argument to the `call` or it will be wrapped in call
 * to a helper function like `__makeTemplateObject`.
 *
 * @param call The AST node of the call to process.
 */
function unwrapMessagePartsFromLocalizeCall(call) {
    let cooked = call.get('arguments')[0];
    if (cooked === undefined) {
        throw new BabelParseError(call.node, '`$localize` called without any arguments.');
    }
    if (!cooked.isExpression()) {
        throw new BabelParseError(cooked.node, 'Unexpected argument to `$localize` (expected an array).');
    }
    // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.
    let raw = cooked;
    // Check for cached call of the form `x || x = __makeTemplateObject(...)`
    if (cooked.isLogicalExpression() &&
        cooked.node.operator === '||' &&
        cooked.get('left').isIdentifier()) {
        const right = cooked.get('right');
        if (right.isAssignmentExpression()) {
            cooked = right.get('right');
            if (!cooked.isExpression()) {
                throw new BabelParseError(cooked.node, 'Unexpected "makeTemplateObject()" function (expected an expression).');
            }
        }
    }
    // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.
    if (cooked.isCallExpression()) {
        let cookedCall = cooked;
        if (cookedCall.get('arguments').length === 0) {
            // No arguments so perhaps it is a `__templateObject()` call.
            // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.
            cookedCall = unwrapLazyLoadHelperCall(cookedCall);
        }
        cooked = cookedCall.get('arguments')[0];
        if (!cooked.isExpression()) {
            throw new BabelParseError(cooked.node, 'Unexpected `cooked` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        const arg2 = cookedCall.get('arguments')[1];
        if (arg2 && !arg2.isExpression()) {
            throw new BabelParseError(arg2.node, 'Unexpected `raw` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        // If there is no second argument then assume that raw and cooked are the same
        raw = arg2 !== undefined ? arg2 : cooked;
    }
    const cookedStrings = unwrapStringLiteralArray(cooked.node);
    const rawStrings = unwrapStringLiteralArray(raw.node);
    return localize_1.ɵmakeTemplateObject(cookedStrings, rawStrings);
}
exports.unwrapMessagePartsFromLocalizeCall = unwrapMessagePartsFromLocalizeCall;
function unwrapSubstitutionsFromLocalizeCall(call) {
    const expressions = call.arguments.splice(1);
    if (!isArrayOfExpressions(expressions)) {
        const badExpression = expressions.find(expression => !t.isExpression(expression));
        throw new BabelParseError(badExpression, 'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).');
    }
    return expressions;
}
exports.unwrapSubstitutionsFromLocalizeCall = unwrapSubstitutionsFromLocalizeCall;
function unwrapMessagePartsFromTemplateLiteral(elements) {
    const cooked = elements.map(q => {
        if (q.value.cooked === undefined) {
            throw new BabelParseError(q, `Unexpected undefined message part in "${elements.map(eq => eq.value.cooked)}"`);
        }
        return q.value.cooked;
    });
    const raw = elements.map(q => q.value.raw);
    return localize_1.ɵmakeTemplateObject(cooked, raw);
}
exports.unwrapMessagePartsFromTemplateLiteral = unwrapMessagePartsFromTemplateLiteral;
/**
 * Wrap the given `expression` in parentheses if it is a binary expression.
 *
 * This ensures that this expression is evaluated correctly if it is embedded in another expression.
 *
 * @param expression The expression to potentially wrap.
 */
function wrapInParensIfNecessary(expression) {
    if (t.isBinaryExpression(expression)) {
        return t.parenthesizedExpression(expression);
    }
    else {
        return expression;
    }
}
exports.wrapInParensIfNecessary = wrapInParensIfNecessary;
/**
 * Extract the string values from an `array` of string literals.
 * @param array The array to unwrap.
 */
function unwrapStringLiteralArray(array) {
    if (!isStringLiteralArray(array)) {
        throw new BabelParseError(array, 'Unexpected messageParts for `$localize` (expected an array of strings).');
    }
    return array.elements.map((str) => str.value);
}
exports.unwrapStringLiteralArray = unwrapStringLiteralArray;
/**
 * This expression is believed to be a call to a "lazy-load" template object helper function.
 * This is expected to be of the form:
 *
 * ```ts
 *  function _templateObject() {
 *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);
 *    return _templateObject = function() { return e }, e
 *  }
 * ```
 *
 * We unwrap this to return the call to `_taggedTemplateLiteral()`.
 *
 * @param call the call expression to unwrap
 * @returns the  call expression
 */
function unwrapLazyLoadHelperCall(call) {
    const callee = call.get('callee');
    if (!callee.isIdentifier()) {
        throw new BabelParseError(callee.node, 'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).');
    }
    const lazyLoadBinding = call.scope.getBinding(callee.node.name);
    if (!lazyLoadBinding) {
        throw new BabelParseError(callee.node, 'Missing declaration for lazy-load helper function');
    }
    const lazyLoadFn = lazyLoadBinding.path;
    if (!lazyLoadFn.isFunctionDeclaration()) {
        throw new BabelParseError(lazyLoadFn.node, 'Unexpected expression (expected a function declaration');
    }
    const returnedNode = getReturnedExpression(lazyLoadFn);
    if (returnedNode.isCallExpression()) {
        return returnedNode;
    }
    if (returnedNode.isIdentifier()) {
        const identifierName = returnedNode.node.name;
        const declaration = returnedNode.scope.getBinding(identifierName);
        if (declaration === undefined) {
            throw new BabelParseError(returnedNode.node, 'Missing declaration for return value from helper.');
        }
        if (!declaration.path.isVariableDeclarator()) {
            throw new BabelParseError(declaration.path.node, 'Unexpected helper return value declaration (expected a variable declaration).');
        }
        const initializer = declaration.path.get('init');
        if (!initializer.isCallExpression()) {
            throw new BabelParseError(declaration.path.node, 'Unexpected return value from helper (expected a call expression).');
        }
        // Remove the lazy load helper if this is the only reference to it.
        if (lazyLoadBinding.references === 1) {
            lazyLoadFn.remove();
        }
        return initializer;
    }
    return call;
}
exports.unwrapLazyLoadHelperCall = unwrapLazyLoadHelperCall;
function getReturnedExpression(fn) {
    const bodyStatements = fn.get('body').get('body');
    for (const statement of bodyStatements) {
        if (statement.isReturnStatement()) {
            const argument = statement.get('argument');
            if (argument.isSequenceExpression()) {
                const expressions = argument.get('expressions');
                return Array.isArray(expressions)
                    ? expressions[expressions.length - 1]
                    : expressions;
            }
            else if (argument.isExpression()) {
                return argument;
            }
            else {
                throw new BabelParseError(statement.node, 'Invalid return argument in helper function (expected an expression).');
            }
        }
    }
    throw new BabelParseError(fn.node, 'Missing return statement in helper function.');
}
/**
 * Is the given `node` an array of literal strings?
 *
 * @param node The node to test.
 */
function isStringLiteralArray(node) {
    return (t.isArrayExpression(node) &&
        node.elements.every(element => t.isStringLiteral(element)));
}
exports.isStringLiteralArray = isStringLiteralArray;
/**
 * Are all the given `nodes` expressions?
 * @param nodes The nodes to test.
 */
function isArrayOfExpressions(nodes) {
    return nodes.every(element => t.isExpression(element));
}
exports.isArrayOfExpressions = isArrayOfExpressions;
/**
 * Translate the text of the given message, using the given translations.
 *
 * Logs as warning if the translation is not available
 */
function translate(diagnostics, translations, messageParts, substitutions, missingTranslation) {
    try {
        return localize_1.ɵtranslate(translations, messageParts, substitutions);
    }
    catch (e) {
        if (localize_1.ɵisMissingTranslationError(e)) {
            if (missingTranslation === 'error') {
                diagnostics.error(e.message);
            }
            else if (missingTranslation === 'warning') {
                diagnostics.warn(e.message);
            }
            // Return the parsed message because this will have the meta blocks stripped
            return [
                localize_1.ɵmakeTemplateObject(e.parsedMessage.messageParts, e.parsedMessage.messageParts),
                substitutions
            ];
        }
        else {
            diagnostics.error(e.message);
            return [messageParts, substitutions];
        }
    }
}
exports.translate = translate;
class BabelParseError extends Error {
    constructor(node, message) {
        super(message);
        this.node = node;
        this.type = 'BabelParseError';
    }
}
exports.BabelParseError = BabelParseError;
function isBabelParseError(e) {
    return e.type === 'BabelParseError';
}
exports.isBabelParseError = isBabelParseError;
//# sourceMappingURL=source_file_utils.js.map