{"version":3,"file":"source_file_utils.js","sourceRoot":"","sources":["../../../../../../libs/cli/src/cmds/extract/source_file_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  ɵParsedTranslation,\n  ɵisMissingTranslationError,\n  ɵmakeTemplateObject,\n  ɵtranslate\n} from '@angular/localize';\nimport { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { ParsedTranslation } from '@angular/localize/src/utils';\nimport { Diagnostics } from '../common/diagnostics';\n\n/**\n * Is the given `expression` an identifier with the correct name\n * @param expression The expression to check.\n */\nexport function isNamedIdentifier(\n  expression: NodePath,\n  name: string\n): expression is NodePath {\n  return expression.isIdentifier() && expression.node.name === name;\n}\n\n/**\n * Is the given `identifier` declared globally.\n * @param identifier The identifier to check.\n */\nexport function isGlobalIdentifier(identifier: NodePath<t.Identifier>) {\n  return (\n    !identifier.scope || !identifier.scope.hasBinding(identifier.node.name)\n  );\n}\n\n/**\n * Build a translated expression to replace the call to `$localize`.\n * @param messageParts The static parts of the message.\n * @param substitutions The expressions to substitute into the message.\n */\nexport function buildLocalizeReplacement(\n  messageParts: TemplateStringsArray,\n  substitutions: readonly t.Expression[]\n): t.Expression {\n  let mappedString: t.Expression = t.stringLiteral(messageParts[0]);\n  for (let i = 1; i < messageParts.length; i++) {\n    mappedString = t.binaryExpression(\n      '+',\n      mappedString,\n      wrapInParensIfNecessary(substitutions[i - 1])\n    );\n    mappedString = t.binaryExpression(\n      '+',\n      mappedString,\n      t.stringLiteral(messageParts[i])\n    );\n  }\n  return mappedString;\n}\n\n/**\n * Extract the message parts from the given `call` (to `$localize`).\n *\n * The message parts will either by the first argument to the `call` or it will be wrapped in call\n * to a helper function like `__makeTemplateObject`.\n *\n * @param call The AST node of the call to process.\n */\nexport function unwrapMessagePartsFromLocalizeCall(\n  call: NodePath<t.CallExpression>\n): TemplateStringsArray {\n  let cooked = call.get('arguments')[0] as any;\n\n  if (cooked === undefined) {\n    throw new BabelParseError(\n      call.node,\n      '`$localize` called without any arguments.'\n    );\n  }\n  if (!cooked.isExpression()) {\n    throw new BabelParseError(\n      cooked.node,\n      'Unexpected argument to `$localize` (expected an array).'\n    );\n  }\n\n  // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.\n  let raw = cooked;\n\n  // Check for cached call of the form `x || x = __makeTemplateObject(...)`\n  if (\n    cooked.isLogicalExpression() &&\n    cooked.node.operator === '||' &&\n    cooked.get('left').isIdentifier()\n  ) {\n    const right = cooked.get('right');\n    if (right.isAssignmentExpression()) {\n      cooked = right.get('right');\n      if (!cooked.isExpression()) {\n        throw new BabelParseError(\n          cooked.node,\n          'Unexpected \"makeTemplateObject()\" function (expected an expression).'\n        );\n      }\n    }\n  }\n\n  // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.\n  if (cooked.isCallExpression()) {\n    let cookedCall = cooked;\n    if (cookedCall.get('arguments').length === 0) {\n      // No arguments so perhaps it is a `__templateObject()` call.\n      // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.\n      cookedCall = unwrapLazyLoadHelperCall(cookedCall);\n    }\n\n    cooked = cookedCall.get('arguments')[0];\n    if (!cooked.isExpression()) {\n      throw new BabelParseError(\n        cooked.node,\n        'Unexpected `cooked` argument to the \"makeTemplateObject()\" function (expected an expression).'\n      );\n    }\n    const arg2 = cookedCall.get('arguments')[1];\n    if (arg2 && !arg2.isExpression()) {\n      throw new BabelParseError(\n        arg2.node,\n        'Unexpected `raw` argument to the \"makeTemplateObject()\" function (expected an expression).'\n      );\n    }\n    // If there is no second argument then assume that raw and cooked are the same\n    raw = arg2 !== undefined ? arg2 : cooked;\n  }\n\n  const cookedStrings = unwrapStringLiteralArray(cooked.node);\n  const rawStrings = unwrapStringLiteralArray(raw.node);\n  return ɵmakeTemplateObject(cookedStrings, rawStrings);\n}\n\nexport function unwrapSubstitutionsFromLocalizeCall(\n  call: t.CallExpression\n): t.Expression[] {\n  const expressions = call.arguments.splice(1);\n  if (!isArrayOfExpressions(expressions)) {\n    const badExpression = expressions.find(\n      expression => !t.isExpression(expression)\n    )!;\n    throw new BabelParseError(\n      badExpression,\n      'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).'\n    );\n  }\n  return expressions;\n}\n\nexport function unwrapMessagePartsFromTemplateLiteral(\n  elements: t.TemplateElement[]\n): TemplateStringsArray {\n  const cooked = elements.map(q => {\n    if (q.value.cooked === undefined) {\n      throw new BabelParseError(\n        q,\n        `Unexpected undefined message part in \"${elements.map(\n          eq => eq.value.cooked\n        )}\"`\n      );\n    }\n    return q.value.cooked;\n  });\n  const raw = elements.map(q => q.value.raw);\n  return ɵmakeTemplateObject(cooked, raw);\n}\n\n/**\n * Wrap the given `expression` in parentheses if it is a binary expression.\n *\n * This ensures that this expression is evaluated correctly if it is embedded in another expression.\n *\n * @param expression The expression to potentially wrap.\n */\nexport function wrapInParensIfNecessary(\n  expression: t.Expression\n): t.Expression {\n  if (t.isBinaryExpression(expression)) {\n    return t.parenthesizedExpression(expression);\n  } else {\n    return expression;\n  }\n}\n\n/**\n * Extract the string values from an `array` of string literals.\n * @param array The array to unwrap.\n */\nexport function unwrapStringLiteralArray(array: t.Expression): string[] {\n  if (!isStringLiteralArray(array)) {\n    throw new BabelParseError(\n      array,\n      'Unexpected messageParts for `$localize` (expected an array of strings).'\n    );\n  }\n  return array.elements.map((str: t.StringLiteral) => str.value);\n}\n\n/**\n * This expression is believed to be a call to a \"lazy-load\" template object helper function.\n * This is expected to be of the form:\n *\n * ```ts\n *  function _templateObject() {\n *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);\n *    return _templateObject = function() { return e }, e\n *  }\n * ```\n *\n * We unwrap this to return the call to `_taggedTemplateLiteral()`.\n *\n * @param call the call expression to unwrap\n * @returns the  call expression\n */\nexport function unwrapLazyLoadHelperCall(\n  call: NodePath<t.CallExpression>\n): NodePath<t.CallExpression> {\n  const callee = call.get('callee') as any;\n  if (!callee.isIdentifier()) {\n    throw new BabelParseError(\n      callee.node,\n      'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).'\n    );\n  }\n  const lazyLoadBinding = call.scope.getBinding(callee.node.name);\n  if (!lazyLoadBinding) {\n    throw new BabelParseError(\n      callee.node,\n      'Missing declaration for lazy-load helper function'\n    );\n  }\n  const lazyLoadFn = lazyLoadBinding.path;\n  if (!lazyLoadFn.isFunctionDeclaration()) {\n    throw new BabelParseError(\n      (lazyLoadFn as any).node,\n      'Unexpected expression (expected a function declaration'\n    );\n  }\n  const returnedNode = getReturnedExpression(lazyLoadFn);\n\n  if (returnedNode.isCallExpression()) {\n    return returnedNode;\n  }\n\n  if (returnedNode.isIdentifier()) {\n    const identifierName = returnedNode.node.name;\n    const declaration = returnedNode.scope.getBinding(identifierName);\n    if (declaration === undefined) {\n      throw new BabelParseError(\n        returnedNode.node,\n        'Missing declaration for return value from helper.'\n      );\n    }\n    if (!declaration.path.isVariableDeclarator()) {\n      throw new BabelParseError(\n        (declaration as any).path.node,\n        'Unexpected helper return value declaration (expected a variable declaration).'\n      );\n    }\n    const initializer = declaration.path.get('init');\n    if (!initializer.isCallExpression()) {\n      throw new BabelParseError(\n        declaration.path.node,\n        'Unexpected return value from helper (expected a call expression).'\n      );\n    }\n\n    // Remove the lazy load helper if this is the only reference to it.\n    if (lazyLoadBinding.references === 1) {\n      lazyLoadFn.remove();\n    }\n\n    return initializer;\n  }\n  return call;\n}\n\nfunction getReturnedExpression(\n  fn: NodePath<t.FunctionDeclaration>\n): NodePath<t.Expression> {\n  const bodyStatements = (fn.get('body') as any).get('body');\n  for (const statement of bodyStatements) {\n    if (statement.isReturnStatement()) {\n      const argument = statement.get('argument');\n      if (argument.isSequenceExpression()) {\n        const expressions = argument.get('expressions');\n        return Array.isArray(expressions)\n          ? expressions[expressions.length - 1]\n          : expressions;\n      } else if (argument.isExpression()) {\n        return argument;\n      } else {\n        throw new BabelParseError(\n          statement.node,\n          'Invalid return argument in helper function (expected an expression).'\n        );\n      }\n    }\n  }\n  throw new BabelParseError(\n    fn.node,\n    'Missing return statement in helper function.'\n  );\n}\n\n/**\n * Is the given `node` an array of literal strings?\n *\n * @param node The node to test.\n */\nexport function isStringLiteralArray(\n  node: t.Node\n): node is t.Expression & { elements: t.StringLiteral[] } {\n  return (\n    t.isArrayExpression(node) &&\n    node.elements.every(element => t.isStringLiteral(element))\n  );\n}\n\n/**\n * Are all the given `nodes` expressions?\n * @param nodes The nodes to test.\n */\nexport function isArrayOfExpressions(nodes: t.Node[]): nodes is t.Expression[] {\n  return nodes.every(element => t.isExpression(element));\n}\n\n/** Options that affect how the `makeEsXXXTranslatePlugin()` functions work. */\nexport interface TranslatePluginOptions {\n  missingTranslation?: MissingTranslationStrategy;\n  localizeName?: string;\n}\n\n/**\n * How to handle missing translations.\n */\nexport type MissingTranslationStrategy = 'error' | 'warning' | 'ignore';\n\n/**\n * Translate the text of the given message, using the given translations.\n *\n * Logs as warning if the translation is not available\n */\nexport function translate(\n  diagnostics: Diagnostics,\n  translations: Record<string, ɵParsedTranslation>,\n  messageParts: TemplateStringsArray,\n  substitutions: readonly any[],\n  missingTranslation: MissingTranslationStrategy\n): [TemplateStringsArray, readonly any[]] {\n  try {\n    return ɵtranslate(translations, messageParts, substitutions);\n  } catch (e) {\n    if (ɵisMissingTranslationError(e)) {\n      if (missingTranslation === 'error') {\n        diagnostics.error(e.message);\n      } else if (missingTranslation === 'warning') {\n        diagnostics.warn(e.message);\n      }\n      // Return the parsed message because this will have the meta blocks stripped\n      return [\n        ɵmakeTemplateObject(\n          e.parsedMessage.messageParts,\n          e.parsedMessage.messageParts\n        ),\n        substitutions\n      ];\n    } else {\n      diagnostics.error(e.message);\n      return [messageParts, substitutions];\n    }\n  }\n}\n\nexport class BabelParseError extends Error {\n  private readonly type = 'BabelParseError';\n  constructor(public node: t.Node, message: string) {\n    super(message);\n  }\n}\n\nexport function isBabelParseError(e: any): e is BabelParseError {\n  return e.type === 'BabelParseError';\n}\n"]}