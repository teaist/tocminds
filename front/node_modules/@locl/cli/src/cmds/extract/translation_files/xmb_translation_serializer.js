"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const xml_file_1 = require("./xml_file");
const DOCTYPE = `<!ELEMENT messagebundle (msg)*>
<!ATTLIST messagebundle class CDATA #IMPLIED>

<!ELEMENT msg (#PCDATA|ph|source)*>
<!ATTLIST msg id CDATA #IMPLIED>
<!ATTLIST msg seq CDATA #IMPLIED>
<!ATTLIST msg name CDATA #IMPLIED>
<!ATTLIST msg desc CDATA #IMPLIED>
<!ATTLIST msg meaning CDATA #IMPLIED>
<!ATTLIST msg obsolete (obsolete) #IMPLIED>
<!ATTLIST msg xml:space (default|preserve) "default">
<!ATTLIST msg is_hidden CDATA #IMPLIED>

<!ELEMENT source (#PCDATA)>

<!ELEMENT ph (#PCDATA|ex)*>
<!ATTLIST ph name CDATA #REQUIRED>

<!ELEMENT ex (#PCDATA)>`;
class XmbTranslationSerializer {
    renderFile(messages) {
        const xml = new xml_file_1.XmlFile();
        xml.startTag('messagebundle');
        messages.forEach(message => {
            xml.startTag('msg', {
                id: message.id ||
                    message.messageId,
                desc: message.description,
                meaning: message.meaning
            }, { preserveWhitespace: true });
            this.renderMessage(xml, message);
            xml.endTag('msg', { preserveWhitespace: false });
        });
        xml.endTag('messagebundle');
        return xml.toString();
    }
    renderMessage(xml, message) {
        xml.text(message.messageParts[0]);
        for (let i = 1; i < message.messageParts.length; i++) {
            xml.startTag('ph', { name: message.placeholderNames[i - 1] }, { selfClosing: true });
            xml.text(message.messageParts[i]);
        }
    }
}
exports.XmbTranslationSerializer = XmbTranslationSerializer;
//# sourceMappingURL=xmb_translation_serializer.js.map