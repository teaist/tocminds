"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const compiler_1 = require("@angular/compiler");
const base_visitor_1 = require("@angular/localize/src/tools/src/translate/translation_files/base_visitor");
const translation_parse_error_1 = require("../translation_parsers/translation_parse_error");
const translation_utils_1 = require("../translation_parsers/translation_utils");
/**
 * This visitor will walk over a set of XML nodes, which represent an i18n message, and serialize
 * them into a message object of type `T`.
 * The type of the serialized message is controlled by the
 */
class MessageSerializer extends base_visitor_1.BaseVisitor {
    constructor(renderer, config) {
        super();
        this.renderer = renderer;
        this.config = config;
    }
    serialize(nodes) {
        this.renderer.startRender();
        compiler_1.visitAll(this, nodes);
        this.renderer.endRender();
        return this.renderer.message;
    }
    visitElement(element) {
        if (this.config.placeholder &&
            element.name === this.config.placeholder.elementName) {
            const name = translation_utils_1.getAttrOrThrow(element, this.config.placeholder.nameAttribute);
            const body = this.config.placeholder.bodyAttribute &&
                translation_utils_1.getAttribute(element, this.config.placeholder.bodyAttribute);
            this.visitPlaceholder(name, body);
        }
        else if (this.config.placeholderContainer &&
            element.name === this.config.placeholderContainer.elementName) {
            const start = translation_utils_1.getAttrOrThrow(element, this.config.placeholderContainer.startAttribute);
            const end = translation_utils_1.getAttrOrThrow(element, this.config.placeholderContainer.endAttribute);
            this.visitPlaceholderContainer(start, element.children, end);
        }
        else if (this.config.inlineElements.indexOf(element.name) !== -1) {
            compiler_1.visitAll(this, element.children);
        }
        else {
            throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, `Invalid element found in message.`);
        }
    }
    visitText(text) {
        this.renderer.text(text.value);
    }
    visitExpansion(expansion) {
        this.renderer.startIcu();
        this.renderer.text(`${expansion.switchValue}, ${expansion.type},`);
        compiler_1.visitAll(this, expansion.cases);
        this.renderer.endIcu();
    }
    visitExpansionCase(expansionCase) {
        this.renderer.text(` ${expansionCase.value} {`);
        this.renderer.startContainer();
        compiler_1.visitAll(this, expansionCase.expression);
        this.renderer.closeContainer();
        this.renderer.text(`}`);
    }
    visitContainedNodes(nodes) {
        const length = nodes.length;
        let index = 0;
        while (index < length) {
            if (!this.isPlaceholderContainer(nodes[index])) {
                const startOfContainedNodes = index;
                while (index < length - 1) {
                    index++;
                    if (this.isPlaceholderContainer(nodes[index])) {
                        break;
                    }
                }
                if (index - startOfContainedNodes > 1) {
                    // Only create a container if there are two or more contained Nodes in a row
                    this.renderer.startContainer();
                    compiler_1.visitAll(this, nodes.slice(startOfContainedNodes, index - 1));
                    this.renderer.closeContainer();
                }
            }
            if (index < length) {
                nodes[index].visit(this, undefined);
            }
            index++;
        }
    }
    visitPlaceholder(name, body) {
        this.renderer.placeholder(name, body);
    }
    visitPlaceholderContainer(startName, children, closeName) {
        this.renderer.startPlaceholder(startName);
        this.visitContainedNodes(children);
        this.renderer.closePlaceholder(closeName);
    }
    isPlaceholderContainer(node) {
        return (node instanceof compiler_1.Element &&
            node.name === this.config.placeholderContainer.elementName);
    }
}
exports.MessageSerializer = MessageSerializer;
//# sourceMappingURL=message_serializer.js.map