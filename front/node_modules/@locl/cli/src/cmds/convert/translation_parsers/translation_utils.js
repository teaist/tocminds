"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const compiler_1 = require("@angular/compiler");
const translation_parse_error_1 = require("./translation_parse_error");
function getAttrOrThrow(element, attrName) {
    const attrValue = getAttribute(element, attrName);
    if (attrValue === undefined) {
        throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, `Missing required "${attrName}" attribute:`);
    }
    return attrValue;
}
exports.getAttrOrThrow = getAttrOrThrow;
function getAttribute(element, attrName) {
    const attr = element.attrs.find(a => a.name === attrName);
    return attr !== undefined ? attr.value : undefined;
}
exports.getAttribute = getAttribute;
function parseInnerRange(element) {
    const xmlParser = new compiler_1.XmlParser();
    const xml = xmlParser.parse(element.sourceSpan.start.file.content, element.sourceSpan.start.file.url, { tokenizeExpansionForms: true, range: getInnerRange(element) });
    if (xml.errors.length) {
        throw xml.errors
            .map(e => new translation_parse_error_1.TranslationParseError(e.span, e.msg).toString())
            .join('\n');
    }
    return xml.rootNodes;
}
exports.parseInnerRange = parseInnerRange;
function getInnerRange(element) {
    const start = element.startSourceSpan.end;
    const end = element.endSourceSpan.start;
    return {
        startPos: start.offset,
        startLine: start.line,
        startCol: start.col,
        endPos: end.offset
    };
}
/**
 * Create a predicate, which can be used by things like `Array.filter()`, that will match a named
 * XML Element from a collection of XML Nodes.
 *
 * @param name The expected name of the element to match.
 */
function isNamedElement(name) {
    function predicate(node) {
        return node instanceof compiler_1.Element && node.name === name;
    }
    return predicate;
}
exports.isNamedElement = isNamedElement;
/**
 * Can this XML be parsed for translations, given the expected `rootNodeName` and expected root node
 * `attributes` that should appear in the file.
 *
 * @param filePath The path to the file being checked.
 * @param contents The contents of the file being checked.
 * @param rootNodeName The expected name of an XML root node that should exist.
 * @param attributes The attributes (and their values) that should appear on the root node.
 * @returns The `XmlTranslationParserHint` object for use by `TranslationParser.parse()` if the XML
 * document has the expected format.
 */
function canParseXml(filePath, contents, rootNodeName, attributes) {
    const xmlParser = new compiler_1.XmlParser();
    const xml = xmlParser.parse(contents, filePath);
    if (xml.rootNodes.length === 0 ||
        xml.errors.some(error => error.level === compiler_1.ParseErrorLevel.ERROR)) {
        return false;
    }
    const rootElements = xml.rootNodes.filter(isNamedElement(rootNodeName));
    const rootElement = rootElements[0];
    if (rootElement === undefined) {
        return false;
    }
    for (const attrKey of Object.keys(attributes)) {
        const attr = rootElement.attrs.find(a => a.name === attrKey);
        if (attr === undefined || attr.value !== attributes[attrKey]) {
            return false;
        }
    }
    if (rootElements.length > 1) {
        xml.errors.push(new compiler_1.ParseError(xml.rootNodes[1].sourceSpan, 'Unexpected root node. XLIFF 1.2 files should only have a single <xliff> root node.', compiler_1.ParseErrorLevel.WARNING));
    }
    return { element: rootElement, errors: xml.errors };
}
exports.canParseXml = canParseXml;
/**
 * Add an XML parser related message to the given `diagnostics` object.
 */
function addParseDiagnostic(diagnostics, sourceSpan, message, level) {
    addParseError(diagnostics, new compiler_1.ParseError(sourceSpan, message, level));
}
exports.addParseDiagnostic = addParseDiagnostic;
/**
 * Copy the formatted error message from the given `parseError` object into the given `diagnostics`
 * object.
 */
function addParseError(diagnostics, parseError) {
    if (parseError.level === compiler_1.ParseErrorLevel.ERROR) {
        diagnostics.error(parseError.toString());
    }
    else {
        diagnostics.warn(parseError.toString());
    }
}
exports.addParseError = addParseError;
//# sourceMappingURL=translation_utils.js.map