{"version":3,"file":"xtb_translation_parser.js","sourceRoot":"","sources":["../../../../../../../libs/cli/src/cmds/convert/translation_parsers/xtb_translation_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Element, Node, XmlParser, visitAll } from '@angular/compiler';\r\nimport { ɵParsedTranslation } from '@angular/localize';\r\nimport { extname } from 'path';\r\n\r\nimport { MessageSerializer } from '../message_serialization/message_serializer';\r\nimport { TargetMessageRenderer } from '../message_serialization/target_message_renderer';\r\n\r\nimport { TranslationParseError } from './translation_parse_error';\r\nimport {\r\n  ParsedTranslationBundle,\r\n  TranslationParser\r\n} from './translation_parser';\r\nimport {\r\n  canParseXml,\r\n  getAttrOrThrow,\r\n  parseInnerRange,\r\n  XmlTranslationParserHint\r\n} from './translation_utils';\r\nimport { Diagnostics } from '../../common/diagnostics';\r\nimport { BaseVisitor } from '@angular/localize/src/tools/src/translate/translation_files/base_visitor';\r\n\r\n/**\r\n * A translation parser that can load XB files.\r\n */\r\nexport class XtbTranslationParser\r\n  implements TranslationParser<XmlTranslationParserHint> {\r\n  constructor(private diagnostics: Diagnostics) {}\r\n\r\n  canParse(\r\n    filePath: string,\r\n    contents: string\r\n  ): XmlTranslationParserHint | false {\r\n    const extension = extname(filePath);\r\n    if (extension !== '.xtb' && extension !== '.xmb') {\r\n      return false;\r\n    }\r\n    return canParseXml(filePath, contents, 'translationbundle', {});\r\n  }\r\n\r\n  parse(filePath: string, contents: string): ParsedTranslationBundle {\r\n    const xmlParser = new XmlParser();\r\n    const xml = xmlParser.parse(contents, filePath);\r\n    const bundle = XtbVisitor.extractBundle(this.diagnostics, xml.rootNodes);\r\n    if (bundle === undefined) {\r\n      throw new Error(`Unable to parse \"${filePath}\" as XTB/XMB format.`);\r\n    }\r\n    return bundle;\r\n  }\r\n}\r\n\r\nclass XtbVisitor extends BaseVisitor {\r\n  static extractBundle(\r\n    diagnostics: Diagnostics,\r\n    messageBundles: Node[]\r\n  ): ParsedTranslationBundle | undefined {\r\n    const visitor = new this(diagnostics);\r\n    const bundles: ParsedTranslationBundle[] = visitAll(\r\n      visitor,\r\n      messageBundles,\r\n      undefined\r\n    );\r\n    return bundles[0];\r\n  }\r\n\r\n  constructor(private diagnostics: Diagnostics) {\r\n    super();\r\n  }\r\n\r\n  visitElement(\r\n    element: Element,\r\n    bundle: ParsedTranslationBundle | undefined\r\n  ): any {\r\n    switch (element.name) {\r\n      case 'translationbundle':\r\n        if (bundle) {\r\n          throw new TranslationParseError(\r\n            element.sourceSpan,\r\n            '<translationbundle> elements can not be nested'\r\n          );\r\n        }\r\n        const langAttr = element.attrs.find(attr => attr.name === 'lang');\r\n        bundle = {\r\n          locale: langAttr && langAttr.value,\r\n          translations: {},\r\n          diagnostics: this.diagnostics\r\n        };\r\n        visitAll(this, element.children, bundle);\r\n        return bundle;\r\n\r\n      case 'translation':\r\n        if (!bundle) {\r\n          throw new TranslationParseError(\r\n            element.sourceSpan,\r\n            '<translation> must be inside a <translationbundle>'\r\n          );\r\n        }\r\n        const id = getAttrOrThrow(element, 'id');\r\n        if (bundle.translations.hasOwnProperty(id)) {\r\n          throw new TranslationParseError(\r\n            element.sourceSpan,\r\n            `Duplicated translations for message \"${id}\"`\r\n          );\r\n        } else {\r\n          try {\r\n            bundle.translations[id] = serializeTargetMessage(element);\r\n          } catch (error) {\r\n            if (typeof error === 'string') {\r\n              this.diagnostics.warn(\r\n                `Could not parse message with id \"${id}\" - perhaps it has an unrecognised ICU format?\\n` +\r\n                  error\r\n              );\r\n            } else {\r\n              throw error;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n\r\n      default:\r\n        throw new TranslationParseError(element.sourceSpan, 'Unexpected tag');\r\n    }\r\n  }\r\n}\r\n\r\nfunction serializeTargetMessage(source: Element): ɵParsedTranslation {\r\n  const serializer = new MessageSerializer(new TargetMessageRenderer(), {\r\n    inlineElements: [],\r\n    placeholder: { elementName: 'ph', nameAttribute: 'name' }\r\n  });\r\n  return serializer.serialize(parseInnerRange(source));\r\n}\r\n"]}