"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const compiler_1 = require("@angular/compiler");
const message_serializer_1 = require("../message_serialization/message_serializer");
const target_message_renderer_1 = require("../message_serialization/target_message_renderer");
const translation_parse_error_1 = require("./translation_parse_error");
const translation_utils_1 = require("./translation_utils");
const base_visitor_1 = require("@angular/localize/src/tools/src/translate/translation_files/base_visitor");
/**
 * A translation parser that can load translations from XLIFF 2 files.
 *
 * http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html
 *
 */
class Xliff2TranslationParser {
    constructor(diagnostics) {
        this.diagnostics = diagnostics;
    }
    canParse(filePath, contents) {
        return translation_utils_1.canParseXml(filePath, contents, 'xliff', { version: '2.0' });
    }
    parse(filePath, contents) {
        const xmlParser = new compiler_1.XmlParser();
        const xml = xmlParser.parse(contents, filePath);
        const bundle = Xliff2TranslationBundleVisitor.extractBundle(xml.rootNodes, this.diagnostics);
        if (bundle === undefined) {
            throw new Error(`Unable to parse "${filePath}" as XLIFF 2.0 format.`);
        }
        return bundle;
    }
}
exports.Xliff2TranslationParser = Xliff2TranslationParser;
class Xliff2TranslationBundleVisitor extends base_visitor_1.BaseVisitor {
    constructor(diagnostics) {
        super();
        this.diagnostics = diagnostics;
    }
    static extractBundle(xliff, diagnostics) {
        const visitor = new this(diagnostics);
        compiler_1.visitAll(visitor, xliff, {});
        return visitor.bundle;
    }
    visitElement(element, { parsedLocale }) {
        if (element.name === 'xliff') {
            parsedLocale = translation_utils_1.getAttribute(element, 'trgLang');
            return compiler_1.visitAll(this, element.children, { parsedLocale });
        }
        else if (element.name === 'file') {
            this.bundle = {
                locale: parsedLocale,
                translations: Xliff2TranslationVisitor.extractTranslations(element),
                diagnostics: this.diagnostics
            };
        }
        else {
            return compiler_1.visitAll(this, element.children, { parsedLocale });
        }
    }
}
class Xliff2TranslationVisitor extends base_visitor_1.BaseVisitor {
    constructor() {
        super(...arguments);
        this.translations = {};
    }
    static extractTranslations(file) {
        const visitor = new this();
        compiler_1.visitAll(visitor, file.children);
        return visitor.translations;
    }
    visitElement(element, context) {
        if (element.name === 'unit') {
            const externalId = translation_utils_1.getAttrOrThrow(element, 'id');
            if (this.translations[externalId] !== undefined) {
                throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, `Duplicated translations for message "${externalId}"`);
            }
            compiler_1.visitAll(this, element.children, { unit: externalId });
        }
        else if (element.name === 'segment') {
            assertTranslationUnit(element, context);
            const targetMessage = element.children.find(isTargetElement);
            if (targetMessage === undefined) {
                throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, 'Missing required <target> element');
            }
            this.translations[context.unit] = serializeTargetMessage(targetMessage);
        }
        else {
            return compiler_1.visitAll(this, element.children);
        }
    }
}
function assertTranslationUnit(segment, context) {
    if (context === undefined || context.unit === undefined) {
        throw new translation_parse_error_1.TranslationParseError(segment.sourceSpan, 'Invalid <segment> element: should be a child of a <unit> element.');
    }
}
function serializeTargetMessage(source) {
    const serializer = new message_serializer_1.MessageSerializer(new target_message_renderer_1.TargetMessageRenderer(), {
        inlineElements: ['cp', 'sc', 'ec', 'mrk', 'sm', 'em'],
        placeholder: {
            elementName: 'ph',
            nameAttribute: 'equiv',
            bodyAttribute: 'disp'
        },
        placeholderContainer: {
            elementName: 'pc',
            startAttribute: 'equivStart',
            endAttribute: 'equivEnd'
        }
    });
    return serializer.serialize(translation_utils_1.parseInnerRange(source));
}
function isTargetElement(node) {
    return node instanceof compiler_1.Element && node.name === 'target';
}
//# sourceMappingURL=xliff2_translation_parser.js.map