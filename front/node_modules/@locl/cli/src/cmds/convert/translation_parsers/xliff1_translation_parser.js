"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const compiler_1 = require("@angular/compiler");
const base_visitor_1 = require("@angular/localize/src/tools/src/translate/translation_files/base_visitor");
const message_serializer_1 = require("../message_serialization/message_serializer");
const target_message_renderer_1 = require("../message_serialization/target_message_renderer");
const translation_parse_error_1 = require("./translation_parse_error");
const translation_utils_1 = require("./translation_utils");
/**
 * A translation parser that can load XLIFF 1.2 files.
 *
 * http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html
 * http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html
 *
 */
class Xliff1TranslationParser {
    constructor(diagnostics) {
        this.diagnostics = diagnostics;
    }
    canParse(filePath, contents) {
        return translation_utils_1.canParseXml(filePath, contents, 'xliff', { version: '1.2' });
    }
    parse(filePath, contents) {
        const xmlParser = new compiler_1.XmlParser();
        const xml = xmlParser.parse(contents, filePath);
        const bundle = XliffFileElementVisitor.extractBundle(xml.rootNodes, this.diagnostics);
        if (bundle === undefined) {
            throw new Error(`Unable to parse "${filePath}" as XLIFF 1.2 format.`);
        }
        return bundle;
    }
}
exports.Xliff1TranslationParser = Xliff1TranslationParser;
class XliffFileElementVisitor extends base_visitor_1.BaseVisitor {
    constructor(diagnostics) {
        super();
        this.diagnostics = diagnostics;
    }
    static extractBundle(xliff, diagnostics) {
        const visitor = new this(diagnostics);
        compiler_1.visitAll(visitor, xliff);
        return visitor.bundle;
    }
    visitElement(element) {
        if (element.name === 'file') {
            this.bundle = {
                locale: translation_utils_1.getAttribute(element, 'target-language'),
                translations: XliffTranslationVisitor.extractTranslations(element),
                diagnostics: this.diagnostics
            };
        }
        else {
            return compiler_1.visitAll(this, element.children);
        }
    }
}
class XliffTranslationVisitor extends base_visitor_1.BaseVisitor {
    constructor() {
        super(...arguments);
        this.translations = {};
    }
    static extractTranslations(file) {
        const visitor = new this();
        compiler_1.visitAll(visitor, file.children);
        return visitor.translations;
    }
    visitElement(element) {
        if (element.name === 'trans-unit') {
            const id = translation_utils_1.getAttrOrThrow(element, 'id');
            if (this.translations[id] !== undefined) {
                throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, `Duplicated translations for message "${id}"`);
            }
            let meaning, description;
            element.children.forEach(el => {
                if (isTargetElement(el)) {
                    this.translations[id] = serializeTargetMessage(el);
                }
                else if (isSourceElement(el) && !this.translations[id]) {
                    this.translations[id] = serializeTargetMessage(el);
                }
                else if (isNoteElement(el)) {
                    const from = el.attrs.find(attr => attr.name === 'from');
                    if (el.children.length) {
                        const value = el.children[0].value;
                        if (from.value === 'description') {
                            description = value;
                        }
                        else if (from.value === 'meaning') {
                            meaning = value;
                        }
                    }
                }
            });
            if (this.translations[id] === undefined) {
                throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, 'Missing required <target> element');
            }
            else {
                if (description) {
                    this.translations[id].description = description;
                }
                if (meaning) {
                    this.translations[id].meaning = meaning;
                }
            }
        }
        else {
            return compiler_1.visitAll(this, element.children);
        }
    }
}
function serializeTargetMessage(source) {
    const serializer = new message_serializer_1.MessageSerializer(new target_message_renderer_1.TargetMessageRenderer(), {
        inlineElements: ['g', 'bx', 'ex', 'bpt', 'ept', 'ph', 'it', 'mrk'],
        placeholder: { elementName: 'x', nameAttribute: 'id' }
    });
    return serializer.serialize(translation_utils_1.parseInnerRange(source));
}
function isSourceElement(node) {
    return node instanceof compiler_1.Element && node.name === 'source';
}
function isTargetElement(node) {
    return node instanceof compiler_1.Element && node.name === 'target';
}
function isNoteElement(node) {
    return node instanceof compiler_1.Element && node.name === 'note';
}
//# sourceMappingURL=xliff1_translation_parser.js.map