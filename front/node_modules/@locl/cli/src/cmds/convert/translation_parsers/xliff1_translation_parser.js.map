{"version":3,"file":"xliff1_translation_parser.js","sourceRoot":"","sources":["../../../../../../../libs/cli/src/cmds/convert/translation_parsers/xliff1_translation_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Element, Node, XmlParser, visitAll, Text } from '@angular/compiler';\nimport { ɵMessageId } from '@angular/localize';\nimport { Diagnostics } from '../../common/diagnostics';\nimport { BaseVisitor } from '@angular/localize/src/tools/src/translate/translation_files/base_visitor';\n\nimport { MessageSerializer } from '../message_serialization/message_serializer';\nimport { TargetMessageRenderer } from '../message_serialization/target_message_renderer';\nimport { TranslationParseError } from './translation_parse_error';\nimport {\n  ParsedTranslationBundle,\n  TranslationParser\n} from './translation_parser';\nimport {\n  getAttrOrThrow,\n  getAttribute,\n  parseInnerRange,\n  canParseXml,\n  XmlTranslationParserHint\n} from './translation_utils';\nimport { ParsedTranslation } from '../translations';\n\n/**\n * A translation parser that can load XLIFF 1.2 files.\n *\n * http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n * http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\n *\n */\nexport class Xliff1TranslationParser\n  implements TranslationParser<XmlTranslationParserHint> {\n  constructor(private diagnostics: Diagnostics) {}\n\n  canParse(\n    filePath: string,\n    contents: string\n  ): XmlTranslationParserHint | false {\n    return canParseXml(filePath, contents, 'xliff', { version: '1.2' });\n  }\n\n  parse(filePath: string, contents: string): ParsedTranslationBundle {\n    const xmlParser = new XmlParser();\n    const xml = xmlParser.parse(contents, filePath);\n    const bundle = XliffFileElementVisitor.extractBundle(\n      xml.rootNodes,\n      this.diagnostics\n    );\n    if (bundle === undefined) {\n      throw new Error(`Unable to parse \"${filePath}\" as XLIFF 1.2 format.`);\n    }\n    return bundle;\n  }\n}\n\nclass XliffFileElementVisitor extends BaseVisitor {\n  private bundle: ParsedTranslationBundle | undefined;\n\n  constructor(private diagnostics: Diagnostics) {\n    super();\n  }\n\n  static extractBundle(\n    xliff: Node[],\n    diagnostics: Diagnostics\n  ): ParsedTranslationBundle | undefined {\n    const visitor = new this(diagnostics);\n    visitAll(visitor, xliff);\n    return visitor.bundle;\n  }\n\n  visitElement(element: Element): any {\n    if (element.name === 'file') {\n      this.bundle = {\n        locale: getAttribute(element, 'target-language'),\n        translations: XliffTranslationVisitor.extractTranslations(element),\n        diagnostics: this.diagnostics\n      };\n    } else {\n      return visitAll(this, element.children);\n    }\n  }\n}\n\nclass XliffTranslationVisitor extends BaseVisitor {\n  private translations: Record<ɵMessageId, ParsedTranslation> = {};\n\n  static extractTranslations(file: Element): Record<string, ParsedTranslation> {\n    const visitor = new this();\n    visitAll(visitor, file.children);\n    return visitor.translations;\n  }\n\n  visitElement(element: Element): any {\n    if (element.name === 'trans-unit') {\n      const id = getAttrOrThrow(element, 'id');\n      if (this.translations[id] !== undefined) {\n        throw new TranslationParseError(\n          element.sourceSpan,\n          `Duplicated translations for message \"${id}\"`\n        );\n      }\n\n      let meaning, description;\n      element.children.forEach(el => {\n        if (isTargetElement(el)) {\n          this.translations[id] = serializeTargetMessage(el);\n        } else if (isSourceElement(el) && !this.translations[id]) {\n          this.translations[id] = serializeTargetMessage(el);\n        } else if (isNoteElement(el)) {\n          const from = el.attrs.find(attr => attr.name === 'from');\n          if (el.children.length) {\n            const value = (el.children[0] as Text).value;\n            if (from.value === 'description') {\n              description = value;\n            } else if (from.value === 'meaning') {\n              meaning = value;\n            }\n          }\n        }\n      });\n\n      if (this.translations[id] === undefined) {\n        throw new TranslationParseError(\n          element.sourceSpan,\n          'Missing required <target> element'\n        );\n      } else {\n        if (description) {\n          this.translations[id].description = description;\n        }\n        if (meaning) {\n          this.translations[id].meaning = meaning;\n        }\n      }\n    } else {\n      return visitAll(this, element.children);\n    }\n  }\n}\n\nfunction serializeTargetMessage(source: Element): ParsedTranslation {\n  const serializer = new MessageSerializer(new TargetMessageRenderer(), {\n    inlineElements: ['g', 'bx', 'ex', 'bpt', 'ept', 'ph', 'it', 'mrk'],\n    placeholder: { elementName: 'x', nameAttribute: 'id' }\n  });\n  return serializer.serialize(parseInnerRange(source));\n}\n\nfunction isSourceElement(node: Node): node is Element {\n  return node instanceof Element && node.name === 'source';\n}\n\nfunction isTargetElement(node: Node): node is Element {\n  return node instanceof Element && node.name === 'target';\n}\n\nfunction isNoteElement(node: Node): node is Element {\n  return node instanceof Element && node.name === 'note';\n}\n"]}