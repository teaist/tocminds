{"version":3,"file":"translation_utils.js","sourceRoot":"","sources":["../../../../../../../libs/cli/src/cmds/convert/translation_parsers/translation_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  Element,\n  LexerRange,\n  Node,\n  ParseError,\n  ParseErrorLevel,\n  ParseSourceSpan,\n  XmlParser\n} from '@angular/compiler';\nimport { Diagnostics } from '../../common/diagnostics';\nimport { TranslationParseError } from './translation_parse_error';\n\nexport function getAttrOrThrow(element: Element, attrName: string): string {\n  const attrValue = getAttribute(element, attrName);\n  if (attrValue === undefined) {\n    throw new TranslationParseError(\n      element.sourceSpan,\n      `Missing required \"${attrName}\" attribute:`\n    );\n  }\n  return attrValue;\n}\n\nexport function getAttribute(\n  element: Element,\n  attrName: string\n): string | undefined {\n  const attr = element.attrs.find(a => a.name === attrName);\n  return attr !== undefined ? attr.value : undefined;\n}\n\nexport function parseInnerRange(element: Element): Node[] {\n  const xmlParser = new XmlParser();\n  const xml = xmlParser.parse(\n    element.sourceSpan.start.file.content,\n    element.sourceSpan.start.file.url,\n    { tokenizeExpansionForms: true, range: getInnerRange(element) }\n  );\n  if (xml.errors.length) {\n    throw xml.errors\n      .map(e => new TranslationParseError(e.span, e.msg).toString())\n      .join('\\n');\n  }\n  return xml.rootNodes;\n}\n\nfunction getInnerRange(element: Element): LexerRange {\n  const start = element.startSourceSpan!.end;\n  const end = element.endSourceSpan!.start;\n  return {\n    startPos: start.offset,\n    startLine: start.line,\n    startCol: start.col,\n    endPos: end.offset\n  };\n}\n\n/**\n * Create a predicate, which can be used by things like `Array.filter()`, that will match a named\n * XML Element from a collection of XML Nodes.\n *\n * @param name The expected name of the element to match.\n */\nexport function isNamedElement(name: string): (node: Node) => node is Element {\n  function predicate(node: Node): node is Element {\n    return node instanceof Element && node.name === name;\n  }\n  return predicate;\n}\n\n/**\n * This \"hint\" object is used to pass information from `canParse()` to `parse()` for\n * `TranslationParser`s that expect XML contents.\n *\n * This saves the `parse()` method from having to re-parse the XML.\n */\nexport interface XmlTranslationParserHint {\n  element: Element;\n  errors: ParseError[];\n}\n\n/**\n * Can this XML be parsed for translations, given the expected `rootNodeName` and expected root node\n * `attributes` that should appear in the file.\n *\n * @param filePath The path to the file being checked.\n * @param contents The contents of the file being checked.\n * @param rootNodeName The expected name of an XML root node that should exist.\n * @param attributes The attributes (and their values) that should appear on the root node.\n * @returns The `XmlTranslationParserHint` object for use by `TranslationParser.parse()` if the XML\n * document has the expected format.\n */\nexport function canParseXml(\n  filePath: string,\n  contents: string,\n  rootNodeName: string,\n  attributes: Record<string, string>\n): XmlTranslationParserHint | false {\n  const xmlParser = new XmlParser();\n  const xml = xmlParser.parse(contents, filePath);\n\n  if (\n    xml.rootNodes.length === 0 ||\n    xml.errors.some(error => error.level === ParseErrorLevel.ERROR)\n  ) {\n    return false;\n  }\n\n  const rootElements = xml.rootNodes.filter(isNamedElement(rootNodeName));\n  const rootElement = rootElements[0];\n  if (rootElement === undefined) {\n    return false;\n  }\n\n  for (const attrKey of Object.keys(attributes)) {\n    const attr = rootElement.attrs.find(a => a.name === attrKey);\n    if (attr === undefined || attr.value !== attributes[attrKey]) {\n      return false;\n    }\n  }\n\n  if (rootElements.length > 1) {\n    xml.errors.push(\n      new ParseError(\n        xml.rootNodes[1].sourceSpan,\n        'Unexpected root node. XLIFF 1.2 files should only have a single <xliff> root node.',\n        ParseErrorLevel.WARNING\n      )\n    );\n  }\n\n  return { element: rootElement, errors: xml.errors };\n}\n\n/**\n * Add an XML parser related message to the given `diagnostics` object.\n */\nexport function addParseDiagnostic(\n  diagnostics: Diagnostics,\n  sourceSpan: ParseSourceSpan,\n  message: string,\n  level: ParseErrorLevel\n): void {\n  addParseError(diagnostics, new ParseError(sourceSpan, message, level));\n}\n\n/**\n * Copy the formatted error message from the given `parseError` object into the given `diagnostics`\n * object.\n */\nexport function addParseError(\n  diagnostics: Diagnostics,\n  parseError: ParseError\n): void {\n  if (parseError.level === ParseErrorLevel.ERROR) {\n    diagnostics.error(parseError.toString());\n  } else {\n    diagnostics.warn(parseError.toString());\n  }\n}\n"]}