"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const compiler_1 = require("@angular/compiler");
const path_1 = require("path");
const message_serializer_1 = require("../message_serialization/message_serializer");
const target_message_renderer_1 = require("../message_serialization/target_message_renderer");
const translation_parse_error_1 = require("./translation_parse_error");
const translation_utils_1 = require("./translation_utils");
const base_visitor_1 = require("@angular/localize/src/tools/src/translate/translation_files/base_visitor");
/**
 * A translation parser that can load XB files.
 */
class XtbTranslationParser {
    constructor(diagnostics) {
        this.diagnostics = diagnostics;
    }
    canParse(filePath, contents) {
        const extension = path_1.extname(filePath);
        if (extension !== '.xtb' && extension !== '.xmb') {
            return false;
        }
        return translation_utils_1.canParseXml(filePath, contents, 'translationbundle', {});
    }
    parse(filePath, contents) {
        const xmlParser = new compiler_1.XmlParser();
        const xml = xmlParser.parse(contents, filePath);
        const bundle = XtbVisitor.extractBundle(this.diagnostics, xml.rootNodes);
        if (bundle === undefined) {
            throw new Error(`Unable to parse "${filePath}" as XTB/XMB format.`);
        }
        return bundle;
    }
}
exports.XtbTranslationParser = XtbTranslationParser;
class XtbVisitor extends base_visitor_1.BaseVisitor {
    constructor(diagnostics) {
        super();
        this.diagnostics = diagnostics;
    }
    static extractBundle(diagnostics, messageBundles) {
        const visitor = new this(diagnostics);
        const bundles = compiler_1.visitAll(visitor, messageBundles, undefined);
        return bundles[0];
    }
    visitElement(element, bundle) {
        switch (element.name) {
            case 'translationbundle':
                if (bundle) {
                    throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, '<translationbundle> elements can not be nested');
                }
                const langAttr = element.attrs.find(attr => attr.name === 'lang');
                bundle = {
                    locale: langAttr && langAttr.value,
                    translations: {},
                    diagnostics: this.diagnostics
                };
                compiler_1.visitAll(this, element.children, bundle);
                return bundle;
            case 'translation':
                if (!bundle) {
                    throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, '<translation> must be inside a <translationbundle>');
                }
                const id = translation_utils_1.getAttrOrThrow(element, 'id');
                if (bundle.translations.hasOwnProperty(id)) {
                    throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, `Duplicated translations for message "${id}"`);
                }
                else {
                    try {
                        bundle.translations[id] = serializeTargetMessage(element);
                    }
                    catch (error) {
                        if (typeof error === 'string') {
                            this.diagnostics.warn(`Could not parse message with id "${id}" - perhaps it has an unrecognised ICU format?\n` +
                                error);
                        }
                        else {
                            throw error;
                        }
                    }
                }
                break;
            default:
                throw new translation_parse_error_1.TranslationParseError(element.sourceSpan, 'Unexpected tag');
        }
    }
}
function serializeTargetMessage(source) {
    const serializer = new message_serializer_1.MessageSerializer(new target_message_renderer_1.TargetMessageRenderer(), {
        inlineElements: [],
        placeholder: { elementName: 'ph', nameAttribute: 'name' }
    });
    return serializer.serialize(translation_utils_1.parseInnerRange(source));
}
//# sourceMappingURL=xtb_translation_parser.js.map