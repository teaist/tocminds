"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const translation_loader_1 = require("@angular/localize/src/tools/src/translate/translation_files/translation_loader");
const glob = require("glob");
const path_1 = require("path");
const diagnostics_1 = require("./common/diagnostics");
const file_utils_1 = require("./common/file_utils");
const util_1 = require("./common/util");
const simple_json_translation_parser_1 = require("./convert/translation_parsers/simple_json_translation_parser");
const xliff1_translation_parser_1 = require("./convert/translation_parsers/xliff1_translation_parser");
const xliff2_translation_parser_1 = require("./convert/translation_parsers/xliff2_translation_parser");
const xtb_translation_parser_1 = require("./convert/translation_parsers/xtb_translation_parser");
exports.command = 'convert';
exports.describe = 'Convert translation files from one format to another';
exports.builder = {
    s: {
        alias: 'source',
        required: true,
        describe: 'A glob pattern indicating what files to convert, e.g. `./assets/**/*.xlf`. This can be absolute or relative to the current working directory. Only translation files are supported (json, xtb & xlf but not xmb).'
    },
    f: {
        alias: 'format',
        required: true,
        describe: 'The format of the translation files to generate.',
        choices: ['json', 'xlf', 'xtb', 'xlf2'],
        default: 'json'
    },
    o: {
        alias: 'outputPath',
        required: true,
        describe: 'A path to where the converted files will be written. This can be absolute or relative to the current working directory.'
    }
};
exports.handler = function (options) {
    const diagnostics = new diagnostics_1.Diagnostics();
    convertFiles({
        sourceGlob: path_1.resolve(options['s']),
        format: options['f'],
        outputPath: path_1.resolve(options['o']),
        diagnostics
    });
    diagnostics.logMessages();
    process.exit(diagnostics.hasErrors ? 1 : 0);
};
function convertFiles({ sourceGlob: source, format, outputPath: output, diagnostics }) {
    console.log(`Converting files from source "${source}" to format "${format}" and output "${output}"`);
    const filesToProcess = glob.sync(source, {
        absolute: true,
        nodir: true
    });
    const translationLoader = new translation_loader_1.TranslationLoader([
        new xliff2_translation_parser_1.Xliff2TranslationParser(diagnostics),
        new xliff1_translation_parser_1.Xliff1TranslationParser(diagnostics),
        new xtb_translation_parser_1.XtbTranslationParser(diagnostics),
        new simple_json_translation_parser_1.SimpleJsonTranslationParser(diagnostics)
    ]);
    const translationBundles = translationLoader.loadBundles(filesToProcess, []);
    if (translationBundles.length) {
        const messages = [];
        translationBundles.forEach(translationBundle => {
            const translations = translationBundle.translations;
            messages.push(...Object.keys(translations).map(id => util_1.translationToMessage(id, translations[id])));
        });
        const serializer = util_1.getTranslationSerializer(format);
        const translationFile = serializer.renderFile(messages, translationBundles[0].locale, true);
        file_utils_1.FileUtils.writeFile(path_1.posix.normalize(output), translationFile);
    }
    else {
        diagnostics.error(`Couldn't find any file to convert.`);
    }
}
exports.convertFiles = convertFiles;
//# sourceMappingURL=convert.js.map