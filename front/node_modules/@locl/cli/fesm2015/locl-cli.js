import { NgModule } from '@angular/core';
import { readFileSync, writeFileSync, existsSync, mkdirSync, statSync, unlinkSync, readdirSync, rmdirSync } from 'fs';
import { sync } from 'glob';
import { dirname, resolve, extname, posix, basename } from 'path';
import { blue, red, yellow } from 'chalk';
import { transformSync } from '@babel/core';
import { ɵmakeTemplateObject, ɵtranslate, ɵisMissingTranslationError, ɵparseMessage } from '@angular/localize';
import { stringLiteral, binaryExpression, isExpression, isBinaryExpression, parenthesizedExpression, isArrayExpression, isStringLiteral } from '@babel/types';
import { config as config$1 } from 'yargs';
import { sync as sync$1 } from 'find-up';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cli.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// not used, only there to make ng-packagr happy
class CliModule {
}
CliModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [],
                exports: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/common/diagnostics.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This class is used to collect and then report warnings and errors that occur during the execution
 * of the tools.
 */
class Diagnostics {
    constructor() {
        this.messages = [];
    }
    /**
     * @return {?}
     */
    get hasErrors() {
        return this.messages.some((/**
         * @param {?} m
         * @return {?}
         */
        m => m.type === 'error'));
    }
    /**
     * @param {?} message
     * @return {?}
     */
    log(message) {
        this.messages.push({ type: '', message });
    }
    /**
     * @param {?} message
     * @return {?}
     */
    warn(message) {
        this.messages.push({ type: 'warning', message });
    }
    /**
     * @param {?} message
     * @return {?}
     */
    error(message) {
        this.messages.push({ type: 'error', message });
    }
    /**
     * @param {?} message
     * @return {?}
     */
    formatDiagnostics(message) {
        /** @type {?} */
        const errors = (/** @type {?} */ (this.messages)).filter((/**
         * @param {?} d
         * @return {?}
         */
        d => d.type === 'error')).map((/**
         * @param {?} d
         * @return {?}
         */
        d => ' - ' + d.message));
        /** @type {?} */
        const warnings = (/** @type {?} */ (this.messages)).filter((/**
         * @param {?} d
         * @return {?}
         */
        d => d.type === 'warning')).map((/**
         * @param {?} d
         * @return {?}
         */
        d => ' - ' + d.message));
        if (errors.length) {
            message += '\nERRORS:\n' + errors.join('\n');
        }
        if (warnings.length) {
            message += '\nWARNINGS:\n' + warnings.join('\n');
        }
        return message;
    }
    /**
     * @return {?}
     */
    logMessages() {
        while (this.messages.length) {
            /** @type {?} */
            const m = this.messages.shift();
            switch (m.type) {
                case 'warning':
                    console.warn(yellow(`Warning: ${m.message}`));
                    break;
                case 'error':
                    console.error(red(`Error: ${m.message}`));
                    break;
                default:
                    console.log(blue(`${m.message}`));
            }
        }
    }
}
if (false) {
    /** @type {?} */
    Diagnostics.prototype.messages;
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/common/file_utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUtils {
    /**
     * @param {?} absolutePath
     * @return {?}
     */
    static readFile(absolutePath) {
        return readFileSync(absolutePath, 'utf8');
    }
    /**
     * @param {?} absolutePath
     * @return {?}
     */
    static readFileBuffer(absolutePath) {
        return readFileSync(absolutePath);
    }
    /**
     * @param {?} absolutePath
     * @param {?} contents
     * @return {?}
     */
    static writeFile(absolutePath, contents) {
        FileUtils.ensureDir(dirname(absolutePath));
        writeFileSync(absolutePath, contents);
    }
    /**
     * @param {?} absolutePath
     * @return {?}
     */
    static ensureDir(absolutePath) {
        /** @type {?} */
        const parents = [];
        while (!FileUtils.isRoot(absolutePath) && !existsSync(absolutePath)) {
            parents.push(absolutePath);
            absolutePath = dirname(absolutePath);
        }
        while (parents.length) {
            mkdirSync((/** @type {?} */ (parents.pop())));
        }
    }
    /**
     * @param {?} p
     * @return {?}
     */
    static remove(p) {
        /** @type {?} */
        const stat = statSync(p);
        if (stat.isFile()) {
            unlinkSync(p);
        }
        else if (stat.isDirectory()) {
            readdirSync(p).forEach((/**
             * @param {?} child
             * @return {?}
             */
            child => {
                /** @type {?} */
                const absChild = resolve(p, child);
                FileUtils.remove(absChild);
            }));
            rmdirSync(p);
        }
    }
    /**
     * @param {?} absolutePath
     * @return {?}
     */
    static isRoot(absolutePath) {
        return dirname(absolutePath) === absolutePath;
    }
    /**
     * @param {?} files
     * @param {?} pattern
     * @param {?=} replaceValue
     * @return {?}
     */
    static dedup(files, pattern, replaceValue = '') {
        /** @type {?} */
        const filesSet = files.map((/**
         * @param {?} file
         * @return {?}
         */
        file => file.replace(pattern, replaceValue)));
        /** @type {?} */
        const dedup = [];
        /** @type {?} */
        const indexes = [];
        filesSet.forEach((/**
         * @param {?} file
         * @param {?} index
         * @return {?}
         */
        (file, index) => {
            if (dedup.indexOf(file) === -1) {
                dedup.push(file);
                indexes.push(index);
            }
        }));
        return indexes.map((/**
         * @param {?} index
         * @return {?}
         */
        index => files[index]));
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/json_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function SimpleJsonTranslationFile() { }
if (false) {
    /** @type {?} */
    SimpleJsonTranslationFile.prototype.locale;
    /** @type {?} */
    SimpleJsonTranslationFile.prototype.translations;
}
class JsonTranslationSerializer {
    /**
     * @param {?} messages
     * @param {?} locale
     * @return {?}
     */
    renderFile(messages, locale) {
        /** @type {?} */
        const fileObj = {
            locale,
            translations: {}
        };
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        message => {
            fileObj.translations[((/** @type {?} */ (message))).id ||
                ((/** @type {?} */ (message))).messageId] =
                ((/** @type {?} */ (message))).text ||
                    ((/** @type {?} */ (message))).messageString;
        }));
        return JSON.stringify(fileObj, null, 2);
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xml_file.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @record
 */
function Options() { }
if (false) {
    /** @type {?|undefined} */
    Options.prototype.selfClosing;
    /** @type {?|undefined} */
    Options.prototype.preserveWhitespace;
}
class XmlFile {
    constructor() {
        this.output = '';
        this.indent = '';
        this.elements = [];
        this.preservingWhitespace = false;
    }
    /**
     * @return {?}
     */
    toString() {
        return this.output;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @param {?=} attributes
     * @param {?=} __2
     * @return {THIS}
     */
    startTag(name, attributes = {}, { selfClosing = false, preserveWhitespace } = {}) {
        if (!(/** @type {?} */ (this)).preservingWhitespace) {
            (/** @type {?} */ (this)).output += (/** @type {?} */ (this)).indent;
        }
        (/** @type {?} */ (this)).output += `<${name}`;
        Object.keys(attributes).forEach((/**
         * @param {?} attrName
         * @return {?}
         */
        attrName => {
            if (attributes[attrName]) {
                (/** @type {?} */ (this)).output += ` ${attrName}="${escapeXml(attributes[attrName])}"`;
            }
        }));
        if (selfClosing) {
            (/** @type {?} */ (this)).output += '/>';
        }
        else {
            (/** @type {?} */ (this)).output += '>';
            (/** @type {?} */ (this)).elements.push(name);
            (/** @type {?} */ (this)).incIndent();
        }
        if (preserveWhitespace !== undefined) {
            (/** @type {?} */ (this)).preservingWhitespace = preserveWhitespace;
        }
        if (!(/** @type {?} */ (this)).preservingWhitespace) {
            (/** @type {?} */ (this)).output += `\n`;
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} name
     * @param {?=} __1
     * @return {THIS}
     */
    endTag(name, { preserveWhitespace } = {}) {
        /** @type {?} */
        const expectedTag = (/** @type {?} */ (this)).elements.pop();
        if (expectedTag !== name) {
            throw new Error(`Unexpected closing tag: "${name}", expected: "${expectedTag}"`);
        }
        (/** @type {?} */ (this)).decIndent();
        if (!(/** @type {?} */ (this)).preservingWhitespace) {
            (/** @type {?} */ (this)).output += (/** @type {?} */ (this)).indent;
        }
        (/** @type {?} */ (this)).output += `</${name}>`;
        if (preserveWhitespace !== undefined) {
            (/** @type {?} */ (this)).preservingWhitespace = preserveWhitespace;
        }
        if (!(/** @type {?} */ (this)).preservingWhitespace) {
            (/** @type {?} */ (this)).output += `\n`;
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} str
     * @return {THIS}
     */
    text(str) {
        (/** @type {?} */ (this)).output += escapeXml(str);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    startPreserveWhitespace() {
        this.preservingWhitespace = true;
    }
    /**
     * @return {?}
     */
    stopPreserveWhitespace() {
        this.preservingWhitespace = false;
    }
    /**
     * @private
     * @return {?}
     */
    incIndent() {
        this.indent = this.indent + '  ';
    }
    /**
     * @private
     * @return {?}
     */
    decIndent() {
        this.indent = this.indent.slice(0, -2);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    XmlFile.prototype.output;
    /**
     * @type {?}
     * @private
     */
    XmlFile.prototype.indent;
    /**
     * @type {?}
     * @private
     */
    XmlFile.prototype.elements;
    /**
     * @type {?}
     * @private
     */
    XmlFile.prototype.preservingWhitespace;
}
/** @type {?} */
const _ESCAPED_CHARS = [
    [/&/g, '&amp;'],
    [/"/g, '&quot;'],
    [/'/g, '&apos;'],
    [/</g, '&lt;'],
    [/>/g, '&gt;']
];
/**
 * @param {?} text
 * @return {?}
 */
function escapeXml(text) {
    return _ESCAPED_CHARS.reduce((/**
     * @param {?} t
     * @param {?} entry
     * @return {?}
     */
    (t, entry) => t.replace(entry[0], entry[1])), text);
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xliff1_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Xliff1TranslationSerializer {
    /**
     * @param {?} messages
     * @param {?} locale
     * @param {?=} isTarget
     * @return {?}
     */
    renderFile(messages, locale, isTarget = false) {
        /** @type {?} */
        const xml = new XmlFile();
        xml.startTag('xliff', {
            version: '1.2',
            xmlns: 'urn:oasis:names:tc:xliff:document:1.2'
        });
        /** @type {?} */
        const fileAttrs = {
            ['source-language']: isTarget ? undefined : locale,
            ['target-language']: locale,
            datatype: 'plaintext'
        };
        xml.startTag('file', fileAttrs);
        xml.startTag('body');
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        message => {
            xml.startTag('trans-unit', {
                id: ((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId,
                datatype: 'html'
            });
            if (!isTarget) {
                this.generateMessageTag(xml, 'source', message);
            }
            this.generateMessageTag(xml, 'target', message);
            if (message.description) {
                this.renderNote(xml, 'description', message.description);
            }
            if (message.meaning) {
                this.renderNote(xml, 'meaning', message.meaning);
            }
            xml.endTag('trans-unit');
        }));
        xml.endTag('body');
        xml.endTag('file');
        xml.endTag('xliff');
        return xml.toString();
    }
    /**
     * @private
     * @param {?} xml
     * @param {?} tagName
     * @param {?} message
     * @return {?}
     */
    generateMessageTag(xml, tagName, message) {
        xml.startTag(tagName, {}, { preserveWhitespace: true });
        this.renderMessage(xml, message);
        xml.endTag(tagName, { preserveWhitespace: false });
    }
    /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    renderMessage(xml, message) {
        xml.text(message.messageParts[0]);
        for (let i = 1; i < message.messageParts.length; i++) {
            xml.startTag('x', { id: message.placeholderNames[i - 1] }, { selfClosing: true });
            xml.text(message.messageParts[i]);
        }
    }
    /**
     * @private
     * @param {?} xml
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    renderNote(xml, name, value) {
        xml.startTag('note', { priority: '1', from: name }, { preserveWhitespace: true });
        xml.text(value);
        xml.endTag('note', { preserveWhitespace: false });
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xliff2_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Xliff2TranslationSerializer {
    /**
     * @param {?} messages
     * @param {?} locale
     * @param {?=} isTarget
     * @return {?}
     */
    renderFile(messages, locale, isTarget = false) {
        /** @type {?} */
        const xml = new XmlFile();
        xml.startTag('xliff', {
            version: '2.0',
            xmlns: 'urn:oasis:names:tc:xliff:document:2.0',
            srcLang: locale,
            trgLang: locale
        });
        xml.startTag('file');
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        message => {
            xml.startTag('unit', {
                id: ((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId
            });
            if (message.meaning || message.description) {
                xml.startTag('notes');
                if (message.description) {
                    this.renderNote(xml, 'description', message.description);
                }
                if (message.meaning) {
                    this.renderNote(xml, 'meaning', message.meaning);
                }
                xml.endTag('notes');
            }
            xml.startTag('segment');
            if (!isTarget) {
                this.generateMessageTag(xml, 'source', message);
            }
            this.generateMessageTag(xml, 'target', message);
            xml.endTag('segment');
            xml.endTag('unit');
        }));
        xml.endTag('file');
        xml.endTag('xliff');
        return xml.toString();
    }
    /**
     * @private
     * @param {?} xml
     * @param {?} tagName
     * @param {?} message
     * @return {?}
     */
    generateMessageTag(xml, tagName, message) {
        xml.startTag(tagName, {}, { preserveWhitespace: true });
        this.renderMessage(xml, message);
        xml.endTag(tagName, { preserveWhitespace: false });
    }
    /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    renderMessage(xml, message) {
        xml.text(message.messageParts[0]);
        for (let i = 1; i < message.messageParts.length; i++) {
            /** @type {?} */
            const placeholderName = message.placeholderNames[i - 1];
            if (placeholderName.startsWith('START_')) {
                xml.startTag('pc', {
                    id: `${i}`,
                    equivStart: placeholderName,
                    equivEnd: placeholderName.replace(/^START/, 'CLOSE')
                });
            }
            else if (placeholderName.startsWith('CLOSE_')) {
                xml.endTag('pc');
            }
            else {
                xml.startTag('ph', { id: `${i}`, equiv: placeholderName }, { selfClosing: true });
            }
            xml.text(message.messageParts[i]);
        }
    }
    /**
     * @private
     * @param {?} xml
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    renderNote(xml, name, value) {
        xml.startTag('note', { category: name }, { preserveWhitespace: true });
        xml.text(value);
        xml.endTag('note', { preserveWhitespace: false });
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xmb_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DOCTYPE = `<!ELEMENT messagebundle (msg)*>
<!ATTLIST messagebundle class CDATA #IMPLIED>

<!ELEMENT msg (#PCDATA|ph|source)*>
<!ATTLIST msg id CDATA #IMPLIED>
<!ATTLIST msg seq CDATA #IMPLIED>
<!ATTLIST msg name CDATA #IMPLIED>
<!ATTLIST msg desc CDATA #IMPLIED>
<!ATTLIST msg meaning CDATA #IMPLIED>
<!ATTLIST msg obsolete (obsolete) #IMPLIED>
<!ATTLIST msg xml:space (default|preserve) "default">
<!ATTLIST msg is_hidden CDATA #IMPLIED>

<!ELEMENT source (#PCDATA)>

<!ELEMENT ph (#PCDATA|ex)*>
<!ATTLIST ph name CDATA #REQUIRED>

<!ELEMENT ex (#PCDATA)>`;
class XmbTranslationSerializer {
    /**
     * @param {?} messages
     * @return {?}
     */
    renderFile(messages) {
        /** @type {?} */
        const xml = new XmlFile();
        xml.startTag('messagebundle');
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        message => {
            xml.startTag('msg', {
                id: ((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId,
                desc: message.description,
                meaning: message.meaning
            }, { preserveWhitespace: true });
            this.renderMessage(xml, message);
            xml.endTag('msg', { preserveWhitespace: false });
        }));
        xml.endTag('messagebundle');
        return xml.toString();
    }
    /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    renderMessage(xml, message) {
        xml.text(message.messageParts[0]);
        for (let i = 1; i < message.messageParts.length; i++) {
            xml.startTag('ph', { name: message.placeholderNames[i - 1] }, { selfClosing: true });
            xml.text(message.messageParts[i]);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/translation_files/xtb_translation_serializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DOCTYPE$1 = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE translationbundle [
<!ELEMENT translationbundle (translation)*>
<!ATTLIST translationbundle lang CDATA #REQUIRED>

<!ELEMENT translation (#PCDATA|ph)*>
<!ATTLIST translation id CDATA #REQUIRED>
<!ATTLIST translation desc CDATA #IMPLIED>
<!ATTLIST translation meaning CDATA #IMPLIED>
<!ATTLIST translation xml:space (default|preserve) "default">

<!ELEMENT ph (#PCDATA|ex)*>
<!ATTLIST ph name CDATA #REQUIRED>

<!ELEMENT ex (#PCDATA)>
]>
`;
class XtbTranslationSerializer {
    /**
     * @param {?} messages
     * @param {?} locale
     * @return {?}
     */
    renderFile(messages, locale) {
        /** @type {?} */
        const xml = new XmlFile();
        xml.startTag('translationbundle', { lang: locale });
        messages.forEach((/**
         * @param {?} message
         * @return {?}
         */
        message => {
            xml.startTag('translation', {
                id: ((/** @type {?} */ (message))).id ||
                    ((/** @type {?} */ (message))).messageId,
                desc: message.description,
                meaning: message.meaning
            }, { preserveWhitespace: true });
            this.renderMessage(xml, message);
            xml.endTag('translation', { preserveWhitespace: false });
        }));
        xml.endTag('translationbundle');
        return DOCTYPE$1 + xml.toString();
    }
    /**
     * @private
     * @param {?} xml
     * @param {?} message
     * @return {?}
     */
    renderMessage(xml, message) {
        xml.text(message.messageParts[0]);
        for (let i = 1; i < message.messageParts.length; i++) {
            xml.startTag('ph', { name: message.placeholderNames[i - 1] }, { selfClosing: true });
            xml.text(message.messageParts[i]);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/common/util.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} format
 * @return {?}
 */
function getTranslationSerializer(format) {
    switch (format) {
        case 'json':
            return new JsonTranslationSerializer();
        case 'xliff1':
        case 'xlf':
            return new Xliff1TranslationSerializer();
        case 'xliff2':
        case 'xlf2':
            return new Xliff2TranslationSerializer();
        case 'xmb':
            return new XmbTranslationSerializer();
        case 'xtb':
            return new XtbTranslationSerializer();
    }
}
/**
 * @param {?} format
 * @return {?}
 */
function getExtension(format) {
    switch (format) {
        case 'json':
        case 'xmb':
        case 'xtb':
            return format;
        default:
            return 'xlf';
    }
}
/**
 * The character used to mark the start and end of a "block" in a `$localize` tagged string.
 * A block can indicate metadata about the message or specify a name of a placeholder for a
 * substitution expressions.
 *
 * For example:
 *
 * ```ts
 * $localize`Hello, ${title}:title:!`;
 * $localize`:meaning|description\@\@id:source message text`;
 * ```
 * @type {?}
 */
const BLOCK_MARKER = ':';
/**
 * Find the end of a "marked block" indicated by the first non-escaped colon.
 *
 * @throws an error if the block is unterminated
 * @param {?} cooked The cooked string (where escaped chars have been processed)
 * @param {?} raw The raw string (where escape sequences are still in place)
 *
 * @return {?} the index of the end of block marker
 */
function findEndOfBlock(cooked, raw) {
    /************************************************************************************************
     * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.
     * (See that file for more explanation of why.)
     ************************************************************************************************/
    for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {
        if (raw[rawIndex] === '\\') {
            rawIndex++;
        }
        else if (cooked[cookedIndex] === BLOCK_MARKER) {
            return cookedIndex;
        }
    }
    throw new Error(`Unterminated $localize metadata block in "${raw}".`);
}
/**
 * Split a message part (`cooked` + `raw`) into an optional delimited "block" off the front and the
 * rest of the text of the message part.
 *
 * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the
 * start and end of the block.
 *
 * If the block is in the first message part then it will be metadata about the whole message:
 * meaning, description, id.  Otherwise it will be metadata about the immediately preceding
 * substitution: placeholder name.
 *
 * Since blocks are optional, it is possible that the content of a message block actually starts
 * with a block marker. In this case the marker must be escaped `\:`.
 *
 * @throws an error if the `block` is unterminated
 * @param {?} cooked The cooked version of the message part to parse.
 * @param {?} raw The raw version of the message part to parse.
 * @return {?} An object containing the `text` of the message part and the text of the `block`, if it
 * exists.
 */
function splitBlock(cooked, raw) {
    if (raw.charAt(0) !== BLOCK_MARKER) {
        return { text: cooked };
    }
    else {
        /** @type {?} */
        const endOfBlock = findEndOfBlock(cooked, raw);
        return {
            block: cooked.substring(1, endOfBlock),
            text: cooked.substring(endOfBlock + 1)
        };
    }
}
/**
 * @param {?} index
 * @return {?}
 */
function computePlaceholderName(index) {
    return index === 1 ? 'PH' : `PH_${index - 1}`;
}
/**
 * @param {?} id
 * @param {?} translation
 * @return {?}
 */
function translationToMessage(id, translation) {
    /** @type {?} */
    const messageParts = translation.messageParts;
    /** @type {?} */
    const legacyIds = [];
    /** @type {?} */
    const cleanedMessageParts = [messageParts[0]];
    /** @type {?} */
    const substitutions = {};
    /** @type {?} */
    const placeholderNames = [];
    /** @type {?} */
    let text = messageParts[0];
    for (let i = 1; i < messageParts.length; i++) {
        const { text: messagePart, block: placeholderName = translation.placeholderNames[i - 1] ||
            computePlaceholderName(i) } = splitBlock(messageParts[i], messageParts.raw[i]);
        text += `{$${placeholderName}}${messagePart}`;
        if (translation.placeholderNames.length) {
            substitutions[placeholderName] = translation.placeholderNames[i - 1];
        }
        placeholderNames.push(placeholderName);
        cleanedMessageParts.push(messagePart);
    }
    return {
        id,
        legacyIds,
        substitutions,
        text,
        meaning: translation.meaning || '',
        description: translation.description || '',
        messageParts: cleanedMessageParts,
        placeholderNames
    };
}
/**
 * @record
 */
function ParsedMessageLegacy() { }
if (false) {
    /**
     * The key used to look up the appropriate translation target.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageId;
    /**
     * Legacy message ids, if provided.
     *
     * In legacy message formats the message id can only be computed directly from the original
     * template source.
     *
     * Since this information is not available in `$localize` calls, the legacy message ids may be
     * attached by the compiler to the `$localize` metablock so it can be used if needed at the point
     * of translation if the translations are encoded using the legacy message id.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.legacyIds;
    /**
     * A mapping of placeholder names to substitution values.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.substitutions;
    /**
     * A human readable rendering of the message
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageString;
    /**
     * The meaning of the `message`, used to distinguish identical `messageString`s.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.meaning;
    /**
     * The description of the `message`, used to aid translation.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.description;
    /**
     * The static parts of the message.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.messageParts;
    /**
     * The names of the placeholders that will be replaced with substitutions.
     * @type {?}
     */
    ParsedMessageLegacy.prototype.placeholderNames;
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/source_file_utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Is the given `expression` an identifier with the correct name
 * @param {?} expression The expression to check.
 * @param {?} name
 * @return {?}
 */
function isNamedIdentifier(expression, name) {
    return expression.isIdentifier() && expression.node.name === name;
}
/**
 * Is the given `identifier` declared globally.
 * @param {?} identifier The identifier to check.
 * @return {?}
 */
function isGlobalIdentifier(identifier) {
    return (!identifier.scope || !identifier.scope.hasBinding(identifier.node.name));
}
/**
 * Build a translated expression to replace the call to `$localize`.
 * @param {?} messageParts The static parts of the message.
 * @param {?} substitutions The expressions to substitute into the message.
 * @return {?}
 */
function buildLocalizeReplacement(messageParts, substitutions) {
    /** @type {?} */
    let mappedString = stringLiteral(messageParts[0]);
    for (let i = 1; i < messageParts.length; i++) {
        mappedString = binaryExpression('+', mappedString, wrapInParensIfNecessary(substitutions[i - 1]));
        mappedString = binaryExpression('+', mappedString, stringLiteral(messageParts[i]));
    }
    return mappedString;
}
/**
 * Extract the message parts from the given `call` (to `$localize`).
 *
 * The message parts will either by the first argument to the `call` or it will be wrapped in call
 * to a helper function like `__makeTemplateObject`.
 *
 * @param {?} call The AST node of the call to process.
 * @return {?}
 */
function unwrapMessagePartsFromLocalizeCall(call) {
    /** @type {?} */
    let cooked = (/** @type {?} */ (call.get('arguments')[0]));
    if (cooked === undefined) {
        throw new BabelParseError(call.node, '`$localize` called without any arguments.');
    }
    if (!cooked.isExpression()) {
        throw new BabelParseError(cooked.node, 'Unexpected argument to `$localize` (expected an array).');
    }
    // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.
    /** @type {?} */
    let raw = cooked;
    // Check for cached call of the form `x || x = __makeTemplateObject(...)`
    if (cooked.isLogicalExpression() &&
        cooked.node.operator === '||' &&
        cooked.get('left').isIdentifier()) {
        /** @type {?} */
        const right = cooked.get('right');
        if (right.isAssignmentExpression()) {
            cooked = right.get('right');
            if (!cooked.isExpression()) {
                throw new BabelParseError(cooked.node, 'Unexpected "makeTemplateObject()" function (expected an expression).');
            }
        }
    }
    // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.
    if (cooked.isCallExpression()) {
        /** @type {?} */
        let cookedCall = cooked;
        if (cookedCall.get('arguments').length === 0) {
            // No arguments so perhaps it is a `__templateObject()` call.
            // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.
            cookedCall = unwrapLazyLoadHelperCall(cookedCall);
        }
        cooked = cookedCall.get('arguments')[0];
        if (!cooked.isExpression()) {
            throw new BabelParseError(cooked.node, 'Unexpected `cooked` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        /** @type {?} */
        const arg2 = cookedCall.get('arguments')[1];
        if (arg2 && !arg2.isExpression()) {
            throw new BabelParseError(arg2.node, 'Unexpected `raw` argument to the "makeTemplateObject()" function (expected an expression).');
        }
        // If there is no second argument then assume that raw and cooked are the same
        raw = arg2 !== undefined ? arg2 : cooked;
    }
    /** @type {?} */
    const cookedStrings = unwrapStringLiteralArray(cooked.node);
    /** @type {?} */
    const rawStrings = unwrapStringLiteralArray(raw.node);
    return ɵmakeTemplateObject(cookedStrings, rawStrings);
}
/**
 * @param {?} call
 * @return {?}
 */
function unwrapSubstitutionsFromLocalizeCall(call) {
    /** @type {?} */
    const expressions = call.arguments.splice(1);
    if (!isArrayOfExpressions(expressions)) {
        /** @type {?} */
        const badExpression = (/** @type {?} */ (expressions.find((/**
         * @param {?} expression
         * @return {?}
         */
        expression => !isExpression(expression)))));
        throw new BabelParseError(badExpression, 'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).');
    }
    return expressions;
}
/**
 * @param {?} elements
 * @return {?}
 */
function unwrapMessagePartsFromTemplateLiteral(elements) {
    /** @type {?} */
    const cooked = elements.map((/**
     * @param {?} q
     * @return {?}
     */
    q => {
        if (q.value.cooked === undefined) {
            throw new BabelParseError(q, `Unexpected undefined message part in "${elements.map((/**
             * @param {?} eq
             * @return {?}
             */
            eq => eq.value.cooked))}"`);
        }
        return q.value.cooked;
    }));
    /** @type {?} */
    const raw = elements.map((/**
     * @param {?} q
     * @return {?}
     */
    q => q.value.raw));
    return ɵmakeTemplateObject(cooked, raw);
}
/**
 * Wrap the given `expression` in parentheses if it is a binary expression.
 *
 * This ensures that this expression is evaluated correctly if it is embedded in another expression.
 *
 * @param {?} expression The expression to potentially wrap.
 * @return {?}
 */
function wrapInParensIfNecessary(expression) {
    if (isBinaryExpression(expression)) {
        return parenthesizedExpression(expression);
    }
    else {
        return expression;
    }
}
/**
 * Extract the string values from an `array` of string literals.
 * @param {?} array The array to unwrap.
 * @return {?}
 */
function unwrapStringLiteralArray(array) {
    if (!isStringLiteralArray(array)) {
        throw new BabelParseError(array, 'Unexpected messageParts for `$localize` (expected an array of strings).');
    }
    return array.elements.map((/**
     * @param {?} str
     * @return {?}
     */
    (str) => str.value));
}
/**
 * This expression is believed to be a call to a "lazy-load" template object helper function.
 * This is expected to be of the form:
 *
 * ```ts
 *  function _templateObject() {
 *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);
 *    return _templateObject = function() { return e }, e
 *  }
 * ```
 *
 * We unwrap this to return the call to `_taggedTemplateLiteral()`.
 *
 * @param {?} call the call expression to unwrap
 * @return {?} the  call expression
 */
function unwrapLazyLoadHelperCall(call) {
    /** @type {?} */
    const callee = (/** @type {?} */ (call.get('callee')));
    if (!callee.isIdentifier()) {
        throw new BabelParseError(callee.node, 'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).');
    }
    /** @type {?} */
    const lazyLoadBinding = call.scope.getBinding(callee.node.name);
    if (!lazyLoadBinding) {
        throw new BabelParseError(callee.node, 'Missing declaration for lazy-load helper function');
    }
    /** @type {?} */
    const lazyLoadFn = lazyLoadBinding.path;
    if (!lazyLoadFn.isFunctionDeclaration()) {
        throw new BabelParseError(((/** @type {?} */ (lazyLoadFn))).node, 'Unexpected expression (expected a function declaration');
    }
    /** @type {?} */
    const returnedNode = getReturnedExpression(lazyLoadFn);
    if (returnedNode.isCallExpression()) {
        return returnedNode;
    }
    if (returnedNode.isIdentifier()) {
        /** @type {?} */
        const identifierName = returnedNode.node.name;
        /** @type {?} */
        const declaration = returnedNode.scope.getBinding(identifierName);
        if (declaration === undefined) {
            throw new BabelParseError(returnedNode.node, 'Missing declaration for return value from helper.');
        }
        if (!declaration.path.isVariableDeclarator()) {
            throw new BabelParseError(((/** @type {?} */ (declaration))).path.node, 'Unexpected helper return value declaration (expected a variable declaration).');
        }
        /** @type {?} */
        const initializer = declaration.path.get('init');
        if (!initializer.isCallExpression()) {
            throw new BabelParseError(declaration.path.node, 'Unexpected return value from helper (expected a call expression).');
        }
        // Remove the lazy load helper if this is the only reference to it.
        if (lazyLoadBinding.references === 1) {
            lazyLoadFn.remove();
        }
        return initializer;
    }
    return call;
}
/**
 * @param {?} fn
 * @return {?}
 */
function getReturnedExpression(fn) {
    /** @type {?} */
    const bodyStatements = ((/** @type {?} */ (fn.get('body')))).get('body');
    for (const statement of bodyStatements) {
        if (statement.isReturnStatement()) {
            /** @type {?} */
            const argument = statement.get('argument');
            if (argument.isSequenceExpression()) {
                /** @type {?} */
                const expressions = argument.get('expressions');
                return Array.isArray(expressions)
                    ? expressions[expressions.length - 1]
                    : expressions;
            }
            else if (argument.isExpression()) {
                return argument;
            }
            else {
                throw new BabelParseError(statement.node, 'Invalid return argument in helper function (expected an expression).');
            }
        }
    }
    throw new BabelParseError(fn.node, 'Missing return statement in helper function.');
}
/**
 * Is the given `node` an array of literal strings?
 *
 * @param {?} node The node to test.
 * @return {?}
 */
function isStringLiteralArray(node) {
    return (isArrayExpression(node) &&
        node.elements.every((/**
         * @param {?} element
         * @return {?}
         */
        element => isStringLiteral(element))));
}
/**
 * Are all the given `nodes` expressions?
 * @param {?} nodes The nodes to test.
 * @return {?}
 */
function isArrayOfExpressions(nodes) {
    return nodes.every((/**
     * @param {?} element
     * @return {?}
     */
    element => isExpression(element)));
}
/**
 * Options that affect how the `makeEsXXXTranslatePlugin()` functions work.
 * @record
 */
function TranslatePluginOptions() { }
if (false) {
    /** @type {?|undefined} */
    TranslatePluginOptions.prototype.missingTranslation;
    /** @type {?|undefined} */
    TranslatePluginOptions.prototype.localizeName;
}
/**
 * Translate the text of the given message, using the given translations.
 *
 * Logs as warning if the translation is not available
 * @param {?} diagnostics
 * @param {?} translations
 * @param {?} messageParts
 * @param {?} substitutions
 * @param {?} missingTranslation
 * @return {?}
 */
function translate(diagnostics, translations, messageParts, substitutions, missingTranslation) {
    try {
        return ɵtranslate(translations, messageParts, substitutions);
    }
    catch (e) {
        if (ɵisMissingTranslationError(e)) {
            if (missingTranslation === 'error') {
                diagnostics.error(e.message);
            }
            else if (missingTranslation === 'warning') {
                diagnostics.warn(e.message);
            }
            // Return the parsed message because this will have the meta blocks stripped
            return [
                ɵmakeTemplateObject(e.parsedMessage.messageParts, e.parsedMessage.messageParts),
                substitutions
            ];
        }
        else {
            diagnostics.error(e.message);
            return [messageParts, substitutions];
        }
    }
}
class BabelParseError extends Error {
    /**
     * @param {?} node
     * @param {?} message
     */
    constructor(node, message) {
        super(message);
        this.node = node;
        this.type = 'BabelParseError';
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    BabelParseError.prototype.type;
    /** @type {?} */
    BabelParseError.prototype.node;
}
/**
 * @param {?} e
 * @return {?}
 */
function isBabelParseError(e) {
    return e.type === 'BabelParseError';
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/source_files/es2015_extract_plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} messages
 * @param {?} diagnostics
 * @param {?=} localizeName
 * @return {?}
 */
function makeEs2015ExtractPlugin(messages, diagnostics, localizeName = '$localize') {
    return {
        visitor: {
            /**
             * @param {?} path
             * @return {?}
             */
            TaggedTemplateExpression(path) {
                /** @type {?} */
                const tag = path.get('tag');
                if (isNamedIdentifier(tag, localizeName) && isGlobalIdentifier(tag)) {
                    /** @type {?} */
                    const messageParts = unwrapMessagePartsFromTemplateLiteral(path.node.quasi.quasis);
                    /** @type {?} */
                    const message = ɵparseMessage(messageParts, path.node.quasi.expressions);
                    if (!messages.find((/**
                     * @param {?} msg
                     * @return {?}
                     */
                    (msg) => message.id
                        ? msg.id === message.id
                        : msg.messageId ===
                            ((/** @type {?} */ (((/** @type {?} */ (message)))))).messageId))) {
                        messages.push(message);
                    }
                }
            }
        }
    };
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/source_files/es5_extract_plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} messages
 * @param {?} diagnostics
 * @param {?=} localizeName
 * @return {?}
 */
function makeEs5ExtractPlugin(messages, diagnostics, localizeName = '$localize') {
    return {
        visitor: {
            /**
             * @param {?} callPath
             * @return {?}
             */
            CallExpression(callPath) {
                /** @type {?} */
                const calleePath = callPath.get('callee');
                if (isNamedIdentifier(calleePath, localizeName) &&
                    isGlobalIdentifier(calleePath)) {
                    /** @type {?} */
                    const messageParts = unwrapMessagePartsFromLocalizeCall(callPath);
                    /** @type {?} */
                    const expressions = unwrapSubstitutionsFromLocalizeCall(callPath.node);
                    /** @type {?} */
                    const message = ɵparseMessage(messageParts, expressions);
                    if (!messages.find((/**
                     * @param {?} msg
                     * @return {?}
                     */
                    (msg) => message.id
                        ? msg.id === message.id
                        : msg.messageId ===
                            ((/** @type {?} */ (((/** @type {?} */ (message)))))).messageId))) {
                        messages.push(message);
                    }
                }
            }
        }
    };
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract/extractor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A class that extracts parsed messages from file contents, by parsing the contents as JavaScript
 * and looking for occurrences of `$localize` in the source code.
 */
class Extractor {
    /**
     * @param {?} diagnostics
     */
    constructor(diagnostics) {
        this.diagnostics = diagnostics;
        this.messages = [];
    }
    /**
     * @param {?} sourceCode
     * @return {?}
     */
    extractMessages(sourceCode) {
        if (sourceCode.includes('$localize')) {
            // Only bother to parse the file if it contains a reference to `$localize`.
            transformSync(sourceCode, {
                plugins: [
                    makeEs2015ExtractPlugin(this.messages, this.diagnostics),
                    makeEs5ExtractPlugin(this.messages, this.diagnostics)
                ],
                code: false,
                ast: false
            });
        }
    }
}
if (false) {
    /** @type {?} */
    Extractor.prototype.messages;
    /**
     * @type {?}
     * @private
     */
    Extractor.prototype.diagnostics;
}

/**
 * @fileoverview added by tsickle
 * Generated from: cmds/extract.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const command = 'extract';
/** @type {?} */
const describe = 'Extract translations from your ivy application';
/** @type {?} */
const builder = {
    s: {
        alias: 'source',
        required: true,
        describe: 'A glob pattern indicating what files to search for translations, e.g. `./dist/**/*.js`. This can be absolute or relative to the current working directory.'
    },
    f: {
        alias: 'format',
        required: true,
        describe: 'The format of the translation files to generate.',
        choices: ['json', 'xlf', 'xmb', 'xlf2'],
        default: 'json'
    },
    o: {
        alias: 'outputPath',
        required: true,
        describe: 'A path to where the translation file will be written. This can be absolute or relative to the current working directory.'
    },
    l: {
        alias: ['locale', 'locales'],
        required: false,
        type: 'array',
        describe: 'The locale for the extracted file, "en" by default. If you use multiple locales (e.g. "en fr es"), a new file will be generated for each locale'
    }
};
/** @type {?} */
const handler = (/**
 * @param {?} options
 * @return {?}
 */
function (options) {
    /** @type {?} */
    const diagnostics = new Diagnostics();
    extractTranslations({
        sourceGlob: (/** @type {?} */ (options['s'])),
        format: (/** @type {?} */ (options['f'])),
        outputPath: (/** @type {?} */ (options['o'])),
        locales: (/** @type {?} */ (options['l'])),
        diagnostics
    });
    diagnostics.logMessages();
    process.exit(diagnostics.hasErrors ? 1 : 0);
});
/**
 * @record
 */
function ExtractTranslationsOptions() { }
if (false) {
    /** @type {?} */
    ExtractTranslationsOptions.prototype.sourceGlob;
    /** @type {?} */
    ExtractTranslationsOptions.prototype.format;
    /** @type {?} */
    ExtractTranslationsOptions.prototype.outputPath;
    /** @type {?|undefined} */
    ExtractTranslationsOptions.prototype.locales;
    /** @type {?} */
    ExtractTranslationsOptions.prototype.diagnostics;
}
/**
 * @param {?} __0
 * @return {?}
 */
function extractTranslations({ sourceGlob: source, format, outputPath: output, locales = ['en'], diagnostics }) {
    console.log(`Extracting translations from "${source}"`);
    /** @type {?} */
    let filesToProcess = sync(resolve(source), {
        absolute: true,
        nodir: true
    });
    filesToProcess = FileUtils.dedup(filesToProcess, /\-es(5|2015)\./, '.');
    output = resolve(output);
    /** @type {?} */
    const generatedFiles = [];
    /** @type {?} */
    let isFile;
    try {
        /** @type {?} */
        const stat = statSync(output);
        isFile = stat.isFile();
    }
    catch (e) {
        isFile = !!extname(output);
    }
    if (isFile) {
        if (locales.length > 1) {
            diagnostics.error(`Multiple locales detected ("${locales.join(',')}") but output "${output}" is not a directory`);
            return;
        }
        /** @type {?} */
        const res = makeTranslationsFile(filesToProcess, posix.normalize(output), source, format, locales[0], diagnostics);
        if (res) {
            generatedFiles.push(res);
        }
    }
    else {
        filesToProcess.forEach((/**
         * @param {?} file
         * @return {?}
         */
        file => {
            locales.forEach((/**
             * @param {?} locale
             * @return {?}
             */
            locale => {
                /** @type {?} */
                const newFileName = posix.join(output, basename(file, '.js').replace(/-es(5|2015)/, '') +
                    '.' +
                    locale +
                    '.' +
                    getExtension(format));
                /** @type {?} */
                const res = makeTranslationsFile([file], newFileName, source, format, locale, diagnostics);
                if (res) {
                    generatedFiles.push(res);
                }
            }));
        }));
    }
    if (!generatedFiles.length) {
        diagnostics.error(`No messages found. You should build the angular app without a language target for this command to work.`);
        return;
    }
}
/**
 * @param {?} filesToProcess
 * @param {?} fileOutput
 * @param {?} source
 * @param {?} format
 * @param {?} locale
 * @param {?} diagnostics
 * @return {?}
 */
function makeTranslationsFile(filesToProcess, fileOutput, source, format, locale, diagnostics) {
    /** @type {?} */
    const extractor = new Extractor(diagnostics);
    filesToProcess.forEach((/**
     * @param {?} file
     * @return {?}
     */
    file => {
        /** @type {?} */
        const contents = readFileSync(file, 'utf8');
        extractor.extractMessages(contents);
    }));
    /** @type {?} */
    const serializer = getTranslationSerializer(format);
    if (extractor.messages.length > 0) {
        /** @type {?} */
        const translationFile = serializer.renderFile(extractor.messages, locale, false);
        FileUtils.writeFile(fileOutput, translationFile);
        console.log(`  Generated file "${fileOutput}"`);
        return fileOutput;
    }
    return null;
}

/**
 * @fileoverview added by tsickle
 * Generated from: main.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const configPath = sync$1(['.loclrc', '.locl.json']);
/** @type {?} */
const config = configPath
    ? JSON.parse(readFileSync(configPath, { encoding: 'utf8' }))
    : {};
/** @type {?} */
const args = process.argv.slice(2);
config$1(config)
    .commandDir('cmds')
    .demandCommand()
    .help()
    .version(false)
    .parse(args);

/**
 * @fileoverview added by tsickle
 * Generated from: index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: locl-cli.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CliModule, builder, command, describe, extractTranslations, handler };
//# sourceMappingURL=locl-cli.js.map
