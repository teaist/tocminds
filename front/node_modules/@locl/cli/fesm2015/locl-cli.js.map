{"version":3,"file":"locl-cli.js","sources":["ng://@locl/cli/lib/cli.module.ts","ng://@locl/cli/cmds/common/diagnostics.ts","ng://@locl/cli/cmds/common/file_utils.ts","ng://@locl/cli/cmds/extract/translation_files/json_translation_serializer.ts","ng://@locl/cli/cmds/extract/translation_files/xml_file.ts","ng://@locl/cli/cmds/extract/translation_files/xliff1_translation_serializer.ts","ng://@locl/cli/cmds/extract/translation_files/xliff2_translation_serializer.ts","ng://@locl/cli/cmds/extract/translation_files/xmb_translation_serializer.ts","ng://@locl/cli/cmds/extract/translation_files/xtb_translation_serializer.ts","ng://@locl/cli/cmds/common/util.ts","ng://@locl/cli/cmds/extract/source_file_utils.ts","ng://@locl/cli/cmds/extract/source_files/es2015_extract_plugin.ts","ng://@locl/cli/cmds/extract/source_files/es5_extract_plugin.ts","ng://@locl/cli/cmds/extract/extractor.ts","ng://@locl/cli/cmds/extract.ts","ng://@locl/cli/main.ts"],"sourcesContent":["import { NgModule } from '@angular/core';\n\n// not used, only there to make ng-packagr happy\n@NgModule({\n  imports: [],\n  declarations: [],\n  exports: []\n})\nexport class CliModule {}\n","import * as chalk from 'chalk';\n\n/**\n * This class is used to collect and then report warnings and errors that occur during the execution\n * of the tools.\n */\nexport class Diagnostics {\n  readonly messages = [];\n\n  get hasErrors() {\n    return this.messages.some(m => m.type === 'error');\n  }\n\n  log(message: string) {\n    this.messages.push({ type: '', message });\n  }\n\n  warn(message: string) {\n    this.messages.push({ type: 'warning', message });\n  }\n\n  error(message: string) {\n    this.messages.push({ type: 'error', message });\n  }\n\n  formatDiagnostics(message: string): string {\n    const errors = this.messages!.filter(d => d.type === 'error').map(\n      d => ' - ' + d.message\n    );\n    const warnings = this.messages!.filter(d => d.type === 'warning').map(\n      d => ' - ' + d.message\n    );\n    if (errors.length) {\n      message += '\\nERRORS:\\n' + errors.join('\\n');\n    }\n    if (warnings.length) {\n      message += '\\nWARNINGS:\\n' + warnings.join('\\n');\n    }\n    return message;\n  }\n\n  logMessages() {\n    while (this.messages.length) {\n      const m = this.messages.shift();\n      switch (m.type) {\n        case 'warning':\n          console.warn(chalk.yellow(`Warning: ${m.message}`));\n          break;\n        case 'error':\n          console.error(chalk.red(`Error: ${m.message}`));\n          break;\n        default:\n          console.log(chalk.blue(`${m.message}`));\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport class FileUtils {\n  static readFile(absolutePath: string): string {\n    return fs.readFileSync(absolutePath, 'utf8');\n  }\n\n  static readFileBuffer(absolutePath: string): Buffer {\n    return fs.readFileSync(absolutePath);\n  }\n\n  static writeFile(absolutePath: string, contents: string | Buffer) {\n    FileUtils.ensureDir(path.dirname(absolutePath));\n    fs.writeFileSync(absolutePath, contents);\n  }\n\n  static ensureDir(absolutePath: string): void {\n    const parents: string[] = [];\n    while (!FileUtils.isRoot(absolutePath) && !fs.existsSync(absolutePath)) {\n      parents.push(absolutePath);\n      absolutePath = path.dirname(absolutePath);\n    }\n    while (parents.length) {\n      fs.mkdirSync(parents.pop()!);\n    }\n  }\n\n  static remove(p: string): void {\n    const stat = fs.statSync(p);\n    if (stat.isFile()) {\n      fs.unlinkSync(p);\n    } else if (stat.isDirectory()) {\n      fs.readdirSync(p).forEach(child => {\n        const absChild = path.resolve(p, child);\n        FileUtils.remove(absChild);\n      });\n      fs.rmdirSync(p);\n    }\n  }\n\n  static isRoot(absolutePath: string): boolean {\n    return path.dirname(absolutePath) === absolutePath;\n  }\n\n  static dedup(files: string[], pattern: RegExp, replaceValue = ''): string[] {\n    const filesSet = files.map(file => file.replace(pattern, replaceValue));\n    const dedup = [];\n    const indexes = [];\n    filesSet.forEach((file: string, index: number) => {\n      if (dedup.indexOf(file) === -1) {\n        dedup.push(file);\n        indexes.push(index);\n      }\n    });\n    return indexes.map(index => files[index]);\n  }\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\nimport { TranslationSerializer } from './translation_serializer';\r\n\r\ninterface SimpleJsonTranslationFile {\r\n  locale: string;\r\n  translations: Record<string, string>;\r\n}\r\n\r\nexport class JsonTranslationSerializer implements TranslationSerializer {\r\n  renderFile(\r\n    messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n    locale: string\r\n  ): string {\r\n    const fileObj: SimpleJsonTranslationFile = {\r\n      locale,\r\n      translations: {}\r\n    };\r\n    messages.forEach(message => {\r\n      fileObj.translations[\r\n        (message as ɵParsedMessage).id ||\r\n          (message as ParsedMessageLegacy).messageId\r\n      ] =\r\n        (message as ɵParsedMessage).text ||\r\n        (message as ParsedMessageLegacy).messageString;\r\n    });\r\n    return JSON.stringify(fileObj, null, 2);\r\n  }\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ninterface Options {\n  selfClosing?: boolean;\n  preserveWhitespace?: boolean;\n}\n\nexport class XmlFile {\n  private output = '';\n  private indent = '';\n  private elements: string[] = [];\n  private preservingWhitespace = false;\n  toString() {\n    return this.output;\n  }\n\n  startTag(\n    name: string,\n    attributes: Record<string, string> = {},\n    { selfClosing = false, preserveWhitespace }: Options = {}\n  ): this {\n    if (!this.preservingWhitespace) {\n      this.output += this.indent;\n    }\n\n    this.output += `<${name}`;\n\n    Object.keys(attributes).forEach(attrName => {\n      if (attributes[attrName]) {\n        this.output += ` ${attrName}=\"${escapeXml(attributes[attrName])}\"`;\n      }\n    });\n\n    if (selfClosing) {\n      this.output += '/>';\n    } else {\n      this.output += '>';\n      this.elements.push(name);\n      this.incIndent();\n    }\n\n    if (preserveWhitespace !== undefined) {\n      this.preservingWhitespace = preserveWhitespace;\n    }\n    if (!this.preservingWhitespace) {\n      this.output += `\\n`;\n    }\n    return this;\n  }\n\n  endTag(name: string, { preserveWhitespace }: Options = {}): this {\n    const expectedTag = this.elements.pop();\n    if (expectedTag !== name) {\n      throw new Error(\n        `Unexpected closing tag: \"${name}\", expected: \"${expectedTag}\"`\n      );\n    }\n\n    this.decIndent();\n\n    if (!this.preservingWhitespace) {\n      this.output += this.indent;\n    }\n    this.output += `</${name}>`;\n\n    if (preserveWhitespace !== undefined) {\n      this.preservingWhitespace = preserveWhitespace;\n    }\n    if (!this.preservingWhitespace) {\n      this.output += `\\n`;\n    }\n    return this;\n  }\n\n  text(str: string): this {\n    this.output += escapeXml(str);\n    return this;\n  }\n\n  startPreserveWhitespace() {\n    this.preservingWhitespace = true;\n  }\n  stopPreserveWhitespace() {\n    this.preservingWhitespace = false;\n  }\n\n  private incIndent() {\n    this.indent = this.indent + '  ';\n  }\n  private decIndent() {\n    this.indent = this.indent.slice(0, -2);\n  }\n}\n\nconst _ESCAPED_CHARS: [RegExp, string][] = [\n  [/&/g, '&amp;'],\n  [/\"/g, '&quot;'],\n  [/'/g, '&apos;'],\n  [/</g, '&lt;'],\n  [/>/g, '&gt;']\n];\n\nfunction escapeXml(text: string): string {\n  return _ESCAPED_CHARS.reduce(\n    (t: string, entry: [RegExp, string]) => t.replace(entry[0], entry[1]),\n    text\n  );\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\nimport { TranslationSerializer } from './translation_serializer';\r\nimport { XmlFile } from './xml_file';\r\n\r\nexport class Xliff1TranslationSerializer implements TranslationSerializer {\r\n  renderFile(\r\n    messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n    locale: string,\r\n    isTarget = false\r\n  ): string {\r\n    const xml = new XmlFile();\r\n    xml.startTag('xliff', {\r\n      version: '1.2',\r\n      xmlns: 'urn:oasis:names:tc:xliff:document:1.2'\r\n    });\r\n    const fileAttrs = {\r\n      ['source-language']: isTarget ? undefined : locale,\r\n      ['target-language']: locale,\r\n      datatype: 'plaintext'\r\n    };\r\n    xml.startTag('file', fileAttrs);\r\n    xml.startTag('body');\r\n    messages.forEach(message => {\r\n      xml.startTag('trans-unit', {\r\n        id:\r\n          (message as ɵParsedMessage).id ||\r\n          (message as ParsedMessageLegacy).messageId,\r\n        datatype: 'html'\r\n      });\r\n      if (!isTarget) {\r\n        this.generateMessageTag(xml, 'source', message);\r\n      }\r\n      this.generateMessageTag(xml, 'target', message);\r\n      if (message.description) {\r\n        this.renderNote(xml, 'description', message.description);\r\n      }\r\n      if (message.meaning) {\r\n        this.renderNote(xml, 'meaning', message.meaning);\r\n      }\r\n      xml.endTag('trans-unit');\r\n    });\r\n    xml.endTag('body');\r\n    xml.endTag('file');\r\n    xml.endTag('xliff');\r\n    return xml.toString();\r\n  }\r\n\r\n  private generateMessageTag(\r\n    xml: XmlFile,\r\n    tagName: string,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ) {\r\n    xml.startTag(tagName, {}, { preserveWhitespace: true });\r\n    this.renderMessage(xml, message);\r\n    xml.endTag(tagName, { preserveWhitespace: false });\r\n  }\r\n\r\n  private renderMessage(\r\n    xml: XmlFile,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ): void {\r\n    xml.text(message.messageParts[0]);\r\n    for (let i = 1; i < message.messageParts.length; i++) {\r\n      xml.startTag(\r\n        'x',\r\n        { id: message.placeholderNames[i - 1] },\r\n        { selfClosing: true }\r\n      );\r\n      xml.text(message.messageParts[i]);\r\n    }\r\n  }\r\n\r\n  private renderNote(xml: XmlFile, name: string, value: string) {\r\n    xml.startTag(\r\n      'note',\r\n      { priority: '1', from: name },\r\n      { preserveWhitespace: true }\r\n    );\r\n    xml.text(value);\r\n    xml.endTag('note', { preserveWhitespace: false });\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\nimport { TranslationSerializer } from './translation_serializer';\r\nimport { XmlFile } from './xml_file';\r\n\r\nexport class Xliff2TranslationSerializer implements TranslationSerializer {\r\n  renderFile(\r\n    messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n    locale: string,\r\n    isTarget = false\r\n  ): string {\r\n    const xml = new XmlFile();\r\n    xml.startTag('xliff', {\r\n      version: '2.0',\r\n      xmlns: 'urn:oasis:names:tc:xliff:document:2.0',\r\n      srcLang: locale,\r\n      trgLang: locale\r\n    });\r\n    xml.startTag('file');\r\n    messages.forEach(message => {\r\n      xml.startTag('unit', {\r\n        id:\r\n          (message as ɵParsedMessage).id ||\r\n          (message as ParsedMessageLegacy).messageId\r\n      });\r\n      if (message.meaning || message.description) {\r\n        xml.startTag('notes');\r\n        if (message.description) {\r\n          this.renderNote(xml, 'description', message.description);\r\n        }\r\n        if (message.meaning) {\r\n          this.renderNote(xml, 'meaning', message.meaning);\r\n        }\r\n        xml.endTag('notes');\r\n      }\r\n      xml.startTag('segment');\r\n      if (!isTarget) {\r\n        this.generateMessageTag(xml, 'source', message);\r\n      }\r\n      this.generateMessageTag(xml, 'target', message);\r\n      xml.endTag('segment');\r\n      xml.endTag('unit');\r\n    });\r\n    xml.endTag('file');\r\n    xml.endTag('xliff');\r\n    return xml.toString();\r\n  }\r\n\r\n  private generateMessageTag(\r\n    xml: XmlFile,\r\n    tagName: string,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ) {\r\n    xml.startTag(tagName, {}, { preserveWhitespace: true });\r\n    this.renderMessage(xml, message);\r\n    xml.endTag(tagName, { preserveWhitespace: false });\r\n  }\r\n\r\n  private renderMessage(\r\n    xml: XmlFile,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ): void {\r\n    xml.text(message.messageParts[0]);\r\n    for (let i = 1; i < message.messageParts.length; i++) {\r\n      const placeholderName = message.placeholderNames[i - 1];\r\n      if (placeholderName.startsWith('START_')) {\r\n        xml.startTag('pc', {\r\n          id: `${i}`,\r\n          equivStart: placeholderName,\r\n          equivEnd: placeholderName.replace(/^START/, 'CLOSE')\r\n        });\r\n      } else if (placeholderName.startsWith('CLOSE_')) {\r\n        xml.endTag('pc');\r\n      } else {\r\n        xml.startTag(\r\n          'ph',\r\n          { id: `${i}`, equiv: placeholderName },\r\n          { selfClosing: true }\r\n        );\r\n      }\r\n      xml.text(message.messageParts[i]);\r\n    }\r\n  }\r\n\r\n  private renderNote(xml: XmlFile, name: string, value: string) {\r\n    xml.startTag('note', { category: name }, { preserveWhitespace: true });\r\n    xml.text(value);\r\n    xml.endTag('note', { preserveWhitespace: false });\r\n  }\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ɵParsedMessage } from '@angular/localize';\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\nimport { TranslationSerializer } from './translation_serializer';\nimport { XmlFile } from './xml_file';\n\nconst DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\nexport class XmbTranslationSerializer implements TranslationSerializer {\n  renderFile(messages: (ɵParsedMessage | ParsedMessageLegacy)[]): string {\n    const xml = new XmlFile();\n    xml.startTag('messagebundle');\n    messages.forEach(message => {\n      xml.startTag(\n        'msg',\n        {\n          id:\n            (message as ɵParsedMessage).id ||\n            (message as ParsedMessageLegacy).messageId,\n          desc: message.description,\n          meaning: message.meaning\n        },\n        { preserveWhitespace: true }\n      );\n      this.renderMessage(xml, message);\n      xml.endTag('msg', { preserveWhitespace: false });\n    });\n    xml.endTag('messagebundle');\n    return xml.toString();\n  }\n\n  private renderMessage(\n    xml: XmlFile,\n    message: ɵParsedMessage | ParsedMessageLegacy\n  ): void {\n    xml.text(message.messageParts[0]);\n    for (let i = 1; i < message.messageParts.length; i++) {\n      xml.startTag(\n        'ph',\n        { name: message.placeholderNames[i - 1] },\n        { selfClosing: true }\n      );\n      xml.text(message.messageParts[i]);\n    }\n  }\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\nimport { TranslationSerializer } from './translation_serializer';\r\nimport { XmlFile } from './xml_file';\r\n\r\nconst DOCTYPE = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE translationbundle [\r\n<!ELEMENT translationbundle (translation)*>\r\n<!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n\r\n<!ELEMENT translation (#PCDATA|ph)*>\r\n<!ATTLIST translation id CDATA #REQUIRED>\r\n<!ATTLIST translation desc CDATA #IMPLIED>\r\n<!ATTLIST translation meaning CDATA #IMPLIED>\r\n<!ATTLIST translation xml:space (default|preserve) \"default\">\r\n\r\n<!ELEMENT ph (#PCDATA|ex)*>\r\n<!ATTLIST ph name CDATA #REQUIRED>\r\n\r\n<!ELEMENT ex (#PCDATA)>\r\n]>\r\n`;\r\n\r\nexport class XtbTranslationSerializer implements TranslationSerializer {\r\n  renderFile(\r\n    messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n    locale: string\r\n  ): string {\r\n    const xml = new XmlFile();\r\n    xml.startTag('translationbundle', { lang: locale });\r\n    messages.forEach(message => {\r\n      xml.startTag(\r\n        'translation',\r\n        {\r\n          id:\r\n            (message as ɵParsedMessage).id ||\r\n            (message as ParsedMessageLegacy).messageId,\r\n          desc: message.description,\r\n          meaning: message.meaning\r\n        },\r\n        { preserveWhitespace: true }\r\n      );\r\n      this.renderMessage(xml, message);\r\n      xml.endTag('translation', { preserveWhitespace: false });\r\n    });\r\n    xml.endTag('translationbundle');\r\n    return DOCTYPE + xml.toString();\r\n  }\r\n\r\n  private renderMessage(\r\n    xml: XmlFile,\r\n    message: ɵParsedMessage | ParsedMessageLegacy\r\n  ): void {\r\n    xml.text(message.messageParts[0]);\r\n    for (let i = 1; i < message.messageParts.length; i++) {\r\n      xml.startTag(\r\n        'ph',\r\n        { name: message.placeholderNames[i - 1] },\r\n        { selfClosing: true }\r\n      );\r\n      xml.text(message.messageParts[i]);\r\n    }\r\n  }\r\n}\r\n","import { JsonTranslationSerializer } from '../extract/translation_files/json_translation_serializer';\r\nimport { TranslationSerializer } from '../extract/translation_files/translation_serializer';\r\nimport { Xliff1TranslationSerializer } from '../extract/translation_files/xliff1_translation_serializer';\r\nimport { Xliff2TranslationSerializer } from '../extract/translation_files/xliff2_translation_serializer';\r\nimport { XmbTranslationSerializer } from '../extract/translation_files/xmb_translation_serializer';\r\nimport { ɵMessageId, ɵParsedMessage } from '@angular/localize';\r\nimport { ParsedTranslation } from '../convert/translations';\r\nimport { XtbTranslationSerializer } from '../extract/translation_files/xtb_translation_serializer';\r\n\r\nexport type TranslationFormat =\r\n  | 'json'\r\n  | 'xmb'\r\n  | 'xliff1'\r\n  | 'xliff2'\r\n  | 'xlf'\r\n  | 'xlf2'\r\n  | 'xtb';\r\n\r\nexport function getTranslationSerializer(\r\n  format: TranslationFormat\r\n): TranslationSerializer {\r\n  switch (format) {\r\n    case 'json':\r\n      return new JsonTranslationSerializer();\r\n    case 'xliff1':\r\n    case 'xlf':\r\n      return new Xliff1TranslationSerializer();\r\n    case 'xliff2':\r\n    case 'xlf2':\r\n      return new Xliff2TranslationSerializer();\r\n    case 'xmb':\r\n      return new XmbTranslationSerializer();\r\n    case 'xtb':\r\n      return new XtbTranslationSerializer();\r\n  }\r\n}\r\n\r\nexport function getExtension(format: TranslationFormat): string {\r\n  switch (format) {\r\n    case 'json':\r\n    case 'xmb':\r\n    case 'xtb':\r\n      return format;\r\n    default:\r\n      return 'xlf';\r\n  }\r\n}\r\n\r\n/**\r\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\r\n * A block can indicate metadata about the message or specify a name of a placeholder for a\r\n * substitution expressions.\r\n *\r\n * For example:\r\n *\r\n * ```ts\r\n * $localize`Hello, ${title}:title:!`;\r\n * $localize`:meaning|description@@id:source message text`;\r\n * ```\r\n */\r\nexport const BLOCK_MARKER = ':';\r\n\r\n/**\r\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\r\n *\r\n * @param cooked The cooked string (where escaped chars have been processed)\r\n * @param raw The raw string (where escape sequences are still in place)\r\n *\r\n * @returns the index of the end of block marker\r\n * @throws an error if the block is unterminated\r\n */\r\nexport function findEndOfBlock(cooked: string, raw: string): number {\r\n  /************************************************************************************************\r\n   * This function is repeated in `src/localize/src/localize.ts` and the two should be kept in sync.\r\n   * (See that file for more explanation of why.)\r\n   ************************************************************************************************/\r\n  for (\r\n    let cookedIndex = 1, rawIndex = 1;\r\n    cookedIndex < cooked.length;\r\n    cookedIndex++, rawIndex++\r\n  ) {\r\n    if (raw[rawIndex] === '\\\\') {\r\n      rawIndex++;\r\n    } else if (cooked[cookedIndex] === BLOCK_MARKER) {\r\n      return cookedIndex;\r\n    }\r\n  }\r\n  throw new Error(`Unterminated $localize metadata block in \"${raw}\".`);\r\n}\r\n\r\n/**\r\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\r\n * rest of the text of the message part.\r\n *\r\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\r\n * start and end of the block.\r\n *\r\n * If the block is in the first message part then it will be metadata about the whole message:\r\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\r\n * substitution: placeholder name.\r\n *\r\n * Since blocks are optional, it is possible that the content of a message block actually starts\r\n * with a block marker. In this case the marker must be escaped `\\:`.\r\n *\r\n * @param cooked The cooked version of the message part to parse.\r\n * @param raw The raw version of the message part to parse.\r\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\r\n * exists.\r\n * @throws an error if the `block` is unterminated\r\n */\r\nexport function splitBlock(\r\n  cooked: string,\r\n  raw: string\r\n): { text: string; block?: string } {\r\n  if (raw.charAt(0) !== BLOCK_MARKER) {\r\n    return { text: cooked };\r\n  } else {\r\n    const endOfBlock = findEndOfBlock(cooked, raw);\r\n    return {\r\n      block: cooked.substring(1, endOfBlock),\r\n      text: cooked.substring(endOfBlock + 1)\r\n    };\r\n  }\r\n}\r\n\r\nfunction computePlaceholderName(index: number) {\r\n  return index === 1 ? 'PH' : `PH_${index - 1}`;\r\n}\r\n\r\nexport function translationToMessage(\r\n  id: string,\r\n  translation: ParsedTranslation\r\n): ɵParsedMessage {\r\n  const messageParts = translation.messageParts;\r\n  const legacyIds = [];\r\n  const cleanedMessageParts: string[] = [messageParts[0]];\r\n  const substitutions: { [placeholderName: string]: any } = {};\r\n  const placeholderNames: string[] = [];\r\n  let text = messageParts[0];\r\n\r\n  for (let i = 1; i < messageParts.length; i++) {\r\n    const {\r\n      text: messagePart,\r\n      block: placeholderName = translation.placeholderNames[i - 1] ||\r\n        computePlaceholderName(i)\r\n    } = splitBlock(messageParts[i], messageParts.raw[i]);\r\n    text += `{$${placeholderName}}${messagePart}`;\r\n    if (translation.placeholderNames.length) {\r\n      substitutions[placeholderName] = translation.placeholderNames[i - 1];\r\n    }\r\n    placeholderNames.push(placeholderName);\r\n    cleanedMessageParts.push(messagePart);\r\n  }\r\n\r\n  return {\r\n    id,\r\n    legacyIds,\r\n    substitutions,\r\n    text,\r\n    meaning: translation.meaning || '',\r\n    description: translation.description || '',\r\n    messageParts: cleanedMessageParts,\r\n    placeholderNames\r\n  };\r\n}\r\n\r\nexport interface ParsedMessageLegacy {\r\n  /**\r\n   * The key used to look up the appropriate translation target.\r\n   */\r\n  messageId: ɵMessageId;\r\n  /**\r\n   * Legacy message ids, if provided.\r\n   *\r\n   * In legacy message formats the message id can only be computed directly from the original\r\n   * template source.\r\n   *\r\n   * Since this information is not available in `$localize` calls, the legacy message ids may be\r\n   * attached by the compiler to the `$localize` metablock so it can be used if needed at the point\r\n   * of translation if the translations are encoded using the legacy message id.\r\n   */\r\n  legacyIds: ɵMessageId[];\r\n  /**\r\n   * A mapping of placeholder names to substitution values.\r\n   */\r\n  substitutions: Record<string, any>;\r\n  /**\r\n   * A human readable rendering of the message\r\n   */\r\n  messageString: string;\r\n  /**\r\n   * The meaning of the `message`, used to distinguish identical `messageString`s.\r\n   */\r\n  meaning: string;\r\n  /**\r\n   * The description of the `message`, used to aid translation.\r\n   */\r\n  description: string;\r\n  /**\r\n   * The static parts of the message.\r\n   */\r\n  messageParts: string[];\r\n  /**\r\n   * The names of the placeholders that will be replaced with substitutions.\r\n   */\r\n  placeholderNames: string[];\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  ɵParsedTranslation,\n  ɵisMissingTranslationError,\n  ɵmakeTemplateObject,\n  ɵtranslate\n} from '@angular/localize';\nimport { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { ParsedTranslation } from '@angular/localize/src/utils';\nimport { Diagnostics } from '../common/diagnostics';\n\n/**\n * Is the given `expression` an identifier with the correct name\n * @param expression The expression to check.\n */\nexport function isNamedIdentifier(\n  expression: NodePath,\n  name: string\n): expression is NodePath {\n  return expression.isIdentifier() && expression.node.name === name;\n}\n\n/**\n * Is the given `identifier` declared globally.\n * @param identifier The identifier to check.\n */\nexport function isGlobalIdentifier(identifier: NodePath<t.Identifier>) {\n  return (\n    !identifier.scope || !identifier.scope.hasBinding(identifier.node.name)\n  );\n}\n\n/**\n * Build a translated expression to replace the call to `$localize`.\n * @param messageParts The static parts of the message.\n * @param substitutions The expressions to substitute into the message.\n */\nexport function buildLocalizeReplacement(\n  messageParts: TemplateStringsArray,\n  substitutions: readonly t.Expression[]\n): t.Expression {\n  let mappedString: t.Expression = t.stringLiteral(messageParts[0]);\n  for (let i = 1; i < messageParts.length; i++) {\n    mappedString = t.binaryExpression(\n      '+',\n      mappedString,\n      wrapInParensIfNecessary(substitutions[i - 1])\n    );\n    mappedString = t.binaryExpression(\n      '+',\n      mappedString,\n      t.stringLiteral(messageParts[i])\n    );\n  }\n  return mappedString;\n}\n\n/**\n * Extract the message parts from the given `call` (to `$localize`).\n *\n * The message parts will either by the first argument to the `call` or it will be wrapped in call\n * to a helper function like `__makeTemplateObject`.\n *\n * @param call The AST node of the call to process.\n */\nexport function unwrapMessagePartsFromLocalizeCall(\n  call: NodePath<t.CallExpression>\n): TemplateStringsArray {\n  let cooked = call.get('arguments')[0] as any;\n\n  if (cooked === undefined) {\n    throw new BabelParseError(\n      call.node,\n      '`$localize` called without any arguments.'\n    );\n  }\n  if (!cooked.isExpression()) {\n    throw new BabelParseError(\n      cooked.node,\n      'Unexpected argument to `$localize` (expected an array).'\n    );\n  }\n\n  // If there is no call to `__makeTemplateObject(...)`, then `raw` must be the same as `cooked`.\n  let raw = cooked;\n\n  // Check for cached call of the form `x || x = __makeTemplateObject(...)`\n  if (\n    cooked.isLogicalExpression() &&\n    cooked.node.operator === '||' &&\n    cooked.get('left').isIdentifier()\n  ) {\n    const right = cooked.get('right');\n    if (right.isAssignmentExpression()) {\n      cooked = right.get('right');\n      if (!cooked.isExpression()) {\n        throw new BabelParseError(\n          cooked.node,\n          'Unexpected \"makeTemplateObject()\" function (expected an expression).'\n        );\n      }\n    }\n  }\n\n  // Check for `__makeTemplateObject(cooked, raw)` or `__templateObject()` calls.\n  if (cooked.isCallExpression()) {\n    let cookedCall = cooked;\n    if (cookedCall.get('arguments').length === 0) {\n      // No arguments so perhaps it is a `__templateObject()` call.\n      // Unwrap this to get the `_taggedTemplateLiteral(cooked, raw)` call.\n      cookedCall = unwrapLazyLoadHelperCall(cookedCall);\n    }\n\n    cooked = cookedCall.get('arguments')[0];\n    if (!cooked.isExpression()) {\n      throw new BabelParseError(\n        cooked.node,\n        'Unexpected `cooked` argument to the \"makeTemplateObject()\" function (expected an expression).'\n      );\n    }\n    const arg2 = cookedCall.get('arguments')[1];\n    if (arg2 && !arg2.isExpression()) {\n      throw new BabelParseError(\n        arg2.node,\n        'Unexpected `raw` argument to the \"makeTemplateObject()\" function (expected an expression).'\n      );\n    }\n    // If there is no second argument then assume that raw and cooked are the same\n    raw = arg2 !== undefined ? arg2 : cooked;\n  }\n\n  const cookedStrings = unwrapStringLiteralArray(cooked.node);\n  const rawStrings = unwrapStringLiteralArray(raw.node);\n  return ɵmakeTemplateObject(cookedStrings, rawStrings);\n}\n\nexport function unwrapSubstitutionsFromLocalizeCall(\n  call: t.CallExpression\n): t.Expression[] {\n  const expressions = call.arguments.splice(1);\n  if (!isArrayOfExpressions(expressions)) {\n    const badExpression = expressions.find(\n      expression => !t.isExpression(expression)\n    )!;\n    throw new BabelParseError(\n      badExpression,\n      'Invalid substitutions for `$localize` (expected all substitution arguments to be expressions).'\n    );\n  }\n  return expressions;\n}\n\nexport function unwrapMessagePartsFromTemplateLiteral(\n  elements: t.TemplateElement[]\n): TemplateStringsArray {\n  const cooked = elements.map(q => {\n    if (q.value.cooked === undefined) {\n      throw new BabelParseError(\n        q,\n        `Unexpected undefined message part in \"${elements.map(\n          eq => eq.value.cooked\n        )}\"`\n      );\n    }\n    return q.value.cooked;\n  });\n  const raw = elements.map(q => q.value.raw);\n  return ɵmakeTemplateObject(cooked, raw);\n}\n\n/**\n * Wrap the given `expression` in parentheses if it is a binary expression.\n *\n * This ensures that this expression is evaluated correctly if it is embedded in another expression.\n *\n * @param expression The expression to potentially wrap.\n */\nexport function wrapInParensIfNecessary(\n  expression: t.Expression\n): t.Expression {\n  if (t.isBinaryExpression(expression)) {\n    return t.parenthesizedExpression(expression);\n  } else {\n    return expression;\n  }\n}\n\n/**\n * Extract the string values from an `array` of string literals.\n * @param array The array to unwrap.\n */\nexport function unwrapStringLiteralArray(array: t.Expression): string[] {\n  if (!isStringLiteralArray(array)) {\n    throw new BabelParseError(\n      array,\n      'Unexpected messageParts for `$localize` (expected an array of strings).'\n    );\n  }\n  return array.elements.map((str: t.StringLiteral) => str.value);\n}\n\n/**\n * This expression is believed to be a call to a \"lazy-load\" template object helper function.\n * This is expected to be of the form:\n *\n * ```ts\n *  function _templateObject() {\n *    var e = _taggedTemplateLiteral(['cooked string', 'raw string']);\n *    return _templateObject = function() { return e }, e\n *  }\n * ```\n *\n * We unwrap this to return the call to `_taggedTemplateLiteral()`.\n *\n * @param call the call expression to unwrap\n * @returns the  call expression\n */\nexport function unwrapLazyLoadHelperCall(\n  call: NodePath<t.CallExpression>\n): NodePath<t.CallExpression> {\n  const callee = call.get('callee') as any;\n  if (!callee.isIdentifier()) {\n    throw new BabelParseError(\n      callee.node,\n      'Unexpected lazy-load helper call (expected a call of the form `_templateObject()`).'\n    );\n  }\n  const lazyLoadBinding = call.scope.getBinding(callee.node.name);\n  if (!lazyLoadBinding) {\n    throw new BabelParseError(\n      callee.node,\n      'Missing declaration for lazy-load helper function'\n    );\n  }\n  const lazyLoadFn = lazyLoadBinding.path;\n  if (!lazyLoadFn.isFunctionDeclaration()) {\n    throw new BabelParseError(\n      (lazyLoadFn as any).node,\n      'Unexpected expression (expected a function declaration'\n    );\n  }\n  const returnedNode = getReturnedExpression(lazyLoadFn);\n\n  if (returnedNode.isCallExpression()) {\n    return returnedNode;\n  }\n\n  if (returnedNode.isIdentifier()) {\n    const identifierName = returnedNode.node.name;\n    const declaration = returnedNode.scope.getBinding(identifierName);\n    if (declaration === undefined) {\n      throw new BabelParseError(\n        returnedNode.node,\n        'Missing declaration for return value from helper.'\n      );\n    }\n    if (!declaration.path.isVariableDeclarator()) {\n      throw new BabelParseError(\n        (declaration as any).path.node,\n        'Unexpected helper return value declaration (expected a variable declaration).'\n      );\n    }\n    const initializer = declaration.path.get('init');\n    if (!initializer.isCallExpression()) {\n      throw new BabelParseError(\n        declaration.path.node,\n        'Unexpected return value from helper (expected a call expression).'\n      );\n    }\n\n    // Remove the lazy load helper if this is the only reference to it.\n    if (lazyLoadBinding.references === 1) {\n      lazyLoadFn.remove();\n    }\n\n    return initializer;\n  }\n  return call;\n}\n\nfunction getReturnedExpression(\n  fn: NodePath<t.FunctionDeclaration>\n): NodePath<t.Expression> {\n  const bodyStatements = (fn.get('body') as any).get('body');\n  for (const statement of bodyStatements) {\n    if (statement.isReturnStatement()) {\n      const argument = statement.get('argument');\n      if (argument.isSequenceExpression()) {\n        const expressions = argument.get('expressions');\n        return Array.isArray(expressions)\n          ? expressions[expressions.length - 1]\n          : expressions;\n      } else if (argument.isExpression()) {\n        return argument;\n      } else {\n        throw new BabelParseError(\n          statement.node,\n          'Invalid return argument in helper function (expected an expression).'\n        );\n      }\n    }\n  }\n  throw new BabelParseError(\n    fn.node,\n    'Missing return statement in helper function.'\n  );\n}\n\n/**\n * Is the given `node` an array of literal strings?\n *\n * @param node The node to test.\n */\nexport function isStringLiteralArray(\n  node: t.Node\n): node is t.Expression & { elements: t.StringLiteral[] } {\n  return (\n    t.isArrayExpression(node) &&\n    node.elements.every(element => t.isStringLiteral(element))\n  );\n}\n\n/**\n * Are all the given `nodes` expressions?\n * @param nodes The nodes to test.\n */\nexport function isArrayOfExpressions(nodes: t.Node[]): nodes is t.Expression[] {\n  return nodes.every(element => t.isExpression(element));\n}\n\n/** Options that affect how the `makeEsXXXTranslatePlugin()` functions work. */\nexport interface TranslatePluginOptions {\n  missingTranslation?: MissingTranslationStrategy;\n  localizeName?: string;\n}\n\n/**\n * How to handle missing translations.\n */\nexport type MissingTranslationStrategy = 'error' | 'warning' | 'ignore';\n\n/**\n * Translate the text of the given message, using the given translations.\n *\n * Logs as warning if the translation is not available\n */\nexport function translate(\n  diagnostics: Diagnostics,\n  translations: Record<string, ɵParsedTranslation>,\n  messageParts: TemplateStringsArray,\n  substitutions: readonly any[],\n  missingTranslation: MissingTranslationStrategy\n): [TemplateStringsArray, readonly any[]] {\n  try {\n    return ɵtranslate(translations, messageParts, substitutions);\n  } catch (e) {\n    if (ɵisMissingTranslationError(e)) {\n      if (missingTranslation === 'error') {\n        diagnostics.error(e.message);\n      } else if (missingTranslation === 'warning') {\n        diagnostics.warn(e.message);\n      }\n      // Return the parsed message because this will have the meta blocks stripped\n      return [\n        ɵmakeTemplateObject(\n          e.parsedMessage.messageParts,\n          e.parsedMessage.messageParts\n        ),\n        substitutions\n      ];\n    } else {\n      diagnostics.error(e.message);\n      return [messageParts, substitutions];\n    }\n  }\n}\n\nexport class BabelParseError extends Error {\n  private readonly type = 'BabelParseError';\n  constructor(public node: t.Node, message: string) {\n    super(message);\n  }\n}\n\nexport function isBabelParseError(e: any): e is BabelParseError {\n  return e.type === 'BabelParseError';\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage, ɵparseMessage } from '@angular/localize';\r\nimport { NodePath, PluginObj } from '@babel/core';\r\nimport { TaggedTemplateExpression } from '@babel/types';\r\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\r\n\r\nimport {\r\n  isGlobalIdentifier,\r\n  isNamedIdentifier,\r\n  unwrapMessagePartsFromTemplateLiteral\r\n} from '../source_file_utils';\r\nimport { Diagnostics } from '../../common/diagnostics';\r\n\r\nexport function makeEs2015ExtractPlugin(\r\n  messages: (ɵParsedMessage | ParsedMessageLegacy)[],\r\n  diagnostics: Diagnostics,\r\n  localizeName = '$localize'\r\n): PluginObj {\r\n  return {\r\n    visitor: {\r\n      TaggedTemplateExpression(path: NodePath<TaggedTemplateExpression>) {\r\n        const tag = path.get('tag');\r\n        if (isNamedIdentifier(tag, localizeName) && isGlobalIdentifier(tag)) {\r\n          const messageParts = unwrapMessagePartsFromTemplateLiteral(\r\n            path.node.quasi.quasis\r\n          );\r\n          const message: ɵParsedMessage | ParsedMessageLegacy = ɵparseMessage(\r\n            messageParts,\r\n            path.node.quasi.expressions\r\n          );\r\n          if (\r\n            !messages.find((msg: any) =>\r\n              message.id\r\n                ? msg.id === message.id\r\n                : msg.messageId ===\r\n                  ((<unknown>message) as ParsedMessageLegacy).messageId\r\n            )\r\n          ) {\r\n            messages.push(message);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ɵParsedMessage, ɵparseMessage } from '@angular/localize';\nimport { NodePath, PluginObj } from '@babel/core';\nimport { CallExpression } from '@babel/types';\nimport { ParsedMessageLegacy } from '../../../cmds/common/util';\n\nimport {\n  isGlobalIdentifier,\n  isNamedIdentifier,\n  unwrapMessagePartsFromLocalizeCall,\n  unwrapSubstitutionsFromLocalizeCall\n} from '../source_file_utils';\nimport { Diagnostics } from '../../common/diagnostics';\n\nexport function makeEs5ExtractPlugin(\n  messages: (ɵParsedMessage | ParsedMessageLegacy)[],\n  diagnostics: Diagnostics,\n  localizeName = '$localize'\n): PluginObj {\n  return {\n    visitor: {\n      CallExpression(callPath: NodePath<CallExpression>) {\n        const calleePath = callPath.get('callee');\n        if (\n          isNamedIdentifier(calleePath, localizeName) &&\n          isGlobalIdentifier(calleePath)\n        ) {\n          const messageParts = unwrapMessagePartsFromLocalizeCall(callPath);\n          const expressions = unwrapSubstitutionsFromLocalizeCall(\n            callPath.node\n          );\n          const message: ɵParsedMessage | ParsedMessageLegacy = ɵparseMessage(\n            messageParts,\n            expressions\n          );\n          if (\n            !messages.find((msg: any) =>\n              message.id\n                ? msg.id === message.id\n                : msg.messageId ===\n                  ((<unknown>message) as ParsedMessageLegacy).messageId\n            )\n          ) {\n            messages.push(message);\n          }\n        }\n      }\n    }\n  };\n}\n","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ɵParsedMessage } from '@angular/localize';\r\nimport { transformSync } from '@babel/core';\r\n\r\nimport { makeEs2015ExtractPlugin } from './source_files/es2015_extract_plugin';\r\nimport { makeEs5ExtractPlugin } from './source_files/es5_extract_plugin';\r\nimport { Diagnostics } from '../common/diagnostics';\r\n\r\n/**\r\n * A class that extracts parsed messages from file contents, by parsing the contents as JavaScript\r\n * and looking for occurrences of `$localize` in the source code.\r\n */\r\nexport class Extractor {\r\n  messages: ɵParsedMessage[] = [];\r\n\r\n  constructor(private diagnostics: Diagnostics) {}\r\n\r\n  extractMessages(sourceCode: string): void {\r\n    if (sourceCode.includes('$localize')) {\r\n      // Only bother to parse the file if it contains a reference to `$localize`.\r\n      transformSync(sourceCode, {\r\n        plugins: [\r\n          makeEs2015ExtractPlugin(this.messages, this.diagnostics),\r\n          makeEs5ExtractPlugin(this.messages, this.diagnostics)\r\n        ],\r\n        code: false,\r\n        ast: false\r\n      });\r\n    }\r\n  }\r\n}\r\n","import { readFileSync, statSync } from 'fs';\r\nimport { sync } from 'glob';\r\nimport { basename, extname, posix, resolve } from 'path';\r\nimport { Diagnostics } from './common/diagnostics';\r\nimport { FileUtils } from './common/file_utils';\r\nimport {\r\n  getExtension,\r\n  getTranslationSerializer,\r\n  TranslationFormat\r\n} from './common/util';\r\nimport { Extractor } from './extract/extractor';\r\n\r\nexport const command = 'extract';\r\nexport const describe = 'Extract translations from your ivy application';\r\nexport const builder = {\r\n  s: {\r\n    alias: 'source',\r\n    required: true,\r\n    describe:\r\n      'A glob pattern indicating what files to search for translations, e.g. `./dist/**/*.js`. This can be absolute or relative to the current working directory.'\r\n  },\r\n  f: {\r\n    alias: 'format',\r\n    required: true,\r\n    describe: 'The format of the translation files to generate.',\r\n    choices: ['json', 'xlf', 'xmb', 'xlf2'],\r\n    default: 'json'\r\n  },\r\n  o: {\r\n    alias: 'outputPath',\r\n    required: true,\r\n    describe:\r\n      'A path to where the translation file will be written. This can be absolute or relative to the current working directory.'\r\n  },\r\n  l: {\r\n    alias: ['locale', 'locales'],\r\n    required: false,\r\n    type: 'array',\r\n    describe:\r\n      'The locale for the extracted file, \"en\" by default. If you use multiple locales (e.g. \"en fr es\"), a new file will be generated for each locale'\r\n  }\r\n};\r\n\r\nexport const handler = function(options) {\r\n  const diagnostics = new Diagnostics();\r\n  extractTranslations({\r\n    sourceGlob: options['s'] as string,\r\n    format: options['f'] as TranslationFormat,\r\n    outputPath: options['o'] as string,\r\n    locales: options['l'] as string[],\r\n    diagnostics\r\n  });\r\n  diagnostics.logMessages();\r\n  process.exit(diagnostics.hasErrors ? 1 : 0);\r\n};\r\n\r\nexport interface ExtractTranslationsOptions {\r\n  sourceGlob: string;\r\n  format: TranslationFormat;\r\n  outputPath: string;\r\n  locales?: string[];\r\n  diagnostics: Diagnostics;\r\n}\r\n\r\nexport function extractTranslations({\r\n  sourceGlob: source,\r\n  format,\r\n  outputPath: output,\r\n  locales = ['en'],\r\n  diagnostics\r\n}: ExtractTranslationsOptions) {\r\n  console.log(`Extracting translations from \"${source}\"`);\r\n  let filesToProcess = sync(resolve(source), {\r\n    absolute: true,\r\n    nodir: true\r\n  });\r\n  filesToProcess = FileUtils.dedup(filesToProcess, /\\-es(5|2015)\\./, '.');\r\n  output = resolve(output);\r\n  const generatedFiles: string[] = [];\r\n  let isFile: boolean;\r\n  try {\r\n    const stat = statSync(output);\r\n    isFile = stat.isFile();\r\n  } catch (e) {\r\n    isFile = !!extname(output);\r\n  }\r\n  if (isFile) {\r\n    if (locales.length > 1) {\r\n      diagnostics.error(\r\n        `Multiple locales detected (\"${locales.join(\r\n          ','\r\n        )}\") but output \"${output}\" is not a directory`\r\n      );\r\n      return;\r\n    }\r\n    const res = makeTranslationsFile(\r\n      filesToProcess,\r\n      posix.normalize(output),\r\n      source,\r\n      format,\r\n      locales[0],\r\n      diagnostics\r\n    );\r\n    if (res) {\r\n      generatedFiles.push(res);\r\n    }\r\n  } else {\r\n    filesToProcess.forEach(file => {\r\n      locales.forEach(locale => {\r\n        const newFileName = posix.join(\r\n          output,\r\n          basename(file, '.js').replace(/-es(5|2015)/, '') +\r\n            '.' +\r\n            locale +\r\n            '.' +\r\n            getExtension(format)\r\n        );\r\n        const res = makeTranslationsFile(\r\n          [file],\r\n          newFileName,\r\n          source,\r\n          format,\r\n          locale,\r\n          diagnostics\r\n        );\r\n        if (res) {\r\n          generatedFiles.push(res);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  if (!generatedFiles.length) {\r\n    diagnostics.error(\r\n      `No messages found. You should build the angular app without a language target for this command to work.`\r\n    );\r\n    return;\r\n  }\r\n}\r\n\r\nfunction makeTranslationsFile(\r\n  filesToProcess: string[],\r\n  fileOutput: string,\r\n  source: string,\r\n  format: TranslationFormat,\r\n  locale: string,\r\n  diagnostics: Diagnostics\r\n): string | null {\r\n  const extractor = new Extractor(diagnostics);\r\n  filesToProcess.forEach(file => {\r\n    const contents = readFileSync(file, 'utf8');\r\n    extractor.extractMessages(contents);\r\n  });\r\n\r\n  const serializer = getTranslationSerializer(format);\r\n  if (extractor.messages.length > 0) {\r\n    const translationFile = serializer.renderFile(\r\n      extractor.messages,\r\n      locale,\r\n      false\r\n    );\r\n    FileUtils.writeFile(fileOutput, translationFile);\r\n    console.log(`  Generated file \"${fileOutput}\"`);\r\n    return fileOutput;\r\n  }\r\n  return null;\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as yargs from 'yargs';\nimport * as findUp from 'find-up';\nimport * as fs from 'fs';\nconst configPath = findUp.sync(['.loclrc', '.locl.json']);\nconst config = configPath\n  ? JSON.parse(fs.readFileSync(configPath, { encoding: 'utf8' }))\n  : {};\n\nconst args = process.argv.slice(2);\nyargs\n  .config(config)\n  .commandDir('cmds')\n  .demandCommand()\n  .help()\n  .version(false)\n  .parse(args);\n"],"names":["chalk.yellow","chalk.red","chalk.blue","fs.readFileSync","path.dirname","fs.writeFileSync","fs.existsSync","fs.mkdirSync","fs.statSync","fs.unlinkSync","fs.readdirSync","path.resolve","fs.rmdirSync","DOCTYPE","t.stringLiteral","t.binaryExpression","t.isExpression","t.isBinaryExpression","t.parenthesizedExpression","t.isArrayExpression","t.isStringLiteral","findUp.sync","yargs\r\n    .config"],"mappings":"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"}